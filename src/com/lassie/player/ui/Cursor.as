/*** Lassie Engine Game Player* @author Greg MacWilliam.*/package com.lassie.player.ui{	import com.lassie.player.core.ICursor;	import com.lassie.player.model.InventoryItem;	import com.lassie.player.model.InventoryCollection;	import com.lassie.player.system.SystemParams;	import com.lassie.player.geom.RGB;	import com.lassie.utils.DisplayUtil;	import flash.display.MovieClip;	import flash.geom.ColorTransform;	import flash.geom.Rectangle;	import flash.ui.Mouse;	import flash.utils.Timer;	import flash.events.TimerEvent;	import flash.events.MouseEvent;	import flash.filters.GlowFilter;		final public class Cursor extends UILayer implements ICursor	{		// private		private var _itemModel:InventoryItem;		private var _itemDisplay:MovieClip;		private var _displaySet:String = "";		private var _tooltipFrame:String = "";		private var _hover:Boolean = false;		private var _wait:Boolean = false;		private var _waitStatus:Object;		private var _clickTimer:Timer;		private var _normalItem:ColorTransform;		private var _waitItem:ColorTransform;		private var _touchItemWasSelected:Boolean = false;				public function Cursor($display:MovieClip):void		{			super($display);			mouseEnabled = false;			mouseChildren = false;			cacheAsBitmap = true;			tweenType = UITweenType.ALPHA;						// create a (custom) double-click timer.			_clickTimer = new Timer(300, 1);						// create color tints for normal and waiting item displays.			_normalItem = new ColorTransform();			_waitItem = new ColorTransform(0.5, 0.5, 0.5, 1, 0, 0, 0, 0);			_waitStatus = {system:false, game:false};						display.x = 0;			display.y = 0;			Mouse.hide();		}				override public function toString():String {			return "[Cursor] ";		}				override protected function _finit():void		{			x = parent.mouseX;			y = parent.mouseY;			startDrag(true, new Rectangle(0, 0, gameDisplay.displayWidth, gameDisplay.displayHeight));			intro();		}		override public function destroy():void		{			super.destroy();			_clickTimer.stop();			_clickTimer = null;			clearItem();		}			//-------------------------------------------------	// Interface properties	//-------------------------------------------------					// Extreme override to allow the skip button to light up the lockout cursor:		public function setAbsoluteHover($enable:Boolean):void {		  if ($enable) {		    MovieClip(display).gotoAndStop('on');		  } else {		    _setDisplay();		  }		}				/**		* Get/set hover highlight enabled.		*/		public function get hover():Boolean {			return _hover;		}		public function set hover($enable:Boolean):void {			_hover = $enable;			_tooltipFrame = $enable ? _tooltipFrame : "";			_setDisplay();		}				/**		* Specifies the enabled status of the wait cursor within the game engine.		* This command is used exclusively by the engine and NOT the developer.		* Automatically assumes the maximum level of wait priority.		*/		public function get systemWait():Boolean {			return _waitStatus['system'];		}		public function set systemWait($enable:Boolean):void {			_waitStatus['system'] = $enable;			_updateWaitStatus();		}				/**		* Specifies the enabled status of the wait cursor by the XML API.		* Developer-controlled wait toggle gets lowest priority.		*/		public function get wait():Boolean {			return _waitStatus['game'];		}		public function set wait($enable:Boolean):void {			_waitStatus['game'] = $enable;			_updateWaitStatus();		}				/**		* Sets wait status for a specific system component.		* Multiple status keys are used by various engine systems.		* As long as one system is in wait mode, the cursor will remain waiting.		*/		public function setWaitStatus($key:String, $enable:Boolean):void {			_waitStatus[$key] = $enable;			_updateWaitStatus();		}				/**		* Updates wait status based on the queue of wait-status settings.		* Various systems within the engine may assign their own wait status settings.		* Wait status will be reflected as long as one system maintains wait status.		*/		private function _updateWaitStatus():void {			_wait = false;			for each (var i:Boolean in _waitStatus) {				if (i) {					_wait = true;					break;				}			}			_setDisplay();						// Add a keyboard input lock while cursor is in wait status.			uiKeyboard.setEnabledStatus('wait', !_wait);		}				/**		* Specifies whether this cursor is currently displaying a custom hover frame Label.		*/		public function get hasCustomTooltip():Boolean {			return _tooltipFrame != "";		}				/**		* Specifies whether this cursor has an item tooltip loaded.		*/		public function get hasItemTooltip():Boolean {			return !!_itemModel;		}				/**		* Specifies the id of the current item tooltip. Blank is returned if there is no item tooltip.		*/		public function get itemId():String {			return !!_itemModel ? _itemModel.id : "";		}				/**		* Gets the title of the current item tooltip. Blank is returned if there is no item tooltip.		*/		public function get itemTitle():String {			return !!_itemModel ? _itemModel.title : "";		}			//-------------------------------------------------	// Interface methods	//-------------------------------------------------				/**		* Enables this cursor's hover state using a custom frameLabel as the hover display.		*/		public function setTooltip($frameLabel:String=""):void {			_tooltipFrame = $frameLabel;			hover = true;		}				/**		* Loads an InventoryItem model as the cursor's item tooltip.		* @param itemId The id of the InventoryItem model to load.		*/		public function loadItem($itemId:String):void		{			clearItem();						// retrieve inventory item model			var $model:InventoryItem = gameModel.getItem($itemId);									if (!!$model && SystemParams.inventoryTouchEnabled) {				// TOUCH MODE				// Load model but NOT display.				_itemModel = $model;				_touchItemWasSelected = true;				stage.addEventListener(MouseEvent.MOUSE_UP, this._onDoubleClickItem);				uiContext.refresh();			}			else if (!!$model) {				// ITEM CURSOR MODE				// get item's MovieClip display asset				var $itemClip:MovieClip = gameLibrary.getMovieClipByAddress($model.asset);								// validate display				if (!!$itemClip) {					// set new item cursor display					_itemModel = $model;					_itemDisplay = $itemClip;					_itemDisplay.gotoAndStop($model.frameLabel);					addChild(_itemDisplay);					stage.addEventListener(MouseEvent.MOUSE_UP, this._onDoubleClickItem);					display.visible = false;				}				else {					// invalid item cursor display.					trace(this +'could not load item "'+ $model.id +'".');				}			}			else {				// invalid inventory item reference.				trace(this +'the item "'+ $itemId +'" does not exist.');			}		}				/**		* Sets the frame label of the item cursor tooltip display.		*/		public function setItemFrame($frameLabel:String):void {			if (!!_itemDisplay) _itemDisplay.gotoAndStop( $frameLabel );		}				/**		* Clears any existing item cursor.		*/		public function clearItem():void		{			// clear listener for double-clicks			stage.removeEventListener(MouseEvent.MOUSE_UP, this._onDoubleClickItem);			//stage.doubleClickEnabled = false;						if (!!_itemDisplay)			{				// clear item display from parent				if (!!_itemDisplay.parent) {					_itemDisplay.parent.removeChild(_itemDisplay);				}								// stop any child clips and nullify reference.				DisplayUtil.stopAllClips(_itemDisplay);				_itemDisplay.transform.colorTransform = new ColorTransform();				_itemDisplay.filters = null;			}						// reveal normal cursor display			display.visible = true;						// nullify all references			_itemDisplay = null;			_itemModel = null;			uiContext.refresh();		}			//-------------------------------------------------	// Instance methods	//-------------------------------------------------				/**		* Updates the cursor display based on all current conditions.		*/		private function _setDisplay():void		{			// SET STANDARD DISPLAY			// use custom frameLabel if provided, otherwise use on/off.			var $frameLabel:String = (_tooltipFrame != "") ? _tooltipFrame : (_wait ? "wait" : (_hover ? "on" : "off"));						// compose frame label as: [display set + frameLabel]			var $newLabel:String = _displaySet + $frameLabel;			var $display:MovieClip = display as MovieClip;						// attempt to set new label.			$display.gotoAndStop($newLabel);						// attempt to set the straight frame label if frame was not set.			if ($display.currentLabel != $newLabel) {				$display.gotoAndStop($frameLabel);			}						// SET ITEM DISPLAY			if (hasItemTooltip) {				// Has tooltip				_setTooltopDisplay();			}			else {				// No tooltip				display.visible = true;			}		}				/**		* Updates the tooltip display based on all current conditions.		*/		private function _setTooltopDisplay():void		{			// Abort all actions if there is no item display.			// Tooltips may not display when running in inventory-touch mode.			if (!_itemModel || !_itemDisplay) return;						// Tooltip is active			var $showItem:Boolean = (_tooltipFrame == "");			var $inven:InventoryCollection = gameModel.currentInventoryModel;			var $tint:ColorTransform = _normalItem;						if (_itemModel.hoverFrameLabel != "")			{				// Use custom hover frame				_itemDisplay.gotoAndStop(_hover ? _itemModel.hoverFrameLabel : _itemModel.frameLabel);			}			else if (!!$inven)			{				// Use inventory styling:				if ($inven.hoverStyle == CursorHoverStyle.TINT) {					// apply a color tint to the tooltip display.					var $rgb:RGB = RGB.parseNumber($inven.hoverColor);					var $normal:ColorTransform = new ColorTransform(1, 1, 1, 1, 0, 0, 0, 0);					var $hover:ColorTransform = new ColorTransform(0.5, 0.5, 0.5, 1, $rgb.red, $rgb.green, $rgb.blue, 0);					_itemDisplay.transform.colorTransform = $tint = (_hover && $showItem) ? $hover : $normal;				}				else {					// apply an outline around the tooltip display.					var $outline:GlowFilter = new GlowFilter($inven.hoverColor, 1, 5, 5, 10, 1);					_itemDisplay.filters = (_hover && $showItem) ? [$outline] : [];				}			}						// set tooltip visibility.			_itemDisplay.visible = $showItem;			_itemDisplay.transform.colorTransform = (_wait ? _waitItem : $tint);			display.visible = !$showItem;		}			//-------------------------------------------------	// Event handlers	//-------------------------------------------------				/**		* Performs a custom doubleClick service for the stage as a whole.		*/		private function _onDoubleClickItem($event:MouseEvent):void		{			if (!_touchItemWasSelected && SystemParams.inventoryTouchEnabled) {				// clear item on first mouseUp event after selecting a touch item.				clearItem();			}			else if (!_clickTimer.running) {				// reset timer with each new click.				_clickTimer.reset();				_clickTimer.start();			}			else {				// register a doubleClick if the timer is still running.				$event.stopPropagation();				_clickTimer.stop();				clearItem();			}						// always reset touch-item selection status.			_touchItemWasSelected = false;		}	}}/*public function _onBlurMove($event:MouseEvent):void{	var $rate:Number = GeomUtil.distance(_lastMouse, position);	var $blurX:Number = Math.abs(_lastMouse.x - position.x);	var $blurY:Number = Math.abs(_lastMouse.y - position.y);	var $throttle:Number = 0.25;		filters = [new BlurFilter($blurX * $throttle, $blurY * $throttle, 2)];	//var $angle:Number = GeomUtil.angleDegrees(_lastMouse, position);	_lastMouse = new Point(x, y);}*/