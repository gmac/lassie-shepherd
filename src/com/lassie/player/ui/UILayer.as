/*** Lassie Engine Game Player* @author Greg MacWilliam.*/package com.lassie.player.ui{	import com.lassie.player.tween.TweenCore;	import com.lassie.player.core.LPSprite;	import com.lassie.player.core.IUILayer;	import com.lassie.player.events.UIEvent;	import com.lassie.utils.DisplayUtil;	import flash.display.DisplayObject;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.geom.Rectangle;	import flash.geom.Point;	import flash.events.Event;		public class UILayer extends LPSprite implements IUILayer	{		// private		private var _display:Sprite;		private var _showSeconds:Number = 1;		private var _hideSeconds:Number = 1;		private var _enabled:Boolean = false;		private var _active:Boolean = false;		private var _tweenType:String = UITweenType.ALPHA;		private var _tweenSeconds:Number = 1;		private var _bounding:Rectangle;		private var _alpha:Number = 1;		private var _scale:Number = 1;		public function UILayer($display:Sprite=null):void		{			super();			mouseEnabled = false;						// fill display with a placeholder if no valid display was provided.			_display = ($display != null) ? $display : new Sprite();						// stop display if it is a MovieClip.			if (_display is MovieClip) {				MovieClip(_display).stop();			}						// configure layer's bounding rectangle.			_setBounding();		}				override public function destroy():void		{			stop();			while (numChildren > 0) removeChildAt(0);			DisplayUtil.stopAllClips(_display);			_display = null;			super.destroy();		}			//-------------------------------------------------	// Read-only properties	//-------------------------------------------------				/**		* Gets a reference to the display object.		*/		public function get display():Sprite {			return _display;		}		/**		* Gets the bounding box of the layer.		*/		public function get boundingBox():Rectangle {			return _bounding;		}				/**		* Tests if the display layer is currently on screen.		*/		public function get visibility():Boolean {			return contains(_display);		}				/**		* Tests if UI element is visible or in a reveal trend.		* true: if sprite is in a reveal animation or completely visible.		* false: if sprite is in a hide animation or completely hidden.		*/		public function get active():Boolean {			return _active;		}			//-------------------------------------------------	// Bounding box methods	//-------------------------------------------------			private function _setBounding():void		{			// get the rect display instance (if defined)			var $rect:DisplayObject = _display.getChildByName(UIInstanceName.RECT);						if ($rect != null) {				// if rect clip exists:				// set bounding based on rect clip,				// then clear rect clip display.				_bounding = $rect.getRect(this);				DisplayUtil.extractChild($rect);			}			else {				// if rect clip does not exist:				// set bounding based display's rectangle.				_bounding = _display.getRect(this);			}		}				protected function _registerUpperLeft():void		{					}				protected function _registerDefault():void		{			//_display		}			//-------------------------------------------------	// UILayer properties	//-------------------------------------------------			/**		* Specifies the number of seconds in the layer's reveal animation.		*/		public function get showSeconds():Number {			return _showSeconds;		}		public function set showSeconds($seconds:Number):void {			_showSeconds = $seconds;		}				/**		* Specifies the number of seconds in the layer's hide animation.		*/		public function get hideSeconds():Number {			return _hideSeconds;		}		public function set hideSeconds($seconds:Number):void {			_hideSeconds = $seconds;		}				/**		* Specifies the enabled status of the layer.		* A layer cannot be shown while disabled.		*/		public function get enabled():Boolean {			return _enabled;		}		public function set enabled($enable:Boolean):void {			_enabled = $enable;		}				/**		* Gets/sets the layer's position based on a Point object.		*/		public function get position():Point {			return new Point(x, y);		}		public function set position($coord:Point):void {			x = $coord.x;			y = $coord.y;		}				/**		* Defines a valid tween type.		*/		public function get tweenType():String {			return _tweenType;		}		public function set tweenType($property:String):void		{			// validate supplied tween value.			// type is not changed unless given a valid property.			switch ($property) {				case UITweenType.ALPHA:				case UITweenType.SCALE:					_tweenType = $property;					break;			}		}				/**		* Gets the value of the current tween property		*/		internal function get tweenValue():Number {			return Number(this[tweenType]);		}		internal function set tweenValue($value:Number):void {			this[tweenType] = $value;		}			//-------------------------------------------------	// Tween properties	//-------------------------------------------------				// alpha		override public function get alpha():Number {			return _alpha;		}		override public function set alpha($percent:Number):void		{			_setDisplay($percent);			_alpha = $percent;			_display.alpha = $percent;		}				// scale		public function get scale():Number {			return _scale;		}		public function set scale($percent:Number):void		{			_setDisplay($percent);			_scale = $percent;			_display.scaleX = _display.scaleY = $percent;		}			//-------------------------------------------------	// Tween methods	//-------------------------------------------------			/**		* Adds / removes the display from stage based on its tween percentage (>0:show, 0:hide)		*/		private function _setDisplay($percent:Number):void {			if ($percent > 0 && !contains(_display)) addChild(_display);			else if ($percent == 0 && contains(_display)) removeChild(_display);		}				/**		* Adjusts a tween's maximum duration relative to the starting and target tween values.		* @param $startValue: the property's starting percentage value (0 - 1)		* @param $targetValue: the target percentage value to tween the property to (0 - 1)		* @param $maxDuration: the full length of tween assuming the maximum possible range is tweened.		*/		protected function _getTweenDuration($startValue:Number, $targetValue:Number, $maxDuration:Number):Number		{			var $startLimit:Number = ($startValue < $targetValue) ? $startValue : 1-$startValue;			var $targetLimit:Number = ($startValue > $targetValue) ? $targetValue : 1-$targetValue;			return $maxDuration * (1 - ($startLimit + $targetLimit));		}			//-------------------------------------------------	// Tween calls	//-------------------------------------------------				/**		* Tweens the tween property to the target value.		* @param $targetAlpha: target alpha to tween the curtain to.		* @param $maxDuration: length of tween (in seconds) assuming that 100% of possible range is tweened.		*/		public function tweenTo($targetValue:Number, $maxDuration:Number=-1):void		{			// default the tween duration setting			if ($maxDuration < 0) $maxDuration = _tweenSeconds;						// stop any existing tween before configuring a new one.			stop();						// if the tween value is not already set and the duration is greater than 0.			if (tweenValue != $targetValue && $maxDuration > 0)			{				// adjust value and duration				$targetValue = Math.max(0, Math.min($targetValue, 1));				var $duration:Number = _getTweenDuration(tweenValue, $targetValue, $maxDuration);								// create tween param				var $param:Object = new Object();				$param[tweenType] = $targetValue;				$param.onComplete = this._onTweenComplete;								// start a new tween				TweenCore.tween(this, $duration, $param);			}			else			{				// set target value without tweening.				tweenValue = $targetValue;				_onTweenComplete();			}						_active = ($targetValue > 0);		}				/**		* Reveals the UI display.		* @param $tween: animate in the display using the layer's tween.		*/		public function show($tween:Boolean=true):void		{			// abort the reveal if the layer is disabled.			//if (!enabled) return;						if ($tween) {				_tweenSeconds = showSeconds;				tweenTo(1);			}			else {				stop();				tweenValue = 1;			}			_active = true;			dispatchEvent(new UIEvent(UIEvent.SHOW));		}				/**		* Hides the UI display.		* @param $tween: animate out the display using the layer's tween.		*/		public function hide($tween:Boolean=true):void		{			if ($tween) {				_tweenSeconds = hideSeconds;				tweenTo(0);			}			else {				stop();				tweenValue = 0;			}			_active = false;			dispatchEvent(new UIEvent(UIEvent.HIDE));		}				/**		* Toggles the UI display.		* @param $tween: animate out the display using the layer's tween.		*/		public function toggle($tween:Boolean=true):void {			active ? hide($tween) : show($tween);		}				/**		* Introduces display by cut-hiding and then revealing it.		*/		public function intro():void		{			hide(false);			show();		}				/**		* Exits the display by cut-revealing and then hiding it.		*/		public function outro():void		{			show(false);			hide();		}				/**		* Stops any tweens that are in progress.		*/		public function stop():void {			TweenCore.killTweensOf(this);		}			//-------------------------------------------------	// Event handlers	//-------------------------------------------------				/**		* Called by TweenCore when a tween has completed.		*/		private function _onTweenComplete($event:Event=null):void		{			dispatchEvent(new UIEvent(UIEvent.TWEEN_COMPLETE));						if (tweenValue == 1) {				dispatchEvent(new UIEvent(UIEvent.SHOW_COMPLETE));			}			else if (tweenValue == 0) {				dispatchEvent(new UIEvent(UIEvent.HIDE_COMPLETE));			}		}	}}