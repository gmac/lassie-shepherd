/*** Lassie Engine Game Player* @author Greg MacWilliam.*/package com.lassie.player.ui{	import com.lassie.player.model.Action;	import com.lassie.player.model.InventoryItem;	import com.lassie.player.model.InventoryCombo;	import com.lassie.player.core.IActionSelectable;	import com.lassie.player.core.ActionProperties;	import com.lassie.player.core.LPSprite;	import com.lassie.external.ILPInventorySlot;	import com.lassie.utils.DisplayUtil;	import flash.display.DisplayObject;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.geom.Rectangle;	import flash.geom.Point;	final public class InventorySlot extends LPSprite implements IActionSelectable, ILPInventorySlot	{		/**		* Specifies an ID for the inventory display slot.		* This value will be relayed on the cursor when spawning an item cursor. << not currently configured.		* An item cursor will not respond to the displayId that it spawned from. << not currently configured.		*/		public var slotId:int = -1;		// action select		private var _hovering:Boolean = false;		private var _timerEnabled:Boolean = false;		private var _actionFocus:Boolean = false;		private var _actionIndex:int = -1;		// private		private var _model:InventoryItem;		private var _display:MovieClip;		private var _hitArea:Sprite;		private var _asset:String = "";		public function InventorySlot():void		{			super();			mouseEnabled = true;			mouseChildren = false;			addEventListener(MouseEvent.MOUSE_OVER, this._onMouseOver);			addEventListener(MouseEvent.MOUSE_OUT, this._onMouseOut);			addEventListener(MouseEvent.MOUSE_DOWN, this._onMouseDown);			// create default display			_display = new MovieClip();			_display.stop();			// create hit area			_hitArea = new Sprite();			_hitArea.visible = false;			addChild(_hitArea);		}		/**		* Loads an inventory item by ID reference into the inventory slot.		*/		public function loadItem($itemId:String):void {			load( gameModel.getItem($itemId) );		}		/**		* Clears any item that is currently loaded into the slot.		*/		public function clear():void {			load( null );		}		/**		* Loads an inventory item model into the slot, or clear the slot if model is null.		*/		public function load($model:InventoryItem):void		{			cacheAsBitmap = false;			// if a valid model was loaded			if (!!$model)			{				// HAS MODEL TO LOAD				// cache the new model				_model = $model;				// if the model's asset is not already set				if (_model.asset != _asset)				{					// clear any existing display.					_clearDisplay();					// then set new asset.					_asset = _model.asset;					var $display:MovieClip = gameLibrary.getMovieClipByAddress(_asset);					_display = ($display != null) ? $display : new MovieClip();					addChild(_display);				}				// set display frame label.				_display.gotoAndStop(model.frameLabel);				_setHitArea();				// apply optimization.				if (_model.cacheAsBitmap) {					DisplayUtil.stopAllClips(_display);					cacheAsBitmap = true;				}			}			else			{				// NO MODEL TO LOAD				_model = null;				_clearDisplay();			}			// toggle visibility based on model status.			visible = (_model != null);		}		/**		* Renders an automatic hit area based on the rectangular bounding of the image display.		*/		private function _setHitArea():void		{			// clear existing hit area.			_hitArea.graphics.clear();			hitArea = null;			if (_model.autoHitArea)			{				var $rect:Rectangle = _display.getRect(this);				_hitArea.graphics.beginFill(0x000000, 0);				_hitArea.graphics.drawRect($rect.x, $rect.y, $rect.width, $rect.height);				_hitArea.graphics.endFill();				hitArea = _hitArea;			}		}		/**		* Clears any existing item display.		*/		private function _clearDisplay():void		{			// if slot has a display			if (!!_display) {				// clear display from any parent display list				if (!!_display.parent) {					_display.parent.removeChild(_display);				}				// stop all of the display's child animations.				DisplayUtil.stopAllClips(_display);				// nullify reference to display and asset.				_display = null;				_asset = "";			}			// disable bitmap caching to clear any stored display information.			cacheAsBitmap = false;		}		override public function destroy():void		{			removeEventListener(MouseEvent.MOUSE_OVER, this._onMouseOver);			removeEventListener(MouseEvent.MOUSE_OUT, this._onMouseOut);			removeEventListener(MouseEvent.MOUSE_DOWN, this._onMouseDown);			cacheAsBitmap = false;			_clearDisplay();			_model = null;		}	//-------------------------------------------------	// Read-only properties	//-------------------------------------------------		public function get model():InventoryItem {			return _model;		}		public function get display():MovieClip {			return _display;		}		/**		* Specifies the ID of the item model currently loaded into the slot.		*/		public function get itemId():String {			return !!_model ? _model.id : "";		}	//-------------------------------------------------	// IActionSelectable implementation	//-------------------------------------------------		/**		* Returns an XML snippit detailing parameters of this actionable target.		*/		public function get actionProps():Object {			return ActionProperties.create(ActionProperties.TYPE_ITEM, model.id, model.actionProps);		}		/**		* Sets the current action targeting the layer.		*/		public function setAction($index:int):void {			_actionIndex = _actionFocus ? $index : -1;			_setContext();		}		/**		* Clears the current action targeting the layer.		* @param $release: if true, the layer's link to the action selector is severed.		*/		public function clearAction($releaseFocus:Boolean=false):void {			if ($releaseFocus) _actionFocus = false;			_actionIndex = -1;			_setContext();		}		/**		* Calls a basic item action.		*/		public function callAction($index:int):void		{			var $action:Action;			// get action if model has not been cleared.			if (!!model) {				$action = model.actions.getActionAt($index);			}			// if a valid action was found,			if (!!$action)			{				// create a copy of the action.				$action = $action.clone();				$action.populateDefaultResponse();				$action.setDialoguePosition( _getDialoguePosition() );				// send the action to the controller for processing.				gameController.process($action);				// flash the contextual summary.				uiContext.execute();			}		}		/**		* Calls an item combination.		*/		public function callItemCombo($pairWith:String):void		{			var $combo:InventoryCombo;			var $action:Action;			if (!!model) {				// get InventoryCombo if slot's model has not been cleared.				$combo = gameModel.getItemCombo(model.id, $pairWith);				try {					$action = (!!$combo) ? $combo.action : gameModel.getItem( $pairWith ).defaultAction;				} catch ($error:Error) {					// do nothing.				}			}			// if a combo was found, pull a copy of its action.			$action = (!!$action) ? $action.clone() : new Action();			// populate action with a default item response, then send for processing.			$action.populateDefaultResponse("item", true);			$action.setDialoguePosition( _getDialoguePosition() );			gameController.process($action);		}		/**		* Runs any action that is currently targeting the layer.		* Resets and clears all actions and action focus.		*/		private function _runAction():void		{			if (_actionFocus && _actionIndex > -1) {				callAction(_actionIndex);				clearAction();			}			_actionFocus = false;		}		/**		* Updates the context display		*/		private function _setContext():void		{			if (model != null) {				// model exists: set contextual model information.				var $verb:String = (_actionIndex >= 0) ? model.actions.getTitleAt(_actionIndex) : "";				var $noun:String = (_hovering || _actionFocus) ? model.title : "";				uiContext.setSummary($noun, $verb);			}			else {				// model has been cleared: clear all context.				uiContext.setSummary("", "");			}		}		/**		* Gets the position for a dialogue subtitle placed immediately above the item.		*/		private function _getDialoguePosition():Point		{			if (gameModel.currentInventoryModel.dialogueOverItem) {				var $rect:Rectangle = this.getRect(gameDisplay as DisplayObject);				return new Point( $rect.x + ($rect.width / 2), $rect.y - 10);			}			return null;		}	//-------------------------------------------------	// Utilities	//-------------------------------------------------		/**		* Enable mouse-hold timer for verb disc interaction mode		*/		private function _enableTimer($enable:Boolean):void		{			if ($enable && !_timerEnabled)			{				// START				ActionSelect.dynamicTimer.addEventListener(TimerEvent.TIMER_COMPLETE, this._onMouseTimeOut);				ActionSelect.dynamicTimer.reset();				ActionSelect.dynamicTimer.start();			}			else if (!$enable && _timerEnabled)			{				// STOP				ActionSelect.dynamicTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, this._onMouseTimeOut);				ActionSelect.dynamicTimer.reset();			}			_timerEnabled = $enable;		}	//-------------------------------------------------	// Event handlers	//-------------------------------------------------		/**		* Mouse rollover		*/		private function _onMouseOver($event:MouseEvent):void		{			// Call cursor rollover IF:			// 1) The cursor does NOT have an item tooltip			// --OR--			// 2) There is an item tooltip with an item Id that is different than this slot.			if (!uiCursor.hasItemTooltip || uiCursor.itemId != this.itemId)			{				uiCursor.hover = true;				_hovering = true;				_setContext();			}		}		/**		* Mouse rollout		*/		private function _onMouseOut($event:MouseEvent):void		{			uiCursor.hover = false;			_hovering = false;			_setContext();		}		/**		* Generic mouse press		*/		private function _onMouseDown($event:MouseEvent):void		{			if (uiCursor.hasItemTooltip) {				// item combination				// only call combo if the cursor's item Id does not match this slot's item Id.				// IMPORTANT: this operation must nest inside the "hasItemTooltip" check,				// otherwise an item cursor click may bypass into an action selector call.				if (uiCursor.itemId != this.itemId) {					// stop event propagation so that proceeding mouse events (skip to click dia)					// do not respond to this initial click action.					$event.stopImmediatePropagation();					callItemCombo(uiCursor.itemId);				}			}			else if (ActionSelect.mode == ActionSelectMode.DYNAMIC) {				// disc action				_onMouseDownDynamic($event);			}			else if (ActionSelect.mode == ActionSelectMode.STATIC) {				// console action				_onMouseDownStatic($event);			}		}		/**		* Mouse press in DISC selector mode		*/		private function _onMouseDownDynamic($event:MouseEvent):void		{			// If puppet layer is configured for			stage.addEventListener(MouseEvent.MOUSE_UP, this._onMouseUpDynamic);			_enableTimer(true);		}		/**		* Mouse release in DYNAMIC selector mode		*/		private function _onMouseUpDynamic($event:MouseEvent):void		{			stage.removeEventListener(MouseEvent.MOUSE_UP, this._onMouseUpDynamic);			if (_actionFocus)			{				// if puppet had ActionSelect focus fixed on it, attempt to run actions.				// timer was cleared by timeout.				_runAction();			}			else if (_hovering && !!model)			{				// load the item model into the cursor.				uiCursor.loadItem(model.id);			}			// always clear the timer on mouse up			_enableTimer(false);		}		/**		* Mouse TimeOut in DISC mode		*/		private function _onMouseTimeOut($event:TimerEvent):void		{			_actionFocus = true;			uiActionSelector.activate(this);		}		/**		* Mouse press in STATIC selector mode		*/		private function _onMouseDownStatic($event:MouseEvent):void		{			// call action selector			if (uiActionSelector.staticActionIndex >= 0)			{				// Has selected action.				_actionFocus = true;				uiActionSelector.activate(this);				_runAction();				clearAction(true);			}			else if (!!model)			{				// No selected action.				// load the item model into the cursor.				uiCursor.loadItem(model.id);			}		}	}}