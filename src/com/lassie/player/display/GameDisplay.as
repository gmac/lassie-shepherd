/*** Lassie Engine Game Player* @author Greg MacWilliam.*/package com.lassie.player.display{	import com.lassie.player.*;	import com.lassie.player.core.*;	import com.lassie.player.room.*;	import com.lassie.player.ui.*;	import com.lassie.player.events.*;	import com.lassie.player.model.Room;	import com.lassie.utils.DisplayUtil;	import com.lassie.events.LassieEvent;	import com.lassie.external.LPFullScreenMode;	import flash.display.StageDisplayState;	import flash.display.StageScaleMode;	import flash.display.StageAlign;	import flash.display.StageQuality;	import flash.display.DisplayObject;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.text.TextField;	import flash.geom.Rectangle;	import flash.media.SoundTransform;	import flash.external.ExternalInterface;	import flash.events.EventDispatcher;	import flash.events.FullScreenEvent;	import flash.events.Event;	//import flash.text.Font;	final public class GameDisplay extends LPSprite implements IGameDisplay	{		// private		private var _displayWidth:int = 1024;		private var _displayHeight:int = 768;		private var _layouts:Sprite;		/**		* @private		* Constructs the game display container.		* Protected as a singleton object.		*/		public function GameDisplay($enforcer:GameDisplayEnforcer):void		{			super();			x = 0;			y = 0;		}		/** @private */		static private var _instance:GameDisplay;		/**		* Gets the Singleton instance reference.		*/		static public function getInstance():GameDisplay {			if (_instance == null) _instance = new GameDisplay(new GameDisplayEnforcer());			return _instance;		}	//-------------------------------------------------	// Placement / positioning methods	//-------------------------------------------------		/**		* @private		* Subscribes display to resize events when added to the stage.		*/		override protected function _init():void {			gameModel.addEventListener(ModelEvent.CHANGE_VOLUME, this._onVolumeChange, false, 0, true);			stage.addEventListener(FullScreenEvent.FULL_SCREEN, this._onScreenResize, false, 0, true);			setFullScreenMode( gameCache.fullScreenMode );			setGraphicsQuality( gameCache.graphicsQuality );			setDisplayVolume();		}		/**		* @private		* Unsubscribes display from resize events when removed from the stage.		*/		override protected function _uninit():void {			gameModel.removeEventListener(ModelEvent.CHANGE_VOLUME, this._onVolumeChange);			stage.removeEventListener(FullScreenEvent.FULL_SCREEN, this._onScreenResize);		}		/**		* Specifies the width of total game display area.		*/		public function get displayWidth():int {			return _displayWidth;		}		/**		* Specifies the height of total game display area.		*/		public function get displayHeight():int {			return _displayHeight;		}		/**		* Toggles full-screen display.		* DEPRECATED METHOD: this method has been replaced by "setFullScreenMode"		*/		/*public function setFullScreen($enable:Boolean):void {			stage.displayState = $enable ? gameSystem.fullScreenDisplayState : StageDisplayState.NORMAL;			// gameCache.fullScreen = $enable; << set on completion of resize.		}*/		/**		* Sets the fullscreen display mode.		*/		public function setFullScreenMode($mode:String):void		{			// validate screen mode setting.			if (!LPFullScreenMode.validate($mode)) $mode = LPFullScreenMode.OFF;			if (!gameSystem.showAllEnabled && $mode == LPFullScreenMode.FULL) $mode = LPFullScreenMode.CENTER;			if ($mode == LPFullScreenMode.CENTER) {				stage.align = StageAlign.TOP_LEFT;				stage.scaleMode = StageScaleMode.NO_SCALE;				//stage.quality = StageQuality.MEDIUM;				scrollRect = new Rectangle(0, 0, _displayWidth, _displayHeight);			}			else if ($mode == LPFullScreenMode.FULL) {				stage.align = StageAlign.TOP;				stage.scaleMode = StageScaleMode.SHOW_ALL;				//stage.quality = StageQuality.MEDIUM;				scrollRect = new Rectangle(0, 0, _displayWidth, _displayHeight);			}			else {				stage.align = StageAlign.TOP_LEFT;				stage.scaleMode = gameSystem.staticWindow ? StageScaleMode.SHOW_ALL : StageScaleMode.NO_SCALE;				//stage.quality = StageQuality.BEST;				scrollRect = null;			}			var $fs:Boolean = ($mode == LPFullScreenMode.CENTER || $mode == LPFullScreenMode.FULL);			stage.displayState = $fs ? gameSystem.fullScreenDisplayState : StageDisplayState.NORMAL;			_onScreenResize(null, $mode);		}		/**		* Sets the quality of the stage display.		*/		public function setGraphicsQuality( $quality:String ):void {			if ($quality == StageQuality.BEST || $quality == StageQuality.MEDIUM) stage.quality = $quality;		}		/**		* Sets the display volume based on the model's current FX volume setting.		*/		public function setDisplayVolume():void {			this.soundTransform = new SoundTransform( gameModel.soundfxVolume );		}	//-------------------------------------------------	// Startup process	//-------------------------------------------------		/**		* Loads all global graphics and constructs display architecture.		* @private		* 1a) Loads global libraries and configures the flash display.		*/		public function load():void		{			// create reference to source display scope			_setWindowSize(gameModel.stageWidth, gameModel.stageHeight);			// create curtain to hide display while loading			var $curtain:Curtain = new Curtain();			LassiePlayer.curtain = $curtain;			addChild($curtain);			// start load process			_loadAssets();		}		/**		* @private		* 1b) Sets the dimesions of the Flash window.		*/		private function _setWindowSize($width:int, $height:int):void		{			_displayWidth = $width;			_displayHeight = $height;			if (ExternalInterface.available && !gameSystem.staticWindow) {				var $js:String = "function(){";				$js += "var flash=document.getElementById('"+ ExternalInterface.objectID +"');";				$js += "var win=flash.parentNode;";				$js += "flash.style.width='100%';";				$js += "flash.style.height='100%';";				$js += "win.style.width='"+ $width +"px';";				$js += "win.style.height='"+ $height +"px';";				$js += "}";				ExternalInterface.call($js);			}			//scrollRect = new Rectangle(0, 0, $width, $height);		}		/*private function _setWindowSize($width:int, $height:int):void		{			_displayWidth = $width;			_displayHeight = $height;			if (ExternalInterface.available) {				var $js:String = "function(){";				$js += "var flash=document.getElementById('"+ ExternalInterface.objectID +"');";				$js += "var win=flash.parentNode;";				$js += "flash.style.width='100%';";				$js += "flash.style.height='100%';";				$js += "win.style.width='"+ $width +"px';";				$js += "win.style.height='"+ $height +"px';";				$js += "}";				ExternalInterface.call($js);			}			//scrollRect = new Rectangle(0, 0, $width, $height);		}*/		/**		* @private		* 2a) Configure and start the loading all external assets		*/		private function _loadAssets():void		{			var $loaderName:String = gameLibrary.getUniqueLoaderName();			var $libsToLoad:Array = new Array(gameModel.coreLibs, UIInstanceName.UI_SWF, UIInstanceName.MENU_SWF);			if (gameModel.systemVoiceEnabled) $libsToLoad.push(gameModel.voiceLibs);			//if (gameModel.voiceEnabled) $libsToLoad.push(gameModel.voiceLibs);			gameLibrary.addLoadListener($loaderName, LibraryEvent.COMPLETE, this._onAssetsReady);			gameLibrary.load($loaderName, $libsToLoad.join(","));		}		/**		* @private		* 2b) Library assets have finished loading, so proceed to build display.		*/		private function _onAssetsReady($event:LibraryEvent):void		{			gameLibrary.removeLoadListener($event.loaderName, LibraryEvent.COMPLETE, this._onAssetsReady);			_buildUI();		}		/**		* @private		* 3) Builds the game UI display.		*/		private function _buildUI():void		{			var $ui:MovieClip = gameLibrary.getSWF(UIInstanceName.UI_SWF);			var $menu:MovieClip = gameLibrary.getSWF(UIInstanceName.MENU_SWF);			var $actionDisplay:DisplayObject;			var $cursorDisplay:DisplayObject;			var $contextDisplay:DisplayObject;			var $inventoryDisplay:DisplayObject;			var $treeMenuDisplay:DisplayObject;			var $subtitleDisplay:DisplayObject;			var $skipDisplay:DisplayObject;			if ($ui != null)			{				//_registerFonts($ui);				$contextDisplay = DisplayUtil.extractChildByName($ui, UIInstanceName.CONTEXT);				$cursorDisplay = DisplayUtil.extractChildByName($ui, UIInstanceName.CURSOR);				$inventoryDisplay = DisplayUtil.extractChildByName($ui, UIInstanceName.INVENTORY);				$treeMenuDisplay = DisplayUtil.extractChildByName($ui, UIInstanceName.TREE_MENU);				$subtitleDisplay = DisplayUtil.extractChildByName($ui, UIInstanceName.SUBTITLE);				$skipDisplay = DisplayUtil.extractChildByName($ui, UIInstanceName.SKIP);				$actionDisplay = DisplayUtil.extractChildByName($ui, UIInstanceName.ACTION_SELECTOR);				DisplayUtil.stopAllClips($ui);			}			// ** create elements BELOW the curtain **			// ** adds elements from top down **			// add action selector below curtain			var $actions:IActionSelector = (ActionSelect.mode == ActionSelectMode.DYNAMIC) ?				new ActionSelectDynamic( $actionDisplay as MovieClip ) :				new ActionSelectStatic( $actionDisplay as MovieClip );			LassiePlayer.actionSelector = $actions;			addChildAt($actions as Sprite, 0);			// add subtitle			var $subtitle:Subtitle = new Subtitle( $subtitleDisplay as TextField );			LassiePlayer.subtitle = $subtitle;			addChildAt($subtitle, 0);			// add skip			var $skip:SkipButton = new SkipButton( $skipDisplay as MovieClip );			LassiePlayer.skip = $skip;			addChildAt($skip, 0);			// add tree menu			var $treeMenu:TreeMenu = new TreeMenu( $treeMenuDisplay as Sprite );			LassiePlayer.treeMenu = $treeMenu;			addChildAt($treeMenu, 0);			// add context			var $context:Context = new Context( $contextDisplay as TextField );			LassiePlayer.context = $context;			addChildAt($context, 0);			// add inventory			var $inventory:Inventory = new Inventory( $inventoryDisplay as Sprite );			LassiePlayer.inventory = $inventory;			addChildAt($inventory, 0);			// add room overlays			var $layouts:LayoutManager = new LayoutManager();			LassiePlayer.layouts = $layouts;			addChildAt($layouts, 0);			// ** create elements ABOVE the curtain **			// game menu			var $gameMenu:GameMenu = new GameMenu( $menu );			LassiePlayer.gameMenu = $gameMenu;			addChild($gameMenu);			// add watermark if software is unregistered.			if (!gameModel.hasLicenseKey) {				//addChild(new Watermark());			}			// cursor			var $cursor:Cursor = new Cursor( $cursorDisplay as MovieClip );			LassiePlayer.cursor = $cursor;			addChild($cursor);			_buildGame();		}		/**		* 3b) Registers all listed UI fonts with the game player		private function _registerFonts($movie:MovieClip):void		{			var $fonts:String = "fonts";			// if movie has a fonts list property			if ($movie.hasOwnProperty($fonts))			{				// parse string into a list of font class names				var $fontList:Array = $movie[$fonts].split(" ").join("").split(",");				// loop through each font				for each (var $fontName in $fontList)				{					try {						// register font with the main movie if the class definition exists.						if ($movie.loaderInfo.applicationDomain.hasDefinition($fontName)) {							Font.registerFont($movie.loaderInfo.applicationDomain.getDefinition($fontName) as Class);						}					}					catch($error:Error) {						trace("[GameDisplay] UI font could not be loaded.");					}				}			}		}		*/		/**		* 4a) Configures listeners that allow display to update upon changes to the model		*/		private function _buildGame():void		{			_setModelListeners();			//traceLayerOrder();			dispatchEvent(new DisplayEvent(DisplayEvent.DISPLAY_READY));		}		/**		* 4b) Configures listeners that allow display to update upon changes to the model		*/		private function _setModelListeners():void {		}	//-------------------------------------------------	// Watermark security	//-------------------------------------------------		/**		* Prevent display list modifiers from tampering with the watermark.		*/		// removeChild works normally except with the watermark.		final override public function removeChild($child:DisplayObject):DisplayObject {			if (!($child is Watermark)) return super.removeChild($child);			return null;		}		// removeChildAt works normally except with the watermark.		final override public function removeChildAt($index:int):DisplayObject {			if (!(getChildAt($index) is Watermark)) return super.removeChildAt($index);			return null;		}		// setChildIndex is disabled.		final override public function setChildIndex($child:DisplayObject, $index:int):void {			return;		}		// swapChildren is disabled.		final override public function swapChildren($child1:DisplayObject, $child2:DisplayObject):void {			return;		}		// swapChildrenAt is disabled.		final override public function swapChildrenAt($index1:int, $index2:int):void {			return;		}	//-------------------------------------------------	// Methods	//-------------------------------------------------		/**		* Clears any existing room and adds a new primary room display.		* @param roomId The identifier of the room to load.		* @param positionId The identifier of a starting position on which to center the room's initial scoll.		*/		public function setRoom($roomId:String, $startPositionId:String=""):void		{			clearRoom();			// get the room Id's data model.			gameModel.currentRoom = $roomId;			var $model:Room = gameModel.currentRoomModel;			if (!!$model)			{				// if model was found, create a room display.				var $room:RoomDisplay = new RoomDisplay($model, $startPositionId);				LassiePlayer.room = $room;				addChildAt($room, 0);				stage.dispatchEvent(new LassieEvent(LassieEvent.ROOM_CHANGE));			}		}		/**		* Clears any existing room.		*/		public function clearRoom():void		{			var $room:RoomDisplay = LassiePlayer.room as RoomDisplay;			if (!!$room)			{				$room.destroy();				$room.parent.removeChild($room);				LassiePlayer.room = null;			}		}		/**		* @private		* Traces current layer order. For debugging only.		*/		public function traceLayerOrder():void		{			for (var $j:int = numChildren-1; $j >= 0; $j--) {				trace($j + ":" + getChildAt($j));			}		}	//-------------------------------------------------	// Event handlers	//-------------------------------------------------		/** @private called directly upon setting stage full screen configuration, or upon pressing ESC to exit full screen */		private function _onScreenResize($event:FullScreenEvent=null, $mode:String=LPFullScreenMode.OFF):void		{			/**			* This event handler accepts TWO arguments because it is called both directly and by a FullScreenEvent.			* - This method is called directly upon setting full screen mode.			* - This method is tirggered by an event when full screen display mode changes.			*			* Respond to ALL direct method calls (event object is null). Direct calls will pass the new full screen setting.			* ONLY respond to FullScreenEvent calls when exiting full screen mode (ESC key press). Event calls will be assumed as OFF.			*/			if ($event == null || !$event.fullScreen)			{				if (gameSystem.showAllEnabled && $mode != LPFullScreenMode.CENTER) {					// if "showAll" is enabled and the display is NOT set to "center" mode,					// then toggle the display into TOP > SHOW_ALL display mode.					stage.align = StageAlign.TOP;					stage.scaleMode = StageScaleMode.SHOW_ALL;				}				if ($mode == LPFullScreenMode.CENTER) {					// center the game display on the stage display.					x = Math.round((stage.stageWidth - displayWidth) / 2);					y = Math.round((stage.stageHeight - displayHeight) / 2);				} else {					x = 0;					y = 0;				}				// commit new full-screen mode to the cache.				gameCache.fullScreenMode = $mode;			}		}		/**		* @private		* Called upon changing the model's volume setting. Updates display with the latest volume setting.		*/		private function _onVolumeChange($event:Event):void {			setDisplayVolume();		}	}}final internal class GameDisplayEnforcer {}