/*** Lassie Engine Game Player* @author Greg MacWilliam.*/package com.lassie.player.logic{	public class LogicParser	{		static private const STRING:String = "'";		static private const GROUP_OPEN:String = "(";		static private const GROUP_CLOSE:String = ")";		static private const VAR_OPEN:String = "[";		static private const VAR_CLOSE:String = "]";		static private const METHOD_OPEN:String = "{";		static private const METHOD_CLOSE:String = "}";		static private const FIELD_OPEN:String = "%*";		static private const FIELD_CLOSE:String = "*%";		static private const AND:String = "AND";		static private const OR:String = "OR";		static private const EQUAL:String = "EQ";		static private const NOT_EQUAL:String = "NE";		static private const GREATER:String = "GT";		static private const LESS:String = "LT";		static private const GREATER_EQUAL:String = "GE";		static private const LESS_EQUAL:String = "LE";		/** @private : value and method containers */		static private var _values:LogicValues = new LogicValues();		static private var _methods:LogicMethods = new LogicMethods();		/**		* Evaluates a full logical expression as true or false.		* @param Full expression to evaluate.		* @return True if expression validates.		*/		static public function eval($expression:String):Boolean		{			return _parseEval( parse($expression) );		}		/**		* Parses the values and methods of an expression.		* @param Full expression to evaluate.		* @return Parsed result string.		*/		static public function parse($expression:String):String		{			$expression = StringUtil.removeWhitespace($expression, STRING);			var $token:String;			var $parsed:String;			// fill in all values			$token = StringUtil.getEnclosureToken($expression, VAR_OPEN, VAR_CLOSE);			while (!!$token) {				$parsed = _parseValue( StringUtil.trim($token, VAR_OPEN, VAR_CLOSE) );				$expression = $expression.replace($token, $parsed);				$token = StringUtil.getEnclosureToken($expression, VAR_OPEN, VAR_CLOSE);			}			// call all methods			$token = StringUtil.getEnclosureToken($expression, METHOD_OPEN, METHOD_CLOSE);			while (!!$token) {				$parsed = _parseMethod( StringUtil.trim($token, METHOD_OPEN, METHOD_CLOSE) );				$expression = $expression.replace($token, $parsed);				$token = StringUtil.getEnclosureToken($expression, METHOD_OPEN, METHOD_CLOSE);			}			return $expression;		}		/**		* Parses logical expression fields into a text string.		* @param Full string from which to parse logic fields.		* @return Resulting string with all fields parsed into the text.		*/		static public function parseFields($expression:String):String		{			var $token:String = StringUtil.getEnclosureToken($expression, FIELD_OPEN, FIELD_CLOSE);			var $parsed:String;			while (!!$token) {				$parsed = parse( StringUtil.trim($token, FIELD_OPEN, FIELD_CLOSE) );				$expression = $expression.replace($token, $parsed);				$token = StringUtil.getEnclosureToken($expression, FIELD_OPEN, FIELD_CLOSE);			}			return $expression;		}	//-------------------------------------------------	// Parsers	//-------------------------------------------------		/**		* Evaluates a group defined by open and closing parenthesis as true or false.		* @param Full expression to evaluate.		* @return True if group expression validates.		*/		static private function _parseEval($expression:String):Boolean		{			var $token:String;			var $parsed:String;			// parse all groups			$token = StringUtil.getEnclosureToken($expression, GROUP_OPEN, GROUP_CLOSE);			while ($token != null) {				$parsed = _parseEval( StringUtil.trim($token, GROUP_OPEN, GROUP_CLOSE) ).toString();				$expression = $expression.replace($token, $parsed);				$token = StringUtil.getEnclosureToken($expression, GROUP_OPEN, GROUP_CLOSE);			}			// select a series operator			var $and:int = $expression.indexOf(AND);			var $or:int = $expression.indexOf(OR);			var $operator:String = ($and > $or) ? AND : OR;			var $result:Boolean = ($operator == AND); // << start AND as true, OR as false			// parse and evaluate all items within the series			var $series:Array = $expression.split($operator);			// "false" items within an AND operation will immediately invalidate.			// "true" items within an OR operation will validate result.			for each (var $eval:String in $series) {				var $valid:Boolean = _evalExpression($eval);				if ($operator == AND && !$valid) return false;				else if ($operator == OR && $valid) $result = true;			}			return $result;		}		/**		* Gets a variable and enters its resulting value into the main expression.		* @param field Name of variable to retrieve		* @return The value of the acquired variable.		*/		static private function _parseValue($field:String):String		{			if (_values.hasOwnProperty($field))			{				try {					return _values[$field];				} catch($error:Error) {					trace('[LogicParser] could not retrieve value "'+ $field +'".');				}			}			else			{				// pull a cached value if field is not native.				return _values.getCacheValue($field);			}			return "";		}		/**		* Calls a method and enters its resulting value into the main expression.		* Method should be formatted as "methodName:arg1,arg2,arg3"		* @param method Text definition of method call and parameters.		* @return The evaluated result of the method called.		*/		static private function _parseMethod($expression:String):String		{			// evaluate all nested methods			var $token:String = StringUtil.getEnclosureToken($expression, METHOD_OPEN, METHOD_CLOSE);			while ($token != null) {				var $parsed:String = _parseMethod( StringUtil.trim($token, METHOD_OPEN, METHOD_CLOSE) ).toString();				$expression = $expression.replace($token, $parsed);				$token = StringUtil.getEnclosureToken($expression, METHOD_OPEN, METHOD_CLOSE);			}			// evaluate method name and params list.			var $params:Array = ($expression+":").split(":");			var $method:String = $params[0];			var $methodParams:String = $params[1];			var $args:Array = ($methodParams != "") ? $methodParams.split(",") : new Array();			if (_methods.hasOwnProperty($method))			{				try {					return _methods[$method].apply(_methods, $args);				} catch($error:Error) {					trace('[LogicParser] could not call method "'+ $method +'".');				}			}			return "";		}	//-------------------------------------------------	// Evaluators	//-------------------------------------------------		/**		* Evaluates a compound expression with two values split by an operator.		* @param Full expression text to evaluate.		* @return True if expression validates.		*/		static private function _evalExpression($expression:String):Boolean		{			var $param:Array;			if ($expression == String(true)) {				return true;			}			else if ($expression.indexOf(EQUAL) > -1) {				$param = $expression.split(EQUAL);				return _evalEqualTo( $param[0], $param[1] );			}			else if ($expression.indexOf(NOT_EQUAL) > -1) {				$param = $expression.split(NOT_EQUAL);				return !_evalEqualTo( $param[0], $param[1] );			}			else if ($expression.indexOf(GREATER_EQUAL) > -1) {				$param = $expression.split(GREATER_EQUAL);				return _evalGreaterThan( $param[0], $param[1], true );			}			else if ($expression.indexOf(GREATER) > -1) {				$param = $expression.split(GREATER);				return _evalGreaterThan( $param[0], $param[1] );			}			else if ($expression.indexOf(LESS_EQUAL) > -1) {				$param = $expression.split(LESS_EQUAL);				return _evalLessThan( $param[0], $param[1], true );			}			else if ($expression.indexOf(LESS) > -1) {				$param = $expression.split(LESS);				return _evalLessThan( $param[0], $param[1] );			}			return false;		}		/**		* Tests if two values are equal.		* @param a First candidate value.		* @param b Second candidate value.		* @return A is equal to B.		*/		static private function _evalEqualTo($a:String, $b:String):Boolean		{			$a = StringUtil.trim($a, STRING, STRING);			$b = StringUtil.trim($b, STRING, STRING);			// resolve 1/true and 0/false as valid comparisons.			if (($a == String(true) && $b == "1") || ($a == "1" && $b == String(true))) return true;			if (($a == String(false) && $b == "0") || ($a == "0" && $b == String(false))) return true;			// otherwise, test for relative equality.			return $a == $b;		}		/**		* Evaluates two numeric values as A > B or A >= B.		* @param a The value to test as the greater.		* @param b The value to test as the lesser.		* @param equality Validate equal values.		* @return A is greater than [or equal to] B.		*/		static private function _evalGreaterThan($a:String, $b:String, $equality:Boolean=false):Boolean		{			var $na:Number = parseInt($a);			var $nb:Number = parseInt($b);			if (!isNaN($na) && !isNaN($nb)) {				return $equality ? $na >= $nb : $na > $nb;			}			return false;		}		/**		* Evaluates two numeric values as A < B or A <= B.		* @param a The value to test as the lesser.		* @param b The value to test as the greater.		* @param equality Validate equal values.		* @return A is less than [or equal to] B.		*/		static private function _evalLessThan($a:String, $b:String, $equality:Boolean=false):Boolean		{			var $na:Number = parseInt($a);			var $nb:Number = parseInt($b);			if (!isNaN($na) && !isNaN($nb)) {				return $equality ? $na <= $nb : $na < $nb;			}			return false;		}	}}