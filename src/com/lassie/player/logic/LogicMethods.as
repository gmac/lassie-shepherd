/*** Lassie Engine Game Player* @author Greg MacWilliam.*/package com.lassie.player.logic{	import com.lassie.player.core.LPDispatcher;	import com.lassie.player.control.Targeting;	import com.lassie.player.model.InventoryCollection;	import com.lassie.player.model.RoomLayer;	import com.lassie.player.model.RoomLayerState;	final internal class LogicMethods extends Object	{		// private		private var _api:LPDispatcher;		private var _math:MathParser;		/**		* Builds a new instance of game methodology.		*/		public function LogicMethods():void		{			super();			_api = new LPDispatcher();			_math = new MathParser();		}		/**		* Performs a mathematical computation on an expression string.		*/		public function math($exp:String):Number {			try {				return _math.eval( _math.parse($exp) );			}			catch($error:Error) {				_api.gameDebug.echo("[LogicMethods] math error.");			}			return -1;		}		/**		* Evals an expression with the logic parser...		* For testing purposes only.		*/		public function eval($expression:String):Boolean {			return LogicParser.eval($expression);		}		/**		* Echos a message into the Lassie debugger panel.		*/		public function echo($message:String):void {			_api.gameDebug.echo($message);		}		/**		* Tests if the specified item ID has been added at some point to the specified inventory.		*/		public function hasAddedItem($inventoryId:String, $itemId:String):Boolean {			var $inven:InventoryCollection = Targeting.getInventory( $inventoryId );			if (!!$inven) return $inven.containsInHistory($itemId);			return false;		}		/**		* Tests if the specified item ID exists within the specified inventory.		*/		public function hasItem($inventoryId:String, $itemId:String):Boolean {			var $inven:InventoryCollection = Targeting.getInventory( $inventoryId );			if (!!$inven) return $inven.contains($itemId);			return false;		}		/**		* Returns a comma-seperated list of all item IDs currently contained within the specified inventory.		*/		public function getItemsList($inventoryId:String):String {			var $inven:InventoryCollection = Targeting.getInventory( $inventoryId );			if (!!$inven) return $inven.contents.join(",");			return "";		}		/**		* Counts the number of items currently contained within the specified inventory.		*/		public function countItems($inventoryId:String):int {			var $inven:InventoryCollection = Targeting.getInventory( $inventoryId );			return $inven.contents.length;		}		/**		* Tests if a method with the specified name has been defined within the methodology table.		*/		public function hasMethod($methodName:String):Boolean {			return _api.gameModel.methodology.hasMethod($methodName);		}		/**		* Gets the value of a layer property.		*/		public function getLayerProp($roomId:String, $layerId:String, $prop:String):String		{			var $layer:RoomLayer = Targeting.getLayer($layerId, Targeting.getRoom($roomId));			if (!!$layer) {				try {					if ($layer.hasOwnProperty($prop)) return ($layer[$prop]).toString();				} catch ($error:Error) {					// do nothing.				}			}			return "";		}		/**		* Gets the value of a layer state property.		*/		public function getLayerStateProp($roomId:String, $layerId:String, $stateId:String, $prop:String):String		{			var $state:RoomLayerState = Targeting.getLayerState($stateId, Targeting.getLayer($layerId, Targeting.getRoom($roomId)));			if (!!$state) {				try {					if ($state.hasOwnProperty($prop)) return ($state[$prop]).toString();				} catch ($error:Error) {					// do nothing.				}			}			return "";		}		/**		* Tests if the specified tree topic is currently enabled or not.		*/		public function getTreeTopicEnabled($roomId:String, $treeId:String, $topicId:String):Boolean		{			try {				// attempt to set the enabled status of the requested topic.				return _api.gameModel.getRoom( $roomId ).getTree( $treeId ).getTopicById( $topicId ).enabled;			} catch ($error:Error) {				// do nothing.			}			return false;		}		/**		* Sets a variable within the game cache.		*/		public function setCacheVar($field:String, $value:String):void {			_api.gameController.setCacheVar($field, $value);		}		/**		* Renders a comma-separated list variable from the cache with a custom delimiter and optional sorting.		*/		public function renderCacheList($field:String, $sort:String, $join:String=","):String {			var $list:Array = _api.gameController.getCacheVar($field).split(",");			if ($sort == "1") $list.sort();			return $list.join($join);		}		/**		* Counts the number of items in a comma-separated list.		*/		public function countCacheList($field:String):int {			var $list:Array = _api.gameController.getCacheVar($field).split(",");			return $list.length;		}		/**		* Gets a list formatted for human readability, with commas between items and the word "and" before the last item.		*/		public function formatCacheList($field:String, $and:String):String {			var $list:Array = _api.gameController.getCacheVar($field).split(",");			if ($list.length < 2) return $list[0];			var $last:String = $list.pop();			return $list.join(", ") +' '+$and+' '+ $last;		}	}}