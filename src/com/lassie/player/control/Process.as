/*** Lassie Engine Game Player* @author Greg MacWilliam.*/package com.lassie.player.control{	import com.lassie.player.model.Action;	import com.lassie.player.events.ControllerEvent;	import flash.events.Event;	import flash.events.KeyboardEvent;	final public class Process extends Command	{		// [static] counter for incrementing new instance Id's.		static private var _itable:Object = new Object();		static private var _trunkId:String = "";		/**		* Unregisters a process instance with the class.		*/		static private function _unregister($process:Process):void		{			// clear trunk reference, if applicable.			if (_trunkId == $process.id) _trunkId = "";			// clear object reference from the instance table.			if (_itable.hasOwnProperty($process.id)) delete _itable[$process.id];		}		/**		* Gets a process by identifier.		*/		static private function _getProcess($id:String):Process		{			if (_itable.hasOwnProperty($id)) {				return _itable[$id] as Process;			}			return null;		}		/**		* Creates a new process from an action object.		* Creating a new process will stop and clear the current trunk unless specifically designated as a branch.		*/		static public function create($action:Action, $branch:Boolean=false, $orphan:Boolean=false):Process		{			// generate class key to enable new process creation.			var $key:ProcessKey = new ProcessKey();			// if this is NOT a branch process			if (!$branch) {				// clear any existing trunk process				clearTrunk();				// set new trunk reference				_trunkId = $key.id;			}			// create new process and register it with the class.			var $process:Process = new Process($action, $key, $orphan);			_itable[$key.id] = $process;			// call and return the process.			$process.call();			return $process;		}		/**		* Stops and clears the current trunk process.		*/		static public function clearTrunk():void		{			var $trunk:Process = _getProcess(_trunkId);			if ($trunk != null) $trunk.destroy();			_trunkId = "";		}		/**		* Stops and clears all branch processes.		static public function clearBranches():void		{			for (var $id:String in _itable) {				if ($id != _trunkId) _getProcess($id).destroy();			}		}*/		/**		* Stops and clears all processes (trunk and branches).		* @param $exclude: specifies a single process to skip while clearing the instance table.		*/		static public function clear($exclude:Process=null):void		{			// gets the id of the process instance to exclude.			var $excludeId:String = ($exclude != null) ? $exclude.id : "";			// loop through and destroy all non-excluded id's.			for (var $id:String in _itable) {				if ($id != $excludeId) {					var $process:Process = _getProcess($id);					if (!$process.orphan) $process.destroy();				}			}		}		/**		* Pauses activity by stopping all processes.		*/		static public function pause():void {			for (var $id:String in _itable) _getProcess($id).stop();		}		/**		* Plays activity by resuming all processes.		*/		static public function play():void {			for (var $id:String in _itable) _getProcess($id).resume();		}		/**		* Skips through all processes directly to their end points.		*/		static public function skip($all:Boolean=true):void		{			if ($all) {				// skip over all processes.				for (var $id:String in _itable) _getProcess($id).skip();			} else {				// only skip the trunk process				// branch processes will continue running.				var $trunk:Process = _getProcess(_trunkId);				if (!!$trunk) $trunk.skip();			}		}	//-------------------------------------------------	// Instance configuration	//-------------------------------------------------		// public		public var dialogue:Array;		// private		private var _id:String = "";		private var _orphan:Boolean = false;		private var _queue:Array;		private var _active:Command;		private var _endScript:XML;		private var _skipToEndEnabled:Boolean = false;		public function Process($action:Action, $key:ProcessKey, $orphan:Boolean=false):void		{			super();			// set process identifier based on creation key.			_id = $key.id;			_orphan = $orphan;			// configure instance.			_queue = new Array();			dialogue = $action.getDialogueQueue();			addScript($action.script);			//>> trace("CREATE: " + this);		}		/**		* Gets the process' internal Id value.		*/		public function get id():String {			return _id;		}		/**		* Specifies if the process is orphaned.		* Orphaned processes are retained within the instance table,		* however they are not cleared during room transitions.		*/		public function get orphan():Boolean {			return _orphan;		}		/**		* Traces a process summary to string.		*/		override public function toString():String {			return "[Process] id:"+ id +", ("+ _queue +") :: ("+ dialogue +")";		}	//-------------------------------------------------	// Destroyer	//-------------------------------------------------		/**		* Stops and destroys the process.		* NOTE: This is a SELF-DESTROYING class instance.		* a process destroys itself when its queue is empty or after it is skipped.		*/		override public function destroy():void		{			//>> trace("DESTROY: "+ this +"\n");			_enableSkipToEnd(false);			_clearActiveCommand();			purgeQueue();			_queue = null;			_endScript = null;			dialogue = null;			// unregister process with the class			Process._unregister(this);		}		/**		* @private		* Stops and clears the active command.		*/		private function _clearActiveCommand():void		{			if (_active != null) {				_active.removeEventListener(ControllerEvent.COMMAND_COMPLETE, this._onCommandComplete);				_active.stop();				_active.destroy();				_active = null;			}		}	//-------------------------------------------------	// Control methods	//-------------------------------------------------		/**		* Runs the queue of commands.		*/		override protected function _run():void		{			// test if there are commands left in the queue			if (_queue.length > 0)			{				// HAS COMMANDS IN QUEUE				_active = _queue.shift() as Command;				_active.addEventListener(ControllerEvent.COMMAND_COMPLETE, this._onCommandComplete);				//trace("> " + _active);				_active.call();			}			else			{				// NO COMMANDS REMAIN				destroy();			}		}		/**		* Stops the currently running command.		*/		override public function stop():void {			if (!!_active) _active.stop();		}		/**		* Resumes the currently running command.		*/		override public function resume():void {			if (!!_active) _active.resume();		}		/**		* Skips through all commands in the queue, immediately instigating their results.		*/		override public function skip():void		{			// skip and clear any active command.			if (!!_active) {				_active.removeEventListener(ControllerEvent.COMMAND_COMPLETE, this._onCommandComplete);				_active.skip();				_active.destroy();				_active = null;			}			// loop through the process queue and skip all commands.			while (_queue.length > 0) {				var $command:Command = _queue.shift() as Command;				$command.skip();				// Abort skipping process when a skip break point is reached.				if ($command is SequenceControl && SequenceControl($command).breakPoint) {					_clearActiveCommand();					_run();					return;				}				$command.destroy();			}			// destroy process.			destroy();		}	//-------------------------------------------------	// Command methods	//-------------------------------------------------		/**		* Parses script commands into the queue.		* @param script Script XML who's children will be parsed into the queue		* @param stack if TRUE, new commands will be stacked into the front of the queue.		*/		public function addScript($script:XML, $stack:Boolean=false):void		{			// Parse main node as a command, then queue if valid.			var $command:Command = CommandFactory.create($script, this);			var $append:Array = new Array();			// log parent script node if it is a valid command.			if (!!$command) $append.push($command);			// create a command based on each one of script's child nodes.			for each (var $child:XML in $script.children())			{				$command = CommandFactory.create($child, this);				if (!!$command) {					// add new command at the front or back of queue					$append.push($command);				}			}			// add new commands at the front or back of the queue.			_queue = $stack ? $append.concat(_queue) : _queue.concat($append);		}		/**		* Purges all scripts currently in the queue		*/		public function purgeQueue():void		{			while (_queue.length > 0) {				var $command:Command = _queue.shift() as Command;				$command.destroy();			}		}		/**		* Assigns an ending action to the process.		*/		public function setEndScript($script:XMLList, $skip:Boolean=false):void		{			_endScript = new XML('<'+ CommandName.GENERIC +'/>');			_endScript.appendChild( $script );			if ($skip) _enableSkipToEnd( true );		}		/**		* Purges all process configuration and runs the end script.		*/		public function callEndScript():void		{			if (!!_endScript) {				_enableSkipToEnd(false);				_clearActiveCommand();				purgeQueue();				addScript( _endScript );				_run();			}		}		/**		* Toggles the enabled status of skip-to-end.		*/		private function _enableSkipToEnd($enable:Boolean):void {			if ($enable && !_skipToEndEnabled) {				stage.addEventListener(KeyboardEvent.KEY_DOWN, this._onSkipToEnd, false, 0, true);			} else if (!$enable && _skipToEndEnabled) {				stage.removeEventListener(KeyboardEvent.KEY_DOWN, this._onSkipToEnd);			}			_skipToEndEnabled = $enable;		}	//-------------------------------------------------	// Event handlers	//-------------------------------------------------		private function _onCommandComplete($event:Event):void {			_clearActiveCommand();			_run();		}		private function _onSkipToEnd($event:KeyboardEvent):void {			if ($event.keyCode == gameSystem.skipKeyCode) callEndScript();		}	}}/** Key for generating Process objects.* Acts as a psudo singleton enforcer.*/final internal class ProcessKey{	// static counter for generating unique process instances	static private var _counter:int = 0;	// private	private var _id:String = "";	public function ProcessKey():void	{		// generate unique process id.		_id = "p"+(_counter++);	}	/*	* [read-only]: process identifier.	*/	public function get id():String {		return _id;	}}