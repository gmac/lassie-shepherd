/*** Lassie Engine Game Player* @author Greg MacWilliam.*/package com.lassie.player.control{	import com.lassie.player.events.UIEvent;	import com.lassie.utils.XmlUtil;		/**	* CurtainControl manages the appearance and behavior of the game's dissolve transition overlay.	* TIME-BASED.	*/	final internal class CurtainControl extends ProcessCommand	{		// private		private var _toAlpha:Number = -1;		private var _waitForComplete:Boolean = false;		private var _tweenListener:Boolean = false;		private var _skipTween:Boolean = false;				/**		* <curtain blackout="1" to="0.5" waitForComplete="1"/>		*/		public function CurtainControl():void		{			super();		}	//-------------------------------------------------	// Process methods	//-------------------------------------------------			override public function destroy():void		{			_enableTweenListener(false);			super.destroy();		}				override internal function parse($xml:XML):void {			_sourceXML = $xml;			_waitForComplete = XmlUtil.parseBoolean(_sourceXML.@waitForComplete, true);						if (_sourceXML.@blackout != undefined) {				// declare target alpha based on blackout toggle.				_toAlpha = XmlUtil.parseBoolean(_sourceXML.@blackout) ? 1 : 0;			}			else if (_sourceXML.@to != undefined) {				// parse target alpha from "to" parameter.				_toAlpha = parseFloat(_sourceXML.@to);			}		}				override public function toString():String {			return "[CurtainControl]";		}			//-------------------------------------------------	// Control methods	//-------------------------------------------------				override protected function _run():void		{			var $seconds:Number = -1;						if (_sourceXML.@color != undefined) {				// set curtain color.				uiCurtain.fillColor = _sourceXML.@color;			}						if (_sourceXML.@seconds != undefined) {				// pull seconds duration.				$seconds = _sourceXML.@seconds;			}						if (_toAlpha >= 0 && uiCurtain.alpha != _toAlpha)			{				// Has alpha target that is not currently set to the curtain display...				if (_skipTween)				{					// DO NOT TWEEN.					uiCurtain.tweenTo(_toAlpha, 0);				}				else if (_waitForComplete)				{					// TWEEN AND WAIT FOR COMPLETE.					_enableTweenListener(true);					uiCurtain.tweenTo(_toAlpha, $seconds);					return;				}				else				{					// TWEEN AND CONTINUE.					uiCurtain.tweenTo(_toAlpha, $seconds);				}			}						// call complete.			_complete();		}				override public function stop():void {			if (_tweenListener) uiCurtain.stop();		}				override public function resume():void {			if (_tweenListener) uiCurtain.tweenTo(_toAlpha);		}				override protected function _skipBeforeCall():void {			_waitForComplete = false;			_skipTween = true;			_run();		}				override protected function _skipAfterCall():void {			if (_tweenListener) {				uiCurtain.tweenTo(_toAlpha, 0);				_enableTweenListener(false);			}		}			//-------------------------------------------------	// Command methods	//-------------------------------------------------				/**		* Enables / disables the curtain tween listener.		*/		private function _enableTweenListener($enable:Boolean):void		{			if ($enable && !_tweenListener) {				uiCurtain.addEventListener(UIEvent.TWEEN_COMPLETE, this._onTweenComplete, false, 0, true);			}			else if (!$enable && _tweenListener) {				uiCurtain.removeEventListener(UIEvent.TWEEN_COMPLETE, this._onTweenComplete);			}			_tweenListener = $enable;						// block all keyboard input while waiting on the transition.			uiKeyboard.enabled = !$enable;		}				/**		* Tween is complete.		*/		private function _onTweenComplete($event:UIEvent):void {			_enableTweenListener(false);			_complete();		}	}}