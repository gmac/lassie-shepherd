/*** Lassie Engine Game Player* @author Greg MacWilliam.*/package com.lassie.player.control{	import com.lassie.player.core.LPDispatcher;	import com.lassie.player.room.RoomLayerDisplay;	import com.lassie.events.LassieEvent;	import flash.display.DisplayObjectContainer;	import flash.display.MovieClip;	/**	* The TimelineManager registers and releases MovieClip timeline references given to the LassiePlayer for control.	* MovieClip instances must add and remove themselves from the manager using the LassieEvent ADD_TIMELINE and REMOVE_TIMELINE events.	* Once a MovieClip is registered with the table, it will be subject to being stopped and played	*/	final public class TimelineManager extends LPDispatcher	{		/** @private Singleton instance reference */		private static var _instance:TimelineManager;		/**		* Gets the singleton instance reference.		*/		public static function getInstance():TimelineManager {			if (!_instance) _instance = new TimelineManager(new TimelineManagerEnforcer());			return _instance;		}		private const DELIMITER:String = ".";		private var _targets:Object;		public function TimelineManager($enforcer:TimelineManagerEnforcer):void {			super();			_targets = new Object();		}	//-------------------------------------------------	// Public API	//-------------------------------------------------		/**		* Adds a timeline to the manager.		*/		public function addTimeline($mc:MovieClip):void		{			var $ref:String = _getReference($mc);			if ($ref != "") _targets[ $ref ] = 0;		}		/**		* Removes a timeline from the manager.		*/		public function removeTimeline($mc:MovieClip):void		{			var $ref:String = _getReference($mc);			if (_targets.hasOwnProperty( $ref )) delete _targets[$ref];		}		/**		* Plays all timelines registered with the manager.		*/		public function play():void		{			for each (var $key:String in _targets) {				var $mc:MovieClip = _getTimeline( $key );				if (!!$mc && _targets[$key] > 0) {					$mc.gotoAndPlay( _targets[$key] );					_targets[$key] = 0;				}			}		}		/**		* Pauses all timelines registered with the manager.		*/		public function pause():void		{			for each (var $key:String in _targets) {				var $mc:MovieClip = _getTimeline( $key );				if (!!$mc) {					$mc.stop();					_targets[ $key ] = $mc.currentFrame;				}			}		}		/**		* Clears all timelines registered with the manager.		*/		public function clear():void {			for each (var $key:String in _targets) delete _targets[ $key ];		}	//-------------------------------------------------	// Utility methods	//-------------------------------------------------		/**		* Creates a reference string targeting the specified MovieClip instance.		* Reference format: layerId/0/1		*/		private function _getReference($mc:MovieClip):String		{			var $target:Array = new Array();			while (!!$mc.parent)			{				if ($mc is RoomLayerDisplay) {					$target.unshift( RoomLayerDisplay($mc).id );					return $target.join(DELIMITER);				}				else {					$target.unshift( $mc.parent.getChildIndex($mc) );					$mc = $mc.parent;				}			}			return "";		}		/**		* Fetches a MovieClip instance based on a reference string.		*/		private function _getTimeline($ref:String):MovieClip		{			var $target:Array = $ref.split(DELIMITER);			var $display:DisplayObjectContainer = gameRoom.getLayer( $target.shift() );			var $index:int = 0;			if (!!$layer)			{				while ($target.length > 0 && !!$display)				{					$index = parseInt( $target.shift() );					if ($index > 0 && $index < $display.numChildren) $display = $display.getChildAt($index) as DisplayObjectContainer;					else return null;				}				return $display as MovieClip;			}			return null;		}	}}internal class TimelineManagerEnforcer {}