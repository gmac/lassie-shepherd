/*** Lassie Engine Game Player* @author Greg MacWilliam.*/package com.lassie.player.control{	import flash.utils.Timer;	import flash.events.TimerEvent;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.events.Event;	import flash.ui.Keyboard;	import com.lassie.player.model.Dialogue;	import com.lassie.player.core.IPuppetDisplay;	import com.lassie.utils.XmlUtil;	import com.gmac.sound.ISoundObject;	final internal class DialogueControl extends ProcessCommand	{		// [static] timer to clock the display of dialogue items.		static private var _timer:Timer = new Timer(1000, 1);		// [static] subtitle display durations.		static public var baseTime:int = 400;		static public var scaleTime:int = 50;		static public var restTime:int = 400;		// private		private var _queue:Array;		private var _activeDia:Dialogue;		private var _skipEnabled:Boolean = false;		private var _diaTimerEnabled:Boolean = false;		private var _restTimerEnabled:Boolean = false;		private var _playing:Boolean = false;		private var _skipable:Boolean = true;		private var _voice:ISoundObject;		/**		* <dialogue play="* / _none / X,Y,Z" release="X"/>		*/		public function DialogueControl():void {			super();		}	//-------------------------------------------------	// Process methods	//-------------------------------------------------		override public function destroy():void		{			super.destroy();			_stopVoice();			_enableSkipping(false);			_enableDiaTimer(false);			_enableRestTimer(false);			_setPuppetSpeakAnim(false);			uiSubtitle.clearDisplay();			_playing = false;			_activeDia = null;			_queue = null;		}		override public function toString():String {			return "[DialogueControl]";		}	//-------------------------------------------------	// Control methods	//-------------------------------------------------		override protected function _run():void		{			_loadQueue();			_runQueue();		}		override public function stop():void		{			_timer.stop();			_setPuppetSpeakAnim(false);		}		override public function resume():void		{			_timer.start();			_setPuppetSpeakAnim(true);		}		override protected function _skipBeforeCall():void		{			_loadQueue();		}		override protected function _skipAfterCall():void		{			// ...?		}	//-------------------------------------------------	// Command methods	//-------------------------------------------------		/**		* 1) Loads dialogue from the parent process into this dialogue queue.		*/		private function _loadQueue():void		{			_queue = new Array();			var $total:int = parentProcess.dialogue.length;			// GENERAL PLAY METHODS			if (_sourceXML.@play != undefined)			{				var $play:String = _sourceXML.@play;				if ($play == KeyValues.ALL)				{					// Pull all lines.					_queue = parentProcess.dialogue.splice(0, $total);				}				else if ($play == KeyValues.RANDOM)				{					// Pull a single random line.					var $random:Number = Math.floor($total * Math.random());					$random = Math.max(0, Math.min($random, $total-1));					_queue = parentProcess.dialogue.splice($random, 1);				}				else if ($play == KeyValues.NONE)				{					return;				}			}			// RELEASE A LIST OF LINE INDICES			else if (_sourceXML.@playList != undefined)			{				// Pull a list of specific lines, referenced by index.				var $list:Array = _sourceXML.@playList.toString().split(",");				for each (var $j:String in $list) {					var $index:Number = parseInt($j);					// Queue the dialogue line if it is a valid index within range of the list bounds.					if (!isNaN($index) && $index >= 0 && $index < $total) {						_queue.push( Dialogue(parentProcess.dialogue[$index]).clone() );					}				}			}			// RELEASE FIRST X DIALOGUE LINES			else if (_sourceXML.@playBatch != undefined)			{				var $release:Number = parseInt( _sourceXML.@playBatch.toString() );				if (isNaN($release)) $release = $total;				$release = Math.max(0, Math.min($release, $total));				// extract dialogue from parent queue and run the dialogue sequence.				_queue = parentProcess.dialogue.splice(0, $release);			}			// Set skipable status:			if (_sourceXML.@skipable != undefined) {			  _skipable = XmlUtil.parseBoolean(_sourceXML.@skipable);			}		}		/**		* [static] Gets the max number of lines available to pull from a dialogue queue.		* Available as a static method for use by the ProcessSpawn object.		*/		static public function getLineLimit($lineCount:int, $queue:Array):int		{			if ($lineCount < 0) return $queue.length;			return Math.min($lineCount, $queue.length);		}		/**		* 2) Runs the loaded queue, one dialogue item at a time.		*/		private function _runQueue():void		{			if (_queue.length > 0)			{				// HAS DIALOGUE TO PLAY				// set active dialogue model				_activeDia = _queue.shift() as Dialogue;				if (!gameModel.voiceEnabled)				{					// VOICE IS DISABLED					// populate subtitle if voice is disabled.					_setSubtitle(true);				}				else				{					// VOICE IS ENABLED					// otherwise, attempt to set voice track.					var $validSound:Boolean = _setVoice();					// populate subtitle if enabled or if voice was invalid.					if (gameModel.subtitleEnabled || !$validSound) _setSubtitle(!$validSound);				}				// enable puppet's speaking animation.				_setPuppetSpeakAnim(true);				_enableSkipping(_skipable);				_playing = true;			}			else			{				// NO MORE DIALOGUE				_complete();			}		}	//-------------------------------------------------	// Utility methods	//-------------------------------------------------		/**		* Enables/disables the puppet's speaking animation.		*/		private function _setPuppetSpeakAnim($enable:Boolean):void		{			if (!!_activeDia)			{				var $puppet:IPuppetDisplay = getRoomPuppet(_activeDia.puppet);				if (!!$puppet) {					$enable ? $puppet.setSpeakState( _activeDia.frame ) : $puppet.setRestState();				}			}		}		/**		* Sets the active dialogue's subtitle display		* @param $useTimer: if true, the subtitle's display duration is timed relative to text length.		*/		private function _setSubtitle($useTimer:Boolean):void		{			uiSubtitle.setDisplay(_activeDia);			if ($useTimer)			{				_enableDiaTimer(true);				// calculate base and growth duration based on current subtitle scale setting.				var $speed:Number = gameModel.subtitleSpeed;				//var $base:Number = (DialogueControl.baseTime / 2) + (DialogueControl.baseTime * $speed);				//var $growth:Number = (DialogueControl.scaleTime / 2) + (DialogueControl.scaleTime * $speed);				//_timer.delay = $base + (_activeDia.subtitle.length * $growth);				var $time:Number = DialogueControl.baseTime + (_activeDia.subtitle.length * DialogueControl.scaleTime);				var $percent:Number = ($speed - 0.5) / 0.5;				var $scale:Number = ($percent < 0) ? 0.5 : 2; // << multiplier scale, added as "time + (time * mod)"				$time += ($time * $scale * $percent);				// configure timer for dialogue duration.				_timer.delay = $time;				_timer.reset();				_timer.start();			}		}		/**		* Sets the active dialogue's voice track.		* @return Boolean: true if audio track was successfully configured.		*/		private function _setVoice():Boolean		{			if (!!_activeDia)			{				// get sound player				_voice = gameSound.playVoice(_activeDia.sound);				// wait for complete if a player was created...				if (!!_voice) {					// listen for complete and return.					_voice.addEventListener(Event.COMPLETE, this._onDialogueComplete, false, 0, true);					return true;				}			}			return false;		}		/**		* Stops any voice that is currently playing.		*/		private function _stopVoice():void		{			if (!!_voice) {				_voice.stop();				_voice.removeEventListener(Event.COMPLETE, this._onDialogueComplete);				_voice = null;			}		}		/**		* Enables / disables the subtitle timer.		*/		private function _enableDiaTimer($enable:Boolean):void		{			if ($enable && !_diaTimerEnabled) {				_enableRestTimer(false);				_timer.addEventListener(TimerEvent.TIMER_COMPLETE, this._onDialogueComplete, false, 0, true);				_timer.reset();			}			else if (!$enable && _diaTimerEnabled) {				_timer.removeEventListener(TimerEvent.TIMER_COMPLETE, this._onDialogueComplete);				_timer.stop();			}			_diaTimerEnabled = $enable;		}		/**		* Enables / disables the post-dialogue rest timer.		*/		private function _enableRestTimer($enable:Boolean):void		{			if ($enable && !_restTimerEnabled) {				_enableDiaTimer(false);				_timer.delay = DialogueControl.restTime;				_timer.addEventListener(TimerEvent.TIMER_COMPLETE, this._onRestComplete, false, 0, true);				_timer.reset();			}			else if (!$enable && _restTimerEnabled) {				_timer.removeEventListener(TimerEvent.TIMER_COMPLETE, this._onRestComplete);				_timer.stop();			}			_restTimerEnabled = $enable;		}		/**		* Enable skipping controls.		*/		private function _enableSkipping($enable:Boolean):void		{			if ($enable && !_skipEnabled)			{				// set mouse-click skipping.				if (gameSystem.diaMouseSkip) {					stage.addEventListener(MouseEvent.MOUSE_DOWN, this._onDialogueComplete, false, 0, true);					stage.mouseChildren = false;					//uiCursor.systemWait = true;					uiCursor.setWaitStatus('dia', true);				}				// set keyboard skipping.				stage.addEventListener(KeyboardEvent.KEY_DOWN, this._onKeyDown, false, 0, true);				stage.focus = stage;			}			else if (!$enable && _skipEnabled)			{				// release mouse-click skipping.				if (gameSystem.diaMouseSkip) {					stage.removeEventListener(MouseEvent.MOUSE_DOWN, this._onDialogueComplete);					stage.mouseChildren = true;					//uiCursor.systemWait = false;					uiCursor.setWaitStatus('dia', false);				}				// release keyboard skipping.				stage.removeEventListener(KeyboardEvent.KEY_DOWN, this._onKeyDown);			}			_skipEnabled = $enable;		}	//-------------------------------------------------	// Timer methods	//-------------------------------------------------		private function _onKeyDown($event:KeyboardEvent):void		{			// ignore key press if dialogue and skip keys are the same, and the main skip control is enabled.			var $ignore:Boolean = (gameSystem.skipKeyCode == gameSystem.diaSkipKeyCode && uiSkip.enabled);			if ($event.keyCode == gameSystem.skipKeyCode && !uiSkip.enabled)			{				// IF: main skip key was pressed AND main skip control is not enabled.				// purge all remaining dialogue within the queue.				while (_queue.length > 0) _queue.shift();				_onDialogueComplete($event);			}			else if ($event.keyCode == gameSystem.diaSkipKeyCode && !$ignore)			{				// differ to dialogue-complete handler when skip hotkey is pressed.				// handler call will take cake of clearing line and reconfiguring the timer.				_onDialogueComplete($event);			}		}		private function _onDialogueComplete($event:Event):void		{			if (_playing)			{				// deactive dialogue sequence				_stopVoice();				_setPuppetSpeakAnim(false);				uiSubtitle.clearDisplay();				_activeDia = null;				_playing = false;				if (_queue.length > 0) {					// Has additional dialogue:					// configure rest timer.					_enableRestTimer(true);					_timer.start();				}				else {					// No more dialogue:					// call for completion.					_complete();				}			}		}		private function _onRestComplete($event:Event):void		{			_enableRestTimer(false);			_runQueue();		}	}}