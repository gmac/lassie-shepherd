/*** Lassie Engine Game Player* @author Greg MacWilliam.*/package com.lassie.player.control{	import flash.utils.Timer;	import flash.events.TimerEvent;	import flash.events.Event;	/**	* The Wait command will add a time delay into a command sequence.	* This delay can be timed in seconds, or it can be an indefinite period of time until an event is recieved through the stage.	*/	final internal class WaitControl extends ProcessCommand	{		// private		private var _eventType:String;		private var _timerEnabled:Boolean = false;		private var _timer:Timer;		/**		* <wait seconds="3"/>		*/		public function WaitControl():void		{			super();			_timer = new Timer(1000, 1);		}	//-------------------------------------------------	// Process methods	//-------------------------------------------------		override public function destroy():void		{			// cleanup any registered stage event.			if (!!_eventType) stage.removeEventListener(_eventType, this._onTrapStageEvent);			// cleanup any timer operation.			_enableTimer(false);			_timer.stop();			_timer = null;		}		override public function toString():String {			return "[WaitControl]";		}	//-------------------------------------------------	// Control methods	//-------------------------------------------------		override protected function _run():void		{			// Check for a wait duration in seconds.			if (_sourceXML.@seconds != undefined)			{				// SECONDS DURATION				var $seconds:Number = parseInt(_sourceXML.@seconds);				if (!isNaN($seconds))				{					_timer.delay = $seconds * 1000;					_enableTimer(true);					_timer.start();					return;				}			}			// Check for a wait duration in milliseconds.			if (_sourceXML.@ms != undefined)			{				// MILLISECONDS DURATION				var $ms:Number = parseInt(_sourceXML.@ms);				if (!isNaN($ms))				{					_timer.delay = $ms;					_enableTimer(true);					_timer.start();					return;				}			}			// Check for a wait duration defined by a stage event.			if (_sourceXML.@stageEvent != undefined)			{				// EVENT DURATION				_eventType = _sourceXML.@stageEvent;				stage.addEventListener(_eventType, this._onTrapStageEvent, false, 0, true);				return;			}			// proceed if no wait period was resolved.			_complete();		}		override public function stop():void {			_timer.stop();		}		override public function resume():void {			_timer.start();		}		override protected function _skipBeforeCall():void {			// do nothing.		}		override protected function _skipAfterCall():void {			// call complete. cleanup will be performed in the destroyer.			_complete();		}	//-------------------------------------------------	// Command methods	//-------------------------------------------------		/**		* Enables / disables the subtitle timer.		*/		private function _enableTimer($enable:Boolean):void		{			if ($enable && !_timerEnabled) {				_timer.addEventListener(TimerEvent.TIMER_COMPLETE, this._onTimerComplete, false, 0, true);				_timer.reset();			}			else if (!$enable && _timerEnabled) {				_timer.removeEventListener(TimerEvent.TIMER_COMPLETE, this._onTimerComplete);				_timer.stop();			}			_timerEnabled = $enable;		}		/**		* Timer is complete.		*/		private function _onTimerComplete($event:TimerEvent):void {			_enableTimer(false);			_complete();		}		/**		* Traps an event recieved from the stage.		*/		private function _onTrapStageEvent($event:Event):void {			// call complete. cleanup will be performed in the destroyer.			_complete();		}	}}