/*** Lassie Engine Game Player* @author Greg MacWilliam.*/package com.lassie.player.control{	import flash.events.Event;	import flash.display.DisplayObject;	import com.lassie.events.LassieEvent;	import com.lassie.events.LassieMenuEvent;	import com.lassie.player.events.ModelEvent;	import com.lassie.player.core.LPDispatcher;	import com.lassie.player.core.IGameController;	import com.lassie.player.logic.LogicParser;	import com.lassie.player.model.Action;	import com.lassie.player.model.Script;	import com.lassie.player.model.Dialogue;	import com.lassie.player.ui.InventorySlot;	import com.lassie.external.ILassiePlayer;	import com.lassie.external.ILPInventorySlot;	/**	* Main controller console for the game engine.	* This console manages the processing of scripts and actions.	*/	final public class GameController extends LPDispatcher implements IGameController, ILassiePlayer	{		/**		* @private		* Creates the GameController. Requires a singleton enforcer key to allow instantiation.		*/		public function GameController($enforcer:GameControllerEnforcer):void {			super();		}		/** @private Singleton instance reference */		private static var _instance:GameController;		/**		* Gets the singleton instance reference.		*/		public static function getInstance():GameController {			if (_instance == null) _instance = new GameController(new GameControllerEnforcer());			return _instance;		}	//-------------------------------------------------	// Overrides	//-------------------------------------------------		public function load():void		{			// listen for script call events propagating through the display.			stage.addEventListener(LassieEvent.SCRIPT, this._onCatchScriptEvent);			// LAUNCH THE APPLICATION			// attempt to launch using the designated game startup script.			// otherwise, default to opening the game menu.			var $default:XML = new XML('<'+ CommandName.GENERIC +'/>');			$default.appendChild(<menu display="show"/>);			_runScript(KeyValues.STARTUP_SCRIPT, $default);		}	//-------------------------------------------------	// Process methods	//-------------------------------------------------		/**		* Processes all dialogue and script associated with a game action.		* @param action The Action object to process. Action objects are data structures containing scripts and dialogue.		* @param branch Specifies if this action should be processed as a branch.		* Branch process run independently from any existing processes that are currently running.		*/		public function process($action:Action, $processAsBranch:Boolean=false):void {			Process.create($action, $processAsBranch);		}		/**		* Creates a new game Action object with the specified XML snippit, then processes it.		* @param action The XML snippit to compile then process.		* @param branch Specifies if this action should be processed as a branch.		* Branch process run independently from any existing processes that are currently running.		*/		public function processXML($xml:XML, $processAsBranch:Boolean=false):void		{			var $action:Action = new Action();			$action.addScript($xml);			Process.create($action, $processAsBranch);		}	//-------------------------------------------------	// Game session methods	//-------------------------------------------------		/**		* Specifies if game play has launched yet by loading a room.		*/		public function get gameHasLaunched():Boolean {			return !!gameRoom;		}		/**		* Gets an array of all saved game names.		*/		public function get savedGames():Array {			// block command if the menu is unregistered.			if (!uiGameMenu.allowMenuAccess) return new Array();			return gameCache.savedGamesList;		}		/**		* Specifies the index of the currently active game.		*/		public function get activeGameIndex():int {			return -1;		}		/**		* Specifies if a previous game session exists that can be continued.		*/		public function get hasContinueGame():Boolean {			return gameCache.hasAutoSave;		}		/**		* Continues the last auto-saved game session.		*/		public function continueGame():void {			// block command if the menu is unregistered.			if (!uiGameMenu.allowMenuAccess) return;			_resetDisplay();			gameCache.addEventListener(ModelEvent.LOAD_GAME_COMPLETE, this._onLoadGameComplete, false, 0, true);			gameCache.autoResume();		}		/**		* Start a new game.		* Resets display, creates new data within cache, and then launches the new game.		*/		public function newGame():void {			// block command if the menu is unregistered.			if (!uiGameMenu.allowMenuAccess) return;			_resetDisplay();			gameCache.addEventListener(ModelEvent.NEW_GAME_COMPLETE, this._onNewGameComplete, false, 0, true);			gameCache.newData();		}			/** @private called upon creation of a new game within the cache */			private function _onNewGameComplete($event:Event):void			{				gameCache.removeEventListener(ModelEvent.NEW_GAME_COMPLETE, this._onNewGameComplete);				_runScript(KeyValues.START_GAME_SCRIPT);				_runScript(KeyValues.NEW_GAME_SCRIPT, _getConfigScript());				dispatchEvent( new LassieMenuEvent(LassieMenuEvent.LOAD_COMPLETE) );			}		/**		* Loads a saved game.		* Resets display, loads data into the cache, and then launches the game.		*/		public function loadGame($slot:uint):void {			// block command if the menu is unregistered.			if (!uiGameMenu.allowMenuAccess) return;			_resetDisplay();			gameCache.addEventListener(ModelEvent.LOAD_GAME_COMPLETE, this._onLoadGameComplete, false, 0, true);			gameCache.loadData($slot);		}			/** @private called upon loading a game within the cache */			private function _onLoadGameComplete($event:Event):void			{				gameCache.removeEventListener(ModelEvent.LOAD_GAME_COMPLETE, this._onLoadGameComplete);				// run start, then load, then call configuration.				_runScript(KeyValues.START_GAME_SCRIPT);				_runScript(KeyValues.LOAD_GAME_SCRIPT);				processXML( _getConfigScript() );				dispatchEvent( new LassieMenuEvent(LassieMenuEvent.LOAD_COMPLETE) );			}		/**		* Saves any current game data.		* Saves data out of cache and waits for completion.		*/		public function saveGame($slot:uint, $name:String):void {			// block command if the menu is unregistered.			if (!uiGameMenu.allowMenuAccess) return;			gameCache.addEventListener(ModelEvent.SAVE_GAME_COMPLETE, this._onSaveGameComplete, false, 0, true);			gameCache.saveData($slot, $name);		}			/** @private called upon saving a game out of the cache */			private function _onSaveGameComplete($event:Event):void {				gameCache.removeEventListener(ModelEvent.SAVE_GAME_COMPLETE, this._onSaveGameComplete);				dispatchEvent( new LassieMenuEvent(LassieMenuEvent.SAVE_COMPLETE) );			}		/**		* Clears all game data from the specified slot index.		* Clears data from cache and waits for completion.		*/		public function clearGame($slot:uint):void {			gameCache.addEventListener(ModelEvent.CLEAR_GAME_COMPLETE, this._onClearGameComplete, false, 0, true);			gameCache.clearData($slot);		}			/** @private called upon clearing a game from the cache */			private function _onClearGameComplete($event:Event):void {				gameCache.removeEventListener(ModelEvent.CLEAR_GAME_COMPLETE, this._onClearGameComplete);				dispatchEvent( new LassieMenuEvent(LassieMenuEvent.CLEAR_COMPLETE) );			}		/**		* Starts a new game using imported data from a foreign source.		*/		public function importGame($data:Object, $index:uint=0, $name:String=""):void {			// block command if the menu is unregistered.			if (!uiGameMenu.allowMenuAccess) return;			_resetDisplay();			gameCache.importData($data, $index, $name);			_runScript(KeyValues.START_GAME_SCRIPT);			_runScript(KeyValues.NEW_GAME_SCRIPT, _getConfigScript());		}		/**		* Exports a copy of raw game data.		*/		public function exportGame():Object {			// block command if the menu is unregistered.			if (!uiGameMenu.allowMenuAccess) return new Object();			return gameCache.getSessionData();		}	//-------------------------------------------------	// External interface methods	//-------------------------------------------------		/**		* Tests if a value exists within the game cache.		*/		public function hasCacheVar($field:String):Boolean {			return gameCache.getSessionVars().hasValue($field);		}		/**		* Gets a value from the game cache.		*/		public function getCacheVar($field:String):String {			return gameCache.getSessionVars().getValue($field);		}		/**		* Writes a value into the game cache.		*/		public function setCacheVar($field:String, $value:String):void {			gameCache.getSessionVars().setValue($field, $value);		}		/**		* Evaluates an expression within the logic API and returns a boolean of the outcome.		*/		public function logicEval($expression:String):Boolean {			return LogicParser.eval( $expression );		}		/**		* Parses an expression within the logic API and returns the textual outcome.		*/		public function logicParse($expression:String):String {			return LogicParser.parse( $expression );		}		/**		* Gets an object with properties detailing the current action target.		*/		public function getActionTargetInfo():Object {			return uiActionSelector.actionTargetProps;		}		/**		* Creates and returns a new InventorySlot object, cast as the external slot interface.		*/		public function getInventorySlot():ILPInventorySlot {			return new InventorySlot();		}		/**		* Provides a reference to the game's window frame display.		* This reference can be used to localize window coordinates.		*/		public function get window():DisplayObject {			return gameDisplay;		}		/**		* Specifies the width of the viewable window area.		*/		public function get windowWidth():int {			return gameDisplay.displayWidth;		}		/**		* Specifies the height of the viewable window area.		*/		public function get windowHeight():int {			return gameDisplay.displayHeight;		}		/**		* Specifies the title of the game.		*/		public function get gameTitle():String {			return gameModel.gameTitle;		}		/**		* Specifies the game author's name.		*/		public function get authorName():String {			return gameModel.authorName;		}		/**		* Specifies if the game has a valid license key.		*/		public function get hasLicenseKey():Boolean {			return gameModel.hasLicenseKey;		}		/**		* Specifies if the game is in an environment that can be quit from.		*/		public function get quitEnabled():Boolean {			return gameSystem.quitEnabled;		}		/**		* Quits the Lassie Player application.		*/		public function quit():void {			gameSystem.quit();		}		/**		* Provides a block of legal text that the user must agree to before first play.		*/		public function get legalText():String {			return gameSystem.legalText;		}		/**		* Specifies the user's acceptance status of the provided legal text.		*/		public function get hasAcceptedLegal():Boolean {			return gameCache.hasAcceptedLegal;		}		public function set hasAcceptedLegal($accept:Boolean):void {			gameCache.hasAcceptedLegal = $accept;		}		/**		* Specifies if the game is in an environment that supports fullscreen playback.		*/		public function get fullScreenEnabled():Boolean {			return gameSystem.fullScreenEnabled;		}		/**		* Specifies if the movie should display as full screen.		*/		public function get fullScreenMode():String {			return gameCache.fullScreenMode;		}		public function set fullScreenMode($mode:String):void {			// this value is comitted to the game cache upon stage resize:			// >> gameCache.fullScreen = $mode;			gameDisplay.setFullScreenMode($mode);		}		/**		* Specifies the game display's stage quality setting.		*/		public function get graphicsQuality():String {			return gameCache.graphicsQuality;		}		public function set graphicsQuality($quality:String):void {			gameCache.graphicsQuality = $quality;			gameDisplay.setGraphicsQuality($quality);		}		/**		* Specifies the game's current language setting.		*/		public function get languageOptions():Array {			return gameModel.languageOptions;		}		public function get language():String {			return gameModel.currentLanguage;		}		public function set language($key:String):void {			gameModel.currentLanguage = $key;		}		/**		* Specifies the percentage of the game's voice volume, expressed as a number between 0 and 1.		*/		public function get voiceVolume():Number {			return gameModel.voiceVolume;		}		public function set voiceVolume($percent:Number):void {			gameModel.voiceVolume = $percent;		}		/**		* Specifies the percentage of the game's sound FX volume, expressed as a number between 0 and 1.		*/		public function get soundfxVolume():Number {			return gameModel.soundfxVolume;		}		public function set soundfxVolume($percent:Number):void {			gameModel.soundfxVolume = $percent;		}		/**		* Specifies the percentage of the game's soundtrack volume, expressed as a number between 0 and 1.		*/		public function get soundtrackVolume():Number {			return gameModel.soundtrackVolume;		}		public function set soundtrackVolume($percent:Number):void {			gameModel.soundtrackVolume = $percent;		}		/**		* Specifies if voice is enabled within the game.		*/		public function get voiceEnabled():Boolean {			return gameModel.voiceEnabled;		}		public function set voiceEnabled($enable:Boolean):void {			gameModel.voiceEnabled = $enable;		}		/**		* Specifies if subtitles are enabled within the game.		*/		public function get subtitleEnabled():Boolean {			return gameModel.subtitleEnabled;		}		public function set subtitleEnabled($enable:Boolean):void {			gameModel.subtitleEnabled = $enable;		}		/**		* Specifies the speed of subtitle playback.		*/		public function get subtitleSpeed():Number {			return gameModel.subtitleSpeed;		}		public function set subtitleSpeed($percent:Number):void {			gameModel.subtitleSpeed = $percent;		}		/**		* Specifies the enabled status of game keyboard input.		*/		public function get keyboardEnabled():Boolean {			return uiKeyboard.enabled;		}		public function set keyboardEnabled($enable:Boolean):void {			uiKeyboard.enabled = $enable;		}		/**		* Recieves a dialogue XML snippit, then converts it to an action and processes it.		*/		public function playDialogue($xml:XML):void		{			var $action:Action = new Action();			var $dia:Dialogue;			// test if dialogue has nested content nodes.			if ($xml.dia.length() > 0)			{				// HAS NESTED CONTENT				// loop through and add all child <dia> nodes.				for each (var $node:XML in $xml.dia) {					$dia = Dialogue.create($node);					if (!!$dia) $action.addDialogue($dia);				}			}			else {				// NO NESTED CONTENT				// just parse the parent dialogue node.				$dia = Dialogue.create($xml);				if (!!$dia) $action.addDialogue($dia);			}			// test if any dialogue was collected.			if($action.numDialogue > 0) {				var $script:String = '<'+CommandName.GENERIC+'>';				$script += '<'+ CommandName.DIALOGUE +' play="*"/>';				$script += '<'+ CommandName.FLASH +' stageEvent="'+ LassieEvent.DIALOGUE_COMPLETE +'"/>';				$script += '</'+CommandName.GENERIC+'>';				$action.addScript( new XML($script) );				process($action, true);			}		}	//-------------------------------------------------	// External interface methods	//-------------------------------------------------		/**		* Reset the player display:		* Closes the stage curtain and clears any existing room.		*/		private function _resetDisplay():void {			uiCurtain.show(false);			gameDisplay.clearRoom();		}		/**		* Builds a Lassie XML script structure.		*/		private function _getScript($xml:String):XML {			return new XML('<'+CommandName.GENERIC+'>'+ $xml +'</'+CommandName.GENERIC+'>');		}		/**		* Builds a game configuration XML script out of all current model settings.		* Use this script to launch a game room with all current settings.		*/		private function _getConfigScript():XML		{			var $position:String = gameCache.savedRoomPosition;			var $config:String = '<'+ CommandName.GAME +' ';			$config += 'actor="'+ gameModel.currentActor +'" ';			$config += 'room="'+ gameModel.currentRoom;			if (!!$position && $position != "") $config += ":"+$position;			$config += '"/>';			return _getScript($config);		}		/**		* Attempts to call a global script within the game model.		*/		private function _runScript($scriptId:String, $xml:XML=null):void		{			// attempt to pull the requested script model.			if (gameModel.hasScript($scriptId)) {				$xml = gameModel.getScript($scriptId).script;			}			// process a copy of any valid XML.			if (!!$xml) processXML($xml.copy());		}	//-------------------------------------------------	// Event handlers	//-------------------------------------------------		/**		* Catches a script event propagating through the display.		*/		private function _onCatchScriptEvent($event:LassieEvent):void {			// if script is valid XML, hand the script off the the process handler.			if (!!$event.script) processXML($event.script, $event.branchProcess);		}	}}/*** @private* Local class required for Singleton instantiation.*/final internal class GameControllerEnforcer {}