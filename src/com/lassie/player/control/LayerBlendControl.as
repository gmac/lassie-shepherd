/*** Lassie Engine Game Player* @author Greg MacWilliam.*/package com.lassie.player.control{	import com.lassie.player.tween.TweenCore;	import com.lassie.player.tween.TweenPlayer;	import com.lassie.utils.XmlUtil;	import flash.display.DisplayObject;	import flash.geom.Rectangle;	import flash.geom.Point;	/**	* The LayerBlendControl performs basic tweens of a single layer's display properties.	* SYNC/ASYNC.	*/	final internal class LayerBlendControl extends ProcessCommand	{		static private var _allowedFields:Object = {			x:true,			y:true,			alpha:true,			scaleX:true,			scaleY:true,			rotation:true		}		// private		private var _tween:TweenPlayer;		private var _seconds:Number = 0;		private var _waitForComplete:Boolean = false;		/**		* <layerBlend target="panel" from="alpha:0" to="alpha:1" seconds="2" ease="strong:easeInOut" waitForComplete="1"/>		*/		public function LayerBlendControl():void {			super();		}		override public function destroy():void		{			if (!!_tween) {				_tween.destroy();				_tween = null;			}			super.destroy();		}		override internal function parse($xml:XML):void {			_sourceXML = $xml;			_waitForComplete = XmlUtil.parseBoolean(_sourceXML.@waitForComplete, true);			_seconds = _sourceXML.@seconds;			if (isNaN(_seconds)) _seconds = 2;		}		override public function toString():String {			return "[LayerBlendControl]";		}	//-------------------------------------------------	// Control methods	//-------------------------------------------------		override protected function _run():void		{			var $layer:DisplayObject = getRoomLayer(_sourceXML.@target) as DisplayObject;			var $to:Object;			// if a valid layer is being targeted.			if (!!$layer)			{				// test for a set of "at" params (starting values).				if (_sourceXML.@at != undefined) {					_applyParams($layer, _parseParams( _sourceXML.@at ) );				}				// test for a set of "to" params (ending values).				if (_sourceXML.@to != undefined) {					$to = _parseParams( _sourceXML.@to );				}				// configure transition to ending values.				if (!!$to)				{					// set easing					var $ease:Function = TweenCore.parseEase(_sourceXML.@ease);					if ($ease != null) $to.ease = $ease; // << explicitly use "!= null" syntax for functions!					if (_seconds > 0)					{						// Assign task responder:						// - When waitForComplete, this object recieves callback and handles cleanup.						// - Otherwise, tween player will handle cleaning up after itself.						if (_waitForComplete) $to.onComplete = this._onTweenComplete;						else $to.autoDestroy = true;						// create new tween to handle animation.						var $engine:TweenPlayer = TweenCore.getTween($layer, _seconds, $to);						// WAIT FOR COMPLETE:						// Store reference to tween player and exit.						if (_waitForComplete) {							_tween = $engine;							return;						}					}					else {						// immediately apply "to" parameters when no time is specified.						_applyParams($layer, $to);					}				}			}			_complete();		}		/**		* Stops the tween.		*/		override public function stop():void {			if (!!_tween) _tween.pause();		}		/**		* Resumes the tween's playback.		*/		override public function resume():void {			if (!!_tween) _tween.resume();		}		/**		* Applys all tween settings immediately without animating.		*/		override protected function _skipBeforeCall():void {			_waitForComplete = false;			_seconds = 0;			_run();		}		/**		* Skips over the tween after it has been formally called.		*/		override protected function _skipAfterCall():void {			if (!!_tween) _tween.skip();		}	//-------------------------------------------------	// Utility methods	//-------------------------------------------------		/**		* Parses a string of parameters into a formatted and validated object.		*/		private function _parseParams($raw:String):Object		{			var $params:Object = new Object();			var $list:Array = $raw.split(",");			for each (var $param:String in $list) {				var $values:Array = $param.split(":");				var $prop:String = $values[0];				var $val:Number = parseFloat( $values[1] );				if (_allowedFields.hasOwnProperty( $prop ) && !isNaN($val)) $params[ $prop ] = $val;			}			return $params;		}		/**		* Immediately applies parameters to an object display.		*/		private function _applyParams($layer:DisplayObject, $params:Object):void {			// immediately apply all "from" params.			for (var $prop:String in $params) {				try {					$layer[ $prop ] = $params[ $prop ];				} catch ($error:Error) {					// do nothing.				}			}		}		/**		* Resolves the tween after it has finished playing.		*/		private function _onTweenComplete():void {			_complete();		}	}}