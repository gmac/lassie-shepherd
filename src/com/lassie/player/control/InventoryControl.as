/*** Lassie Engine Game Player* @author Greg MacWilliam.*/package com.lassie.player.control{	import com.lassie.player.model.InventoryCollection;	import com.lassie.utils.XmlUtil;	/**	* The InventoryControl manages inventory contents, display, and behavior.	* INSTANT.	*/	final internal class InventoryControl extends ProcessCommand	{		/**		* <inventory target="_current" add="itemId" remove="itemId" removeEach="itemId" replace="itemId:replacementId" display="show/hide/toggle"/>		*/		public function InventoryControl():void		{			super();		}		override public function toString():String {			return "[InventoryControl]";		}		override protected function _run():void		{			var $inven:InventoryCollection;			// get reference to target inventory collection			// get inventory by id, or use the current inventory (if none other is specified)			if (_sourceXML.@target != undefined && _sourceXML.@target != KeyValues.CURRENT) {				$inven = gameModel.getInventory(_sourceXML.@target);			}			else {				$inven = gameModel.currentInventoryModel;			}			// if an inventory was successfully resolved			if (!!$inven)			{				// perform all inventory modifications				if (_sourceXML.@add != undefined)				{					var $contentLimit:Number = (_sourceXML.@contentLimit != undefined) ? parseInt(_sourceXML.@contentLimit) : -1;					var $historyLimit:Number = (_sourceXML.@historyLimit != undefined) ? parseInt(_sourceXML.@historyLimit) : -1;					if (isNaN($contentLimit)) $contentLimit = -1;					if (isNaN($historyLimit)) $historyLimit = -1;					$inven.addItems(_sourceXML.@add, -1, $contentLimit, $historyLimit);				}				// remove first instance of each of the specified items, or all items if value is asterisk.				if (_sourceXML.@remove != undefined) {					if (_sourceXML.@remove == KeyValues.ALL) $inven.removeAllItems();					else $inven.removeItems(_sourceXML.@remove);				}				// remove each instance of specified items				if (_sourceXML.@removeEach != undefined) $inven.removeEachOfItems(_sourceXML.@removeEach);				// replace an item with another item(s).				if (_sourceXML.@replace != undefined)				{					var $replace:Array = Targeting.parseTargetList(_sourceXML.@replace, ":", 3);					$inven.replaceItemWith($replace[0], $replace[1], XmlUtil.parseBoolean($replace[2], true) );				}			}			// set mouse over/out scripts to inventory display			if (_sourceXML.@mouseAction != undefined)			{				var $action:String = _sourceXML.@mouseAction.toString();				var $script:XML = new XML('<'+ CommandName.GENERIC +'/>');				$script.appendChild( _sourceXML.children().copy() );				// apply child script to inventory mouse responder.				switch ($action) {					case KeyValues.OVER: uiInventory.setMouseOver( $script ); break;					case KeyValues.OUT: uiInventory.setMouseOut( $script ); break;				}			}			// set the inventory panel's overlay behavior status.			if (_sourceXML.@dynamicDisplay != undefined) {				uiInventory.dynamicDisplay = XmlUtil.parseBoolean( _sourceXML.@dynamicDisplay, false );			}			// specifies a numeric index or item target to scroll the inventory to.			if (_sourceXML.@scrollTo != undefined) {				uiInventory.scrollTo(_sourceXML.@scrollTo);			}			// set inventory display's visibility.			if (_sourceXML.@display != undefined)			{				var $display:String = _sourceXML.@display.toString();				var $tween:Boolean = XmlUtil.parseBoolean( _sourceXML.@tween, true );				switch ($display) {					case KeyValues.SHOW: uiInventory.show($tween); break;					case KeyValues.HIDE: uiInventory.hide($tween); break;					case KeyValues.TOGGLE: uiInventory.toggle($tween); break;				}			}			// finally, signal completion.			_complete();		}		override public function stop():void {			// none.		}		override public function resume():void {			// none.		}		override public function skip():void {			_run();		}	}}