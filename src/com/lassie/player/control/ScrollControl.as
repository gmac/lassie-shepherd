/*** Lassie Engine Game Player* @author Greg MacWilliam.*/package com.lassie.player.control{	import com.lassie.player.tween.TweenCore;	import com.lassie.player.core.IRoomScroll;	import com.lassie.player.geom.GeomUtil;	import com.lassie.utils.XmlUtil;	import flash.geom.Point;		final internal class ScrollControl extends ProcessCommand	{		private var _tweenPercent:Number = 0;		private var _startX:Number = 0;		private var _startY:Number = 0;		private var _goalX:Number = 0;		private var _goalY:Number = 0;				/**		* <scroll to="0,0" by="0,50" seconds="1" easeType="strong" easeMethod="easeInOut" waitForComplete="1"/>		*/		public function ScrollControl():void {			super();		}	//-------------------------------------------------	// Process methods	//-------------------------------------------------			override public function toString():String {			return "[ScrollControl]";		}			//-------------------------------------------------	// Control methods	//-------------------------------------------------			override protected function _run():void		{			var $scroll:IRoomScroll = gameRoom.scroll;						if ($scroll.scrollEnabled)			{				// SCROLLING IS ENABLED				_startX = _goalX = $scroll.scrollX;				_startY = _goalY = $scroll.scrollY;				var $x:Number;				var $y:Number;								// get "to" coordinates				if (_sourceXML.@to != undefined) {					var $to:Array = (_sourceXML.@to + ",").split(",");					$x = parseInt($to[0]);					$y = parseInt($to[1]);					if (!isNaN($x)) _goalX = $x;					if (!isNaN($y)) _goalY = $y;				}								// get "by" modifiers				if (_sourceXML.@by != undefined) {					var $by:Array = (_sourceXML.@by + ",").split(",");					$x = parseInt($by[0]);					$y = parseInt($by[1]);					if (!isNaN($x)) _goalX += $x;					if (!isNaN($y)) _goalY += $y;				}				// validate start and goal coordinates.				_goalX = Math.max(0, Math.min(_goalX, $scroll.scrollRangeX));				_goalY = Math.max(0, Math.min(_goalY, $scroll.scrollRangeY));								if (Point.distance(new Point(_startX, _startY), new Point(_goalX, _goalY)) > 0)				{					// TWEEN HAS DISTANCE					// configure parameters					var $params:Object = {tweenPercent:1, onComplete:this._onTweenComplete};										// set easing					var $ease:Function = TweenCore.parseEase(_sourceXML.@ease);					if ($ease != null) $params.ease = $ease; // << explicitly use "!= null" syntax for functions!										// set duration					var $seconds:Number = _sourceXML.@seconds;					if (isNaN($seconds)) $seconds = 2;								if ($seconds > 0) {						// TWEEN HAS DURATION						// start tween.						TweenCore.tween(this, $seconds, $params);												// return from function before calling complete unless						// the XML specifically instructs NOT to waitForComplete.						if (XmlUtil.parseBoolean(_sourceXML.@waitForComplete, true)) return;					}					else {						// TWEEN HAS NO DURATION						// immediately set scroll to goal.						gameRoom.scroll.scrollAt(new Point(_goalX, _goalY));					}				}			}			_onTweenComplete();		}				/**		* Tweening property for TweenLite. Specifies the percentage of the tween completed.		*/		public function get tweenPercent():Number {			return _tweenPercent;		}		public function set tweenPercent($percent:Number):void {			_tweenPercent = $percent;			var $x:Number = GeomUtil.interpolate(_startX, _goalX, $percent);			var $y:Number = GeomUtil.interpolate(_startY, _goalY, $percent);			gameRoom.scroll.scrollAt(new Point($x, $y));		}				/**		* Called upon completion of the scroll tween.		*/		private function _onTweenComplete():void		{			if (_sourceXML != null) {				// only call complete while object has source XML intact.				// this will avoid having a second complete event called after a non-waiting tween completes.				_sourceXML = null;				_complete();			}		}				override public function stop():void {			// no stop.		}				override public function resume():void {			// no resume.		}				override public function skip():void {			// no skip.		}	}}