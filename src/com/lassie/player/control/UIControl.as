/*** Lassie Engine Game Player* @author Greg MacWilliam.*/package com.lassie.player.control{	import com.lassie.utils.XmlUtil;	import com.lassie.player.core.IUILayer;	import com.lassie.player.events.DisplayEvent;	import com.lassie.player.room.RoomDisplay;		final internal class UIControl extends ProcessCommand	{		/**		* <ui unload="roomId" load="roomId" target="layer"/>		*/		public function UIControl():void {			super();		}	//-------------------------------------------------	// Process methods	//-------------------------------------------------			override public function toString():String {			return "[UIControl]";		}			//-------------------------------------------------	// Control methods	//-------------------------------------------------			override protected function _run():void		{			var $layer:IUILayer;						// Unload an existing layout.			if (_sourceXML.@unload != undefined) {				uiLayouts.removeLayout( _sourceXML.@unload );				delete _sourceXML.@unload;			}						// Acquire a layer target.			if (_sourceXML.@load != undefined)			{				// LOAD REQUEST				// Load a new layout.				var $targets:Array = Targeting.parseTargetList( _sourceXML.@load, ":", 2 );				var $depth:Number = parseInt( $targets[1] );								$layer = uiLayouts.addLayout($targets[0], (isNaN($depth) ? $depth : 0));				var $room:RoomDisplay = $layer.display as RoomDisplay;								if (!$room.loaded)				{					// If the room has not yet loaded, listen for completion of loading.					// This command will be re-run upon completion of the room display loading.					$layer.display.addEventListener(DisplayEvent.ROOM_DISPLAY_READY, this._onLayoutReady);										// reconfigure XML to target the new layer upon the post-load rerun.					_sourceXML.@target = $targets[0];					delete _sourceXML.@load;					return;				}			}			else if (_sourceXML.@target != undefined)			{				// TARGET REQUEST				$layer = _getUILayer(_sourceXML.@target.toString());			}						if (!!$layer)			{				// Sets the enabled status of the layer.				if (_sourceXML.@enabled != undefined) {					var $enabled:Boolean = XmlUtil.parseBoolean(_sourceXML.@enabled, true);					$layer.enabled = $enabled;				}								// Set the number of seconds in the layer's reveal animation.				if (_sourceXML.@showSeconds != undefined) {					var $show:Number = _sourceXML.@showSeconds;					if (!isNaN($show)) $layer.showSeconds = $show;				}								// Set the number of seconds in the layer's hide animation.				if (_sourceXML.@hideSeconds != undefined) {					var $hide:Number = _sourceXML.@hideSeconds;					if (!isNaN($hide)) $layer.hideSeconds = $hide;				}								// Set the layer display,				if (_sourceXML.@display != undefined)				{					// SET THE LAYER DISPLAY					var $display:String = _sourceXML.@display.toString();					var $tween:Boolean = XmlUtil.parseBoolean(_sourceXML.@tween, true);										switch ($display) {						case KeyValues.SHOW: $layer.show($tween); break;						case KeyValues.HIDE: $layer.hide($tween); break;						case KeyValues.TOGGLE: $layer.toggle($tween); break;					}				}			}							_complete();		}				/**		* Gets a reference to a UI layer object.		*/		private function _getUILayer($id:String):IUILayer		{			switch ($id) {				case "_actions": return uiActionSelector;				case "_cursor": return uiCursor;				case "_inventory": return uiInventory;				case "_menu": return uiGameMenu;				case "_subtitle": return uiSubtitle;				case "_tree": return uiTreeMenu;				default: return uiLayouts.getLayout($id);			}		}				/**		* Called upon completion of a room layout UI layer loading.		*/		private function _onLayoutReady($event:DisplayEvent):void {			$event.target.removeEventListener(DisplayEvent.ROOM_DISPLAY_READY, this._onLayoutReady);			_run();		}	}}