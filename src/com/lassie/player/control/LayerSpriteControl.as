/*** Lassie Engine Game Player* @author Greg MacWilliam.*/package com.lassie.player.control{	import com.lassie.events.LassieEvent;	import com.lassie.player.core.IRoomLayerDisplay;	import com.lassie.player.model.Position;	import com.lassie.player.model.RoomLayer;	import com.lassie.utils.XmlUtil;	import flash.events.Event;	import flash.geom.Point;	/**	* The LayerSpriteControl manages settings display settings of layers on screen.	* The layerSprite command works exclusively with the Flash display and NOT Shepherd data.	* Changes made to a layer using the layerSprite command are NOT registered within the layer's model.	* Basically, use this command to temporarily make change to screen display without caching lasting configuration.	* SYNC/ASYNC.	*/	final internal class LayerSpriteControl extends ProcessCommand	{		private var _layer:IRoomLayerDisplay;		private var _breakListener:Boolean = false;		private var _completeListener:Boolean = false;		/**		* <layerSprite target="layerId" animFrame="frameLabel" turnView="1" shiftFrame="-1/1" waitForComplete="1/0"/>		*/		public function LayerSpriteControl():void {			super();		}		override public function toString():String {			return "[LayerSpriteControl]";		}		override public function destroy():void {			_enableBreakListener(false);			_enableCompleteListener(false);			_layer = null;		}	//-------------------------------------------------	// Control methods	//-------------------------------------------------		override protected function _run():void		{			_layer = getRoomLayer(_sourceXML.@target);			// if a valid layer is being targeted			if (!!_layer)			{				// holds off the command's processing until target layer's animation reaches a break point.				if (_sourceXML.@waitForBreak != undefined) {					var $break:Boolean = XmlUtil.parseBoolean(_sourceXML.@waitForBreak, false);					if ($break) {						delete _sourceXML.@waitForBreak;						_enableBreakListener(true);						return;					}				}				// set the layer's manual float-behind override.				if (_sourceXML.@floatBehind != undefined) {					_layer.floatBehind = _sourceXML.@floatBehind;				}				// sets turn-view inversion on the layer (front/back views are swapped)				if (_sourceXML.@invertTurn != undefined) {					_layer.invertTurn = XmlUtil.parseBoolean(_sourceXML.@invertTurn, false);				}				// sets new layer coordinates				if (_sourceXML.@to != undefined) {					_layer.position = _setLayerPosition(_sourceXML.@to);				}				// shift target layer's display clip by X frames whenever set.				if (_sourceXML.@frameOffset != undefined)				{					var $offset:Number = parseInt(_sourceXML.@frameOffset);					if (!isNaN($offset)) _layer.frameOffset = $offset;				}				// Set layer visibility.				if (_sourceXML.@visible != undefined) {					_layer.visible = XmlUtil.parseBoolean(_sourceXML.@visible, true);				}				// Register the layer's current display state to its model.				if (_sourceXML.@register != undefined && XmlUtil.parseBoolean(_sourceXML.@register, false)) {					_layer.cacheDisplay();				}				// Call a method of the layer's image display.				if (_sourceXML.@imageMethod != undefined && !!_layer.image)				{					try {						var $method:Array = Targeting.parseTargetList( _sourceXML.@imageMethod, ":", 2 );						_layer.image[ $method[0] ].apply(_layer.image, $method[1].split(","));					}					catch($error:Error) {						// do nothing.					}				}				// set new animation frame display.				if (_sourceXML.@animFrame != undefined)				{					var $turnView:Number = parseInt(_sourceXML.@turnView);					$turnView = (!isNaN($turnView)) ? $turnView : -1;					_layer.setImageFrame(_sourceXML.@animFrame, $turnView);					// if waiting for a complete event					if (XmlUtil.parseBoolean(_sourceXML.@waitForComplete, false)) {						// enable completion listener						_enableCompleteListener(true);						return;					}				}			}			_complete();		}		override public function skip():void		{			_enableBreakListener(false);			_enableCompleteListener(false);			_setEndFrame();			_complete();		}	//-------------------------------------------------	// Utility methods	//-------------------------------------------------		/**		* Sets an optional final frame state at the end of an animation.		*/		private function _setEndFrame():void		{			if (_sourceXML.@endFrame != undefined) {				if (!_layer) _layer = getRoomLayer(_sourceXML.@target);				if (!!_layer) _layer.setImageFrame(_sourceXML.@endFrame, -1);			}		}		/**		* Gets a layer's target position.		*/		private function _setLayerPosition($target:String):Point		{			var $to:Array = $target.split(":");			if ($to.length >= 2)			{				switch($to[0]) {					case KeyValues.POINT: return _moveToPoint($to[1]);					case KeyValues.POSITION: return _moveToPosition($to[1]);					case KeyValues.LAYER: return _moveToLayer($to[1]);				}			}			return _layer.position;		}			private function _moveToPoint($target:String):Point			{				var $coords:Array = ($target + ",").split(",");				var $default:Point = _layer.position;				var $x:Number = parseInt($coords[0]);				var $y:Number = parseInt($coords[1]);				if (isNaN($x)) $x = $default.x;				if (isNaN($y)) $y = $default.y;				return new Point($x, $y);			}			private function _moveToPosition($target:String):Point			{				var $pos:Position;				// get target position if a room is loaded and it contains the target position.				if (!!gameModel.currentRoomModel && gameModel.currentRoomModel.hasPosition($target)) {					$pos = gameModel.currentRoomModel.getPosition($target);				}				return (!!$pos) ? $pos.point : _layer.position;			}			private function _moveToLayer($target:String):Point			{				var $layer:RoomLayer = Targeting.getRoom( KeyValues.CURRENT ).getLayer( $target );				var $point:Point = (!!$layer) ? $layer.mapPoint : _layer.position;				return (!!$point) ? $point : _layer.position;			}		/**		* @private enables / disables the layer animation BREAK listener.		*/		private function _enableBreakListener($enable:Boolean):void		{			if (!!_layer) {				if ($enable && !_breakListener) {					_layer.addEventListener(LassieEvent.ANIMATION_BREAK, this._onAnimBreak, false, 0, true);				}				else if (!$enable && _breakListener) {					_layer.removeEventListener(LassieEvent.ANIMATION_BREAK, this._onAnimBreak);				}			}			_breakListener = $enable;		}		/**		* @private enables / disables the layer animation COMPLETE listener.		*/		private function _enableCompleteListener($enable:Boolean):void		{			if (!!_layer) {				if ($enable && !_completeListener) {					_layer.addEventListener(LassieEvent.ANIMATION_COMPLETE, this._onAnimComplete, false, 0, true);				}				else if (!$enable && _completeListener) {					_layer.removeEventListener(LassieEvent.ANIMATION_COMPLETE, this._onAnimComplete);				}			}			_completeListener = $enable;		}	//-------------------------------------------------	// Event handlers	//-------------------------------------------------		/** @private  layer animation has reached a break point. */		private function _onAnimBreak($event:Event):void {			_enableBreakListener(false);			_run();		}		/** @private  layer animation is complete. */		private function _onAnimComplete($event:Event):void {			_enableCompleteListener(false);			_setEndFrame();			_complete();		}	}}