/*** Lassie Engine Game Player* @author Greg MacWilliam.*/package com.lassie.player.model{	import com.lassie.player.geom.*;	import com.lassie.player.events.ModelEvent;	import com.lassie.utils.XmlUtil;	import flash.events.Event;		final public class Room extends DataModel	{		// private		private var _data:RoomData;		private var _layers:RoomModelSet;		private var _trees:RoomModelSet;		private var _scripts:DataModelSet;		private var _positions:DataModelSet;				private var _bgLayer:RoomLayer;		private var _avatarLayer:RoomLayer;		private var _gridData:Grid;		private var _grids:Object;		private var _filters:Object;		private var _isLoaded:Boolean;				public function Room($id:String):void		{			super($id);						_data = new RoomData();			_layers = new RoomModelSet( RoomLayer, this);			_trees = new RoomModelSet( DialogueTree, this );			_scripts = new DataModelSet( Script );			_positions = new DataModelSet( Position );			_grids = new Object();			_filters = new Object();			_isLoaded = false;			cacheEnabled = true;		}			//-------------------------------------------------	// Overrides	//-------------------------------------------------			override public function destroy():void		{			// purge grids			for (var j:String in _grids) {				Grid(_grids[j]).destroy();				delete _grids[j];			}			// purge filters			for (j in _filters) {				Filter(_filters[j]).destroy();				delete _filters[j];			}			// nullify object references			_data = null;			_grids = null;			_filters = null;			_bgLayer = null;			_avatarLayer = null;						// destroy current grid data			if (_gridData != null) {				_gridData.destroy();				_gridData = null;			}						// purge trees and cache			_layers.destroy();			_trees.destroy();			_scripts.destroy();			_positions.destroy();			_layers = null;			_trees = null;			_scripts = null;			_positions = null;						// disable cache mechanism.			cacheEnabled = false;		}				override public function refresh():void {			_cache = gameCache.getSession().getNamespace("rooms."+id);			update();		}				override internal function parse($xml:XML):void		{			XmlUtil.parseAttributes(_data, $xml.@*);						// dialogue trees			_layers.parse($xml.layers.layer);			_layers.sortModelsBy("depth");			_positions.parse($xml.positions.position);			_trees.parse($xml.trees.tree);			_scripts.parse($xml.scripts.script);						// grids			for each (var $gridXml:XML in $xml.grids.grid) {				_addGrid( Grid.parseXML($gridXml) );			}						// filters			for each (var $filterXml:XML in $xml.filters.filter) {				_addFilter( Filter.parseXML($filterXml) );			}						// create references to background and avatar			_bgLayer = _layers.getModel("_bg") as RoomLayer;			_avatarLayer = _layers.getModel("_avatar") as RoomLayer;			_loaded = true;						// forcibly reset grid reference to compile data.			grid = grid;		}				override public function toString():String {			return "[Room] id: "+ id;		}			//-------------------------------------------------	// Model methods	//-------------------------------------------------			/**		* Specifies if external XML has been loaded and parsed into the room model.		*/		public function get isLoaded():Boolean {			return _isLoaded;		}				/**		* Loads external XML into the data model.		*/		public function load():void		{			if (!_isLoaded) {				var loader:XMLLoader = new XMLLoader();				loader.addEventListener(Event.COMPLETE, this._onRoomXMLLoad);				loader.load(id, !gameSystem.localHost);			}			else {				dispatchEvent(new ModelEvent(ModelEvent.MODEL_READY));			}		}				/**		* Calls the room's prerender script.		*/		public function prerender():void		{			var $scriptId:String = prerenderScript;						if (hasScript( $scriptId )) {				// call prerender script, if defined within the script library.				var $script:Script = getScript( $scriptId );				if (!!$script) gameController.processXML($script.script, true);			}		}				//-------------------------------------------------	// Grid methods	//-------------------------------------------------			/**		* Adds a pre-built Grid object to the rooms's structure.		*/		private function _addGrid($grid:Grid):void {			_grids[$grid.id] = $grid;		}		/**		* Gets a room grid by an id name.		*/		private function _getGrid($id:String):Grid {			return _grids.hasOwnProperty($id) ? _grids[$id] as Grid : null;		}		/**		* Compiles the current grid data out of [possibly] multiple references.		*/		private function _setGridData($csv:String):void		{			var $list:Array = $csv.split(",");			_gridData = null;						while ($list.length > 0)			{				// loop through all grid references				var $grid:Grid = _getGrid($list.shift());								if (!!$grid) {					// if grid is valid, then join it with the base grid.					if (_gridData == null) _gridData = $grid.copy();					else _gridData = _gridData.join($grid);				}			}		}				/**		* Gets the active grid structure.		*/		public function get gridData():Grid {			return _gridData;		}				//-------------------------------------------------	// Filter methods	//-------------------------------------------------				/**		* @private		* Adds a pre-built Filter object to the rooms's structure.		*/		private function _addFilter($filter:Filter):void {			_filters[$filter.id] = $filter;		}				/**		* Gets a room filter by an id name.		*/		public function getFilter($id:String):Filter {			return hasFilter($id) ? _filters[$id] as Filter : null;		}				/**		* Tests if room contains a filter with the specified id.		*/		public function hasFilter($id:String):Boolean {			return _filters.hasOwnProperty($id);		}			//-------------------------------------------------	// Layer methods	//-------------------------------------------------			/**		* Gets a room layer by an Id name or creates it if it does not exist.		*/		public function getLayer($id:String):RoomLayer {			return _layers.getModel($id) as RoomLayer;		}				/**		* Gets a room layer by numeric depth index.		*/		public function getLayerAt($index:int):RoomLayer {			return _layers.getModelAt($index) as RoomLayer;		}				/**		* Tests if room contains a layer with the specified id.		*/		public function hasLayer($id:String):Boolean {			return _layers.contains($id);		}				/**		* Gets the number of layers in this room layout.		*/		public function get numLayers():int {			return _layers.numModels;		}				/**		* Reference to the room's background layer.		*/		public function get backgroundLayer():RoomLayer {			return _bgLayer;		}				/**		* Reference to the room's avatar layer (or null).		*/		public function get avatarLayer():RoomLayer {			return _avatarLayer;		}				/**		* Tests if the layout has an avatar layer.		*/		public function get hasAvatar():Boolean {			return _avatarLayer != null;		}			//-------------------------------------------------	// Model methods	//-------------------------------------------------				// tree		public function getTree($id:String):DialogueTree {			return _trees.getModel($id) as DialogueTree;		}				public function hasTree($id:String):Boolean {			return _trees.contains($id);		}				// script		public function getScript($id:String):Script {			return _scripts.getModel($id, false) as Script;		}				public function hasScript($id:String):Boolean {			return _scripts.contains($id);		}				// position		public function getPosition($id:String):Position {			return _positions.getModel($id, false) as Position;		}				public function hasPosition($id:String):Boolean {			return _positions.contains($id);		}			//-------------------------------------------------	// Read / write cache properties	//-------------------------------------------------			// coreLibs		public function get coreLibs():String {			return _cache.pull("coreLibs", _data.coreLibs) as String;		}		public function set coreLibs($val:String):void {			if (_cache.push("coreLibs", $val, _data.coreLibs, !_loaded)) update();		}				// voiceLibs		public function get voiceLibs():String {			return _cache.pull("voiceLibs", _data.voiceLibs) as String;		}		public function set voiceLibs($val:String):void {			if(_cache.push("voiceLibs", $val, _data.voiceLibs, !_loaded)) update();		}				// grid		public function get grid():String {			return _cache.pull("grid", _data.grid) as String;		}		public function set grid($csv:String):void {			_setGridData($csv);			if (_cache.push("grid", $csv, _data.grid, !_loaded)) update();		}				// prerenderScript		public function get prerenderScript():String {			return _cache.pull("prerender", _data.prerenderScript) as String;		}		public function set prerenderScript($scriptId:String):void {			if (_cache.push("prerender", $scriptId, _data.prerenderScript, !_loaded)) update();		}				// enterScript		public function get enterScript():String {			return _cache.pull("enter", _data.enterScript) as String;		}		public function set enterScript($scriptId:String):void {			if (_cache.push("enter", $scriptId, _data.enterScript, !_loaded)) update();		}				// exitScript		public function get exitScript():String {			return _cache.pull("exit", _data.exitScript) as String;		}		public function set exitScript($scriptId:String):void {			if (_cache.push("exit", $scriptId, _data.exitScript, !_loaded)) update();		}				// cleanupScript		public function get cleanupScript():String {			return _cache.pull("cleanup", _data.cleanupScript) as String;		}		public function set cleanupScript($scriptId:String):void {			if (_cache.push("cleanup", $scriptId, _data.cleanupScript, !_loaded)) update();		}				// channel-1 soundtrack		public function get soundtrack1():String {			return _cache.pull("sound1", _data.sound1) as String;		}		public function set soundtrack1($sound:String):void {			if (_cache.push("sound1", $sound, _data.sound1, !_loaded)) update();		}				// channel-2 soundtrack		public function get soundtrack2():String {			return _cache.pull("sound2", _data.sound2) as String;		}		public function set soundtrack2($sound:String):void {			if (_cache.push("sound2", $sound, _data.sound2, !_loaded)) update();		}			//-------------------------------------------------	// Event handlers	//-------------------------------------------------				private function _onRoomXMLLoad($event:Event):void		{			// reference and cleanup loader object			var loader:XMLLoader = $event.target as XMLLoader;			loader.removeEventListener(Event.COMPLETE, this._onRoomXMLLoad);						// parse loaded XML and notify of completion			parse(loader.data);			loader.destroy();			_isLoaded = true;			dispatchEvent(new ModelEvent(ModelEvent.MODEL_READY));		}	}}import com.lassie.player.model.DataModel;import com.lassie.player.model.DataModelSet;import com.lassie.player.model.Room;final internal class RoomData extends Object{	public var grid:String="";	public var coreLibs:String="";	public var voiceLibs:String="";	public var prerenderScript:String="_prerender";	public var enterScript:String="_enter";	public var exitScript:String="_exit";	public var cleanupScript:String="_cleanup";	public var sound1:String="";	public var sound2:String="";		public function RoomData():void	{		super();	}}/*** Native extention of DataModelSet.* This container embeds a room reference into each model within the set.*/final internal class RoomModelSet extends DataModelSet{	private var _parentRoom:Room;		public function RoomModelSet($class:Class, $room:Room):void	{		super($class);		_parentRoom = $room;	}		override public function destroy():void	{		super.destroy();		_parentRoom = null;	}		override protected function _createNewModel($id:String):DataModel	{		return new _modelClass($id, _parentRoom);	}}