/*** Lassie Engine Game Player* @author Greg MacWilliam.*/package com.lassie.player.model{	import com.lassie.player.core.IGameModel;	import com.lassie.player.events.ModelEvent;	import com.lassie.player.system.SystemParams;	import com.lassie.utils.KeyUtil;	import com.lassie.utils.XmlUtil;	import flash.events.EventDispatcher;	import flash.events.Event;		/**	* Master data model for storing and accessing all global settings and record structures.	*/	final public class GameModel extends DataModel implements IGameModel	{		// private		private var _data:GameModelData;		private var _actors:DataModelSet;		private var _combos:ComboModelSet;		private var _collections:DataModelSet;		private var _items:DataModelSet;		private var _responses:DataModelSet;		private var _rooms:DataModelSet;		private var _scripts:DataModelSet;		private var _keyboard:DataModelSet;		private var _methodology:Methodology;		private var _licenseKey:Boolean = false;		private var _globalXML:XML;				/**		* @private		* Constructs a new GameModel. Requires a singleton enforcer key for instantiation.		*/		public function GameModel($enforcer:ModelEnforcer):void		{			super(GameModelData.GLOBAL_MODEL);			_data = new GameModelData();			_actors = new DataModelSet( Actor );			_combos = new ComboModelSet( InventoryCombo );			_collections = new DataModelSet( InventoryCollection );			_items = new DataModelSet( InventoryItem );			_responses = new DataModelSet( ActionList );			_rooms = new DataModelSet( Room );			_scripts = new DataModelSet( Script );			_keyboard = new DataModelSet( KeyStroke );		}				/** @private Singleton instance reference */		private static var _instance:GameModel;				/**		* @private		* Singleton retrieval method.		*/		public static function getInstance():GameModel {			if (_instance == null) _instance = new GameModel(new ModelEnforcer());			return _instance;		}			//-------------------------------------------------	// Overrides	//-------------------------------------------------				override public function destroy():void		{			_data = null;			_actors.destroy();			_collections.destroy();			_combos.destroy();			_items.destroy();			_responses.destroy();			_rooms.destroy();			_scripts.destroy();			cacheEnabled = false;		}				override public function refresh():void		{			_cache = gameCache.getSession().getNamespace(GameModelData.GLOBAL_MODEL);			update();		}				/**		* Parse loaded XML data into the model.		* This is a two step process: first the cache is loaded, then the model is parsed.		*/		override internal function parse($xml:XML):void		{			_globalXML = $xml;			XML.prettyPrinting = !XmlUtil.parseBoolean($xml.@compact, false);						// check XML data registration.			_licenseKey = KeyUtil.validate($xml);						// load application cache using game's Id.			gameCache.addEventListener(ModelEvent.CACHE_READY, this._onCacheReady);			gameCache.load($xml.@id);		}					/** @private called upon completion of the game cache loading */			private function _onCacheReady($event:Event):void			{				gameCache.removeEventListener(ModelEvent.CACHE_READY, this._onCacheReady);				cacheEnabled = true;								// restore reference to source XML.				var $xml:XML = _globalXML;								// parse game data fields				XmlUtil.parseAttributes(_data, $xml.@*);				XmlUtil.parseAttributes(_data, $xml.config.@*);				// force-set current/preset language to configure model				currentLanguage = gameCache.languagePref || SystemParams.languageKey || currentLanguage;				_data.title = $xml.title.toString();				_data.author = $xml.author.toString();				_data.verbDialect = XML($xml.verbDialect);				_data.itemDialect = XML($xml.itemDialect);								// parse all data models				_actors.parse($xml.actors.actor);				_combos.parse($xml.combos.combo);				_items.parse($xml.items.item);				_collections.parse($xml.inventories.inventory);				_responses.parse($xml.responses.response);				_scripts.parse($xml.scripts.script);				_methodology = new Methodology();								// notify of load complete				dispatchEvent(new ModelEvent(ModelEvent.MODEL_READY));			}				override public function toString():String {			return "[MasterModel] id:"+ id;		}			//-------------------------------------------------	// Model methods	//-------------------------------------------------				/**		* Loads the external "global.xml" game data structure, and parses it into the strictly-typed model.		*/		public function load():void		{			var loader:XMLLoader = new XMLLoader();			loader.addEventListener(Event.COMPLETE, this._onGlobalXMLLoad);			loader.load(GameModelData.GLOBAL_MODEL, !gameSystem.localHost);		}	//-------------------------------------------------	// Read-only properties	//-------------------------------------------------			/**		* Specifies the game display's viewable width.		*/		public function get stageWidth():int {			return _data.stageWidth;		}				/**		* Specifies the game display's viewable height.		*/		public function get stageHeight():int {			return _data.stageHeight;		}				/**		* Specifies the language structure for Verb-Noun context summaries.		*/		public function get verbDialect():String {			return _selectLanguage(_data.verbDialect);		}				/**		* Specifies the language structure for Item-Noun context summaries.		*/		public function get itemDialect():String {			return _selectLanguage(_data.itemDialect);		}				/**		* Specifies the core graphics libraries to load into the player for global use.		*/		public function get coreLibs():String {			return _data.coreLibs;		}				/**		* Specifies [optional] libraries of voice assets to load into the player for global use.		*/		public function get voiceLibs():String {			return _data.voiceLibs;		}				/**		* Specifies the title of the game.		*/		public function get gameTitle():String {			return _data.title;		}				/**		* Specifies the game's author.		*/		public function get authorName():String {			return _data.author;		}				/**		* Specifies if the loaded data includes a valid software license key.		*/		public function get hasLicenseKey():Boolean {			return _licenseKey;		}				/**		* Provides a reference to the model's methodology table.		*/		public function get methodology():Methodology {			return _methodology;		}				/**		* Defines an array of language option keys.		*/		public function get languageOptions():Array {			return _data.languageOptions.split(',');		}			//-------------------------------------------------	// Current game-state properties	//-------------------------------------------------			/**		* Specifies the currently active language key.		*/		public function get currentLanguage():String {			return DataModel.languageKey;			//return _cache.pull(GameModelData.LANGUAGE, _data.language);		}		public function set currentLanguage($langKey:String):void {			DataModel.languageKey = $langKey;			gameCache.languagePref = $langKey;			//_cache.push(GameModelData.LANGUAGE, $langKey, _data.language);			dispatchEvent(new ModelEvent(ModelEvent.CHANGE_LANGUAGE));		}				/**		* Specifies the currently active actor identifier.		*/		public function get currentActor():String {			return _cache.pull(GameModelData.ACTOR, _data.actor);		}		public function set currentActor($id:String):void		{			if (hasActor($id))			{				// clear update listener from current actor model				if ( hasActor(currentActor) ) {					currentActorModel.removeEventListener(ModelEvent.UPDATE_DISPLAY, this._onSetActorConfig);				}								// update game actor profile				_cache.push(GameModelData.ACTOR, $id, _data.actor);				dispatchEvent(new ModelEvent(ModelEvent.CHANGE_ACTOR));								// configure game to listen for updates within the actor's configuration.				var $actor:Actor = getActor($id);				$actor.addEventListener(ModelEvent.UPDATE_DISPLAY, this._onSetActorConfig);				_onSetActorConfig();			}		}			/**			* Updates game inventory and response set based on the current actor profile.			*/			private function _onSetActorConfig($event:Event=null):void			{				var $actor:Actor = currentActorModel;				currentInventory = $actor.inventory;				currentResponse = $actor.response;			}				/**		* Specifies the currently active inventory identifier.		*/		public function get currentInventory():String {			return _cache.pull(GameModelData.INVENTORY, _data.inventory);		}		public function set currentInventory($id:String):void		{			if (hasInventory($id)) {				_cache.push(GameModelData.INVENTORY, $id, _data.inventory);				dispatchEvent(new ModelEvent(ModelEvent.CHANGE_INVENTORY));			}		}				/**		* Specifies the currently active response identifier.		*/		public function get currentResponse():String {			return _cache.pull(GameModelData.RESPONSE, _data.response);		}		public function set currentResponse($id:String):void		{			if (hasResponse($id)) {				_cache.push(GameModelData.RESPONSE, $id, _data.response);				dispatchEvent(new ModelEvent(ModelEvent.CHANGE_RESPONSE));			}		}				/**		* Specifies the currently active room identifier.		*/		public function get currentRoom():String {			return _cache.pull(GameModelData.ROOM, _data.room);		}		public function set currentRoom($id:String):void {			_cache.push(GameModelData.ROOM, $id, _data.room);			dispatchEvent(new ModelEvent(ModelEvent.CHANGE_ROOM));		}				/**		* Specifies the current volume of all sound effects, expressed as a number between 0 and 1.		*/		public function get soundfxVolume():Number {			return _cache.pull(GameModelData.SOUND_FX, _data.soundfxVolume);		}		public function set soundfxVolume($vol:Number):void {			_cache.push(GameModelData.SOUND_FX, $vol, _data.soundfxVolume);			dispatchEvent(new ModelEvent(ModelEvent.CHANGE_VOLUME));		}				/**		* Specifies the current volume of all background music, expressed as a number between 0 and 1.		*/		public function get soundtrackVolume():Number {			return _cache.pull(GameModelData.SOUNDTRACK, _data.soundtrackVolume);		}		public function set soundtrackVolume($vol:Number):void {			_cache.push(GameModelData.SOUNDTRACK, $vol, _data.soundtrackVolume);			dispatchEvent(new ModelEvent(ModelEvent.CHANGE_VOLUME));		}				/**		* Specifies the current volume of all voice sounds, expressed as a number between 0 and 1.		*/		public function get voiceVolume():Number {			return _cache.pull(GameModelData.VOICE, _data.voiceVolume);		}		public function set voiceVolume($vol:Number):void {			_cache.push(GameModelData.VOICE, $vol, _data.voiceVolume);			dispatchEvent(new ModelEvent(ModelEvent.CHANGE_VOLUME));		}				/**		* Specifies if voice/talkie loading and playback is enabled by the user.		* Voice libraries are not loaded if voices are disabled.		*/		public function get voiceEnabled():Boolean {			return _cache.pull(GameModelData.TALKIE, _data.voices);		}		public function set voiceEnabled($enable:Boolean):void {			_cache.push(GameModelData.TALKIE, $enable, _data.voices);		}				/**		* Specifies if voice/talkie is enabled for system as a whole within config data.		*/		public function get systemVoiceEnabled():Boolean {			return _data.voices;		}				/**		* Specifies if dialogue subtitles are enabled.		*/		public function get subtitleEnabled():Boolean {			return _cache.pull(GameModelData.SUBTITLE, _data.subtitles);		}		public function set subtitleEnabled($enable:Boolean):void {			_cache.push(GameModelData.SUBTITLE, $enable, _data.subtitles);		}				/**		* Specifies the speed percentage applied to subtitle durations.		*/		public function get subtitleSpeed():Number {			return _cache.pull(GameModelData.SUBTITLE_SPEED, _data.subtitleSpeed);		}		public function set subtitleSpeed($val:Number):void {			_cache.push(GameModelData.SUBTITLE_SPEED, $val, _data.subtitleSpeed);		}			//-------------------------------------------------	// Actor data models	//-------------------------------------------------				/**		* Gets an Actor data model.		*/		public function getActor($id:String):Actor {			return _actors.getModel($id) as Actor;		}				/**		* Tests if an Actor data model with the specified identifier exists.		*/		public function hasActor($id:String):Boolean {			return _actors.contains($id);		}				/**		* Gets the data model of the currently active Actor record.		*/		public function get currentActorModel():Actor {			return getActor( currentActor );		}			//-------------------------------------------------	// Inventory data models	//-------------------------------------------------			/**		* Gets an InventoryCollection data model.		*/		public function getInventory($id:String):InventoryCollection {			return _collections.getModel($id) as InventoryCollection;		}				/**		* Tests if an InventoryCollection data model with the specified identifier exists.		*/		public function hasInventory($id:String):Boolean {			return _collections.contains($id);		}				/**		* Gets the data model of the currently active InventoryCollection record.		*/		public function get currentInventoryModel():InventoryCollection {			return getInventory( currentInventory );		}			//-------------------------------------------------	// Inventory item data models	//-------------------------------------------------			/**		* Gets an InventoryItem data model.		*/		public function getItem($id:String):InventoryItem {			return _items.getModel($id) as InventoryItem;		}				/**		* Tests if an InventoryItem data model with the specified identifier exists.		*/		public function hasItem($id:String):Boolean {			return _items.contains($id);		}			//-------------------------------------------------	// Inventory combination data models	//-------------------------------------------------			public function getItemCombo($item1:String, $item2:String):InventoryCombo {			return _combos.getComboOf($item1, $item2);		}		public function getCombo($id:String):InventoryCombo {			return _combos.getModel($id) as InventoryCombo;		}		public function hasCombo($id:String):Boolean {			return _combos.contains($id);		}			//-------------------------------------------------	// Response set data models	//-------------------------------------------------				public function getResponse($id:String):ActionList {			return _responses.getModel($id) as ActionList;		}		public function hasResponse($id:String):Boolean {			return _responses.contains($id);		}		public function get currentResponseModel():ActionList {			return getResponse( currentResponse );		}			//-------------------------------------------------	// Room data models	//-------------------------------------------------		public function getRoom($id:String):Room {			return _rooms.getModel($id) as Room;		}		public function hasRoom($id:String):Boolean {			return _rooms.contains($id);		}		public function get currentRoomModel():Room {			return getRoom( currentRoom );		}		public function unloadRoom($id:String):Boolean		{			if ($id != currentRoom) {				var $room:Room = _rooms.removeModel($id) as Room;								if (!!$room) {					$room.destroy();					return true;				}			}			return false;		}			//-------------------------------------------------	// Script data models	//-------------------------------------------------		public function getScript($id:String):Script {			return _scripts.getModel($id) as Script;		}		public function hasScript($id:String):Boolean {			return _scripts.contains($id);		}			//-------------------------------------------------	// KeyStroke data models	//-------------------------------------------------		public function getKey($key:String):KeyStroke {			return _keyboard.getModel($key) as KeyStroke;		}		public function hasKey($key:String):Boolean {			return _keyboard.contains($key);		}		public function keyList($key:String):Array {			return _keyboard.contents;		}			//-------------------------------------------------	// Event handlers	//-------------------------------------------------				private function _onGlobalXMLLoad($event:Event):void		{			// reference and cleanup loader object			var $loader:XMLLoader = $event.target as XMLLoader;			$loader.removeEventListener(Event.COMPLETE, this._onGlobalXMLLoad);			parse($loader.data);			$loader.destroy();		}	}}/*** @private* Singleton enforcer class.*/final internal class ModelEnforcer {}