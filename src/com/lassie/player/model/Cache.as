/*** Lassie Engine Game Player* @author Greg MacWilliam.*/package com.lassie.player.model{	public class Cache	{		public static const NAMESPACE_DELIMITER:String = ".";		public static const SCOPE_PREFIX:String = "_";		// public		public var data:Object;		public function Cache($data:Object):void {			data = $data;		}		/**		* Destroys the cache object.		*/		public function destroy():void {			data = null;		}		/**		* Specifies if the cache holds any property assignments.		*/		public function get isEmpty():Boolean {			for (var $j in data) return false;			return true;		}		/**		* Tests if a namespace object exists at the specified URI path.		*/		public function hasNamespace($uri:String):Boolean		{			var $path:Array = $uri.split(NAMESPACE_DELIMITER);			var $scope:Object = data;			for each (var $j:String in $path)			{				if ($scope[SCOPE_PREFIX+$j] != undefined) {					$scope = $scope[SCOPE_PREFIX+$j];				}				else {					return false;				}			}			return true;		}		/**		* Gets an existing namespace or creates it if undefined.		*/		public function getNamespace($uri:String):Cache		{			var $path:Array = $uri.split(NAMESPACE_DELIMITER);			var $scope:Object = data;			for each (var $j:String in $path)			{				if ($scope[SCOPE_PREFIX+$j] == undefined) $scope[SCOPE_PREFIX+$j] = new Object();				$scope = $scope[SCOPE_PREFIX+$j];			}			return new Cache($scope);		}		/**		* Clears the scope of the final object in the URI path.		*/		public function clearNamespace($uri:String):void		{			var $path:Array = $uri.split(NAMESPACE_DELIMITER);			var $clear:String = $path.pop();			var $scope:Object = data;			for each (var $j:String in $path)			{				if ($scope[SCOPE_PREFIX+$j] != undefined) {					$scope = $scope[SCOPE_PREFIX+$j];				}				else {					return;				}			}			if ($scope[$clear] != undefined) {				$scope[$clear] = new Object();			}		}		/**		* Deletes the final object in the URI path.		*/		public function deleteNamespace($uri:String):void		{			var $path:Array = $uri.split(NAMESPACE_DELIMITER);			var $delete:String = $path.pop();			var $scope:Object = data;			for each (var $j:String in $path)			{				if ($scope[SCOPE_PREFIX+$j] != undefined) {					$scope = $scope[SCOPE_PREFIX+$j];				}				else {					return;				}			}			if ($scope.hasOwnProperty(SCOPE_PREFIX+$delete)) {				delete $scope[SCOPE_PREFIX+$delete];			}		}		/**		* Tests if the current namespace scope has a non-scope attribute.		*/		public function hasValue($key:String):Boolean {			return data.hasOwnProperty($key);		}		/**		* Gets a variable within the current namespace scope.		*/		public function getValue($key:String):* {			if (hasValue($key)) return data[$key];			else return null;		}		/**		* Sets a variable within the current namespace scope, overwriting any existing value.		*/		public function setValue($key:String, $val:*):void {			data[$key] = $val;		}		/**		* Clears a value.		*/		public function clearValue($key:String):void {			if (hasValue($key)) delete data[$key];		}		/**		* Pulls a field from the variables cache.		*/		public function pull($key:String, $defaultValue:*):*		{			if (hasValue($key)) return data[$key];			return $defaultValue;		}		/**		* Pushes a field into the variables cache.		*/		public function push($key:String, $newValue:*, $sourceValue:*=null, $forceWrite:Boolean=false):Boolean		{			var $changed:Boolean = false;			// if the new value is different than the source value,			// or if there was no source value provided			if ($newValue != $sourceValue || $sourceValue == null || $forceWrite)			{				// if any existing cached value does not match new value				if (getValue($key) != $newValue)				{					// set new value and flag as changed					setValue($key, $newValue);					$changed = true;				}			}			else if (hasValue($key))			{				// new value is the same as the source value,				// and cache has a cached field				delete data[$key];			}			return $changed;		}	}}