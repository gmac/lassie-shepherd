/*** Lassie Engine Game Player* @author Greg MacWilliam.*/package com.lassie.player.model{	import com.lassie.player.events.ModelEvent;	import com.lassie.utils.XmlUtil;	import flash.geom.Point;	import flash.events.Event;		final public class RoomLayer extends DataModel	{		private const NEXT:String = "+";		private const PREV:String = "-";				// public		// [redrawEnabled]: specifies whether or not display should be updated while setting model properties.		public var redrawEnabled:Boolean = true;				// private		//private var _sourceXML:XML;		private var _states:Object;		private var _statesIndex:Array;		private var _data:RoomLayerData;		private var _stateData:RoomLayerState;		private var _parentRoom:Room;				public function RoomLayer($id:String, $parent:Room):void		{			super($id);						_parentRoom = $parent;			_data = new RoomLayerData();			_states = new Object();			_statesIndex = new Array();			cacheEnabled = true;		}			//-------------------------------------------------	// Overrides	//-------------------------------------------------			override public function destroy():void		{			for (var $j:String in _states) {				var $state:RoomLayerState = _states[$j] as RoomLayerState;				$state.destroy();				delete _states[$j];			}			//_sourceXML = null;			_states = null;			_statesIndex = null;			_stateData = null;			_parentRoom = null;			cacheEnabled = false;		}				override public function refresh():void		{			// update the cache object, then reset the layer state using new config.			_cache = parent.cache.getNamespace(id);			_setLayerState(state);			update();		}				override internal function parse($xml:XML):void		{			// parse XML attributes onto data object.			XmlUtil.parseAttributes(_data, $xml.@*);						// loop through and compile states list.			for each (var $stateXml:XML in $xml.states.state)			{				var $state:RoomLayerState = _getStateById($stateXml.@id);				_statesIndex.push($state.id);				$state.parse($stateXml);				$state.setIndex( _statesIndex.length-1 );			}			refresh();						// update the layer's indexing.			_updateIndexing();			_loaded = true;		}				override public function toString():String {			return "[Layer] id:"+ id +", type:"+ type;		}			//-------------------------------------------------	// Model methods	//-------------------------------------------------				/**		* Called when setting cache fields:		* calls update when a field changes.		*/		private function _updateDisplay():void {			if (redrawEnabled) update();		}			//-------------------------------------------------	// State methods	//-------------------------------------------------				/**		* Gets a layer state by id for public distribution.		* The returned state is refreshed before being released into the application.		*/		public function getState($id:String):RoomLayerState		{			var $state:RoomLayerState = _getStateById( $id );			$state.refresh();			return $state;		}				/**		* Gets a layer state by Id name, or creates the state if it does not exist.		*/		private function _getStateById($id:String, $create:Boolean=true):RoomLayerState		{			if (containsState($id))			{				// Refresh a state's cache each time it is retrieved.				// This will assure that all states served by the room are released with an up-to-date cache.				// This avoids every state needing to listen to the main cache for updates.				return _states[$id] as RoomLayerState;			}			else if ($create)			{				_states[$id] = new RoomLayerState($id, this);				return _states[$id];			}			return null;		}		/**		* Gets a layer state by numeric index.		*/		private function _getStateAt($index:int):RoomLayerState		{			if ($index >= 0 && $index < _statesIndex.length) {				return _getStateById(_statesIndex[$index]);			}			return null;		}				/**		* Sets a new active layer state, (refreshing the state cache in the process).		*/		private function _setLayerState($id:String):void		{			if (!!_stateData) {				// clear any existing state data reference.				_stateData.removeEventListener(ModelEvent.UPDATE_DISPLAY, this._onStateDataUpdate);				_stateData = null;			}			_stateData = getState($id);			_stateData.addEventListener(ModelEvent.UPDATE_DISPLAY, this._onStateDataUpdate, false, 0, true);		}				/**		* Updates the layer state based upon all state index shifts that were cached before the layer loaded.		*/		private function _updateIndexing():void		{			// disable redrawing and track update status. 			var $update:Boolean = false;			var $redraw:Boolean = redrawEnabled;			redrawEnabled = false;						// create an array of indexing queues, then omit the first position (it will always be blank).			var $indexing:Array = indexing.split(",");			$indexing.shift();						// loop through all indexing queues.			while ($indexing.length > 0)			{				var $shift:Boolean = false;				switch( $indexing.shift() ) {					case NEXT: $shift = nextState(); break;					case PREV: $shift = prevState(); break;				}				if ($shift) $update = true;			}						// reset the indexing field now that its data had been applied.			indexing = "";						// restore redraw status and call update if changes were made.			redrawEnabled = $redraw;			if ($update) _updateDisplay();		}				/**		* Tests if the layer currently contains a state with the specified id.		*/		public function containsState($id:String):Boolean {			return _states[$id] != undefined;		}				/**		* Gets the number of states in this layer.		*/		public function get numStateIndices():int {			return _statesIndex.length;		}				/**		* Gets the index of the currently active state.		*/		public function get currentStateIndex():int {			return _statesIndex.indexOf(state);		}				/**		* Advances to next state in the states index.		*/		public function nextState():Boolean		{			if (numStateIndices > 0) {				// state index has been loaded: shift state.				var $index:int = currentStateIndex;				if ($index+1 < numStateIndices) {					state = _getStateAt($index+1).id;					return true;				}			}			else {				// no state index has been loaded.				indexing += ("," + NEXT);			}			return false;		}				/**		* Reverts to previous state within the states index.		*/		public function prevState():Boolean		{			if (numStateIndices > 0) {				// state index has been loaded: shift state.				var $index:int = currentStateIndex;				if ($index-1 >= 0) {					state = _getStateAt($index-1).id;					return true;				}			}			else {				// no state index has been loaded.				indexing += ("," + PREV);			}			return false;		}				/**		* Merges data from an Actor record into this model. Used for Avatar composites.		*/		public function mergeActor($actor:Actor):void		{			// store and disable current redraw setting.			var $redraw:Boolean = redrawEnabled;			redrawEnabled = false;						// set all model properties			_data.asset = $actor.asset;			layerState.imageX = $actor.regX;			layerState.imageY = $actor.regY;			layerState.subtitleColor = $actor.subtitleColor;						// restore redraw setting.			redrawEnabled = $redraw;		}			//-------------------------------------------------	// READ-ONLY	//-------------------------------------------------				public function get parent():Room {			return _parentRoom;		}				public function get layerState():RoomLayerState {			return _stateData;		}				public function get type():String {			return _data.type;		}				public function get asset():String {			return _data.asset;		}				public function get depth():int {			return _data.depth;		}				public function get regPoint():Point {			return (!!_stateData) ? new Point(layerState.x, layerState.y) : null;		}				public function get mapPoint():Point {			return (!!_stateData) ? new Point(layerState.mapX, layerState.mapY) : null;		}			//-------------------------------------------------	// Layer fields	//-------------------------------------------------		/**		* Specifies if the active layer state.		*/		public function get state():String {			return _cache.pull("state", _data.state);		}		public function set state($id:String):void {			if (state != $id) {				_setLayerState($id);				_cache.push("state", $id);				_updateDisplay();			}		}				/**		* Specifies if the layer is visible within the layout.		*/		public function get visible():Boolean {			return _cache.pull("vis", _data.visible);		}		public function set visible($enable:Boolean):void {			_cache.push("vis", $enable, _data.visible, !_loaded);			_updateDisplay();		}				/**		* Specifies if the layer should be rendered into a room layout.		* Setting this field does NOT call display updates; this must be set before a room is rendered.		*/		public function get render():Boolean {			if (omit) return false;			return _cache.pull("render", _data.render);		}		public function set render($enable:Boolean):void {			_cache.push("render", $enable, _data.render, !_loaded);		}				/**		* Specifies if the layer should be entirely omitted from it's parent room layout until further notice.		* A layer that has been omitted will not render within a room, regardless of its "render" setting.		* Setting this field does NOT call display updates; this must be set before a room is rendered.		*/		public function get omit():Boolean {			return _cache.pull("omit", _data.omit);		}		public function set omit($enable:Boolean):void {			_cache.push("omit", $enable, _data.omit, !_loaded);		}				/**		* @private		* "indexing" is an internal layer control property for managing state index assignments prior to the layer being loaded.		* When calling "nextState()" and "prevState()" prior to the layer loading, there is no state index table available to adjust.		* The indexing property caches adjustments to layer indexing that will be applied to the layer upon loading.		*/		internal function get indexing():String {			return _cache.pull("indexing", _data.indexing);		}		internal function set indexing($value:String):void {			_cache.push("indexing", $value, _data.indexing, !_loaded);		}			//-------------------------------------------------	// Event handlers	//-------------------------------------------------			/**		* @private called upon the layer state being updated.		*/		private function _onStateDataUpdate($event:Event):void {			_updateDisplay();		}	}}import com.lassie.player.room.LayerType;final internal class RoomLayerData extends Object{	public var type:String = LayerType.PUPPET;	public var asset:String = "";	public var depth:int = 0;	public var omit:Boolean = false;	public var render:Boolean = true;	public var visible:Boolean = true;	public var state:String = "base";	public var indexing:String = "";		public function RoomLayerData():void {		super();	}}