/*** Lassie Engine Game Player* @author Greg MacWilliam.*/package com.lassie.player.room{	import com.lassie.player.core.*;	import com.lassie.player.core.LPSprite;	import com.lassie.player.events.LibraryEvent;	import com.lassie.player.events.DisplayEvent;	import com.lassie.player.events.ModelEvent;	import com.lassie.player.geom.Filter;	import com.lassie.player.model.Room;	import com.lassie.player.model.RoomLayer;	import com.lassie.player.model.Position;	import com.lassie.player.model.Script;	import flash.display.Sprite;	import flash.events.Event;	import flash.geom.Point;	final public class RoomDisplay extends LPSprite implements IRoomDisplay	{		static public const NULL_SOUNDTRACK:String = "_null";		// private		private var _model:Room;		private var _bg:BackgroundLayer;		private var _avatar:AvatarLayer;		private var _floats:FloatContainer;		private var _layers:Object;		private var _puppets:Object;		private var _startAt:String = "";		private var _initLoad:Boolean = false;		private var _loaded:Boolean = false;		private var _overlay:Boolean = false;	//-------------------------------------------------	// Object methods	//-------------------------------------------------		public function RoomDisplay($model:Room, $startPositionId:String="", $overlay:Boolean=false):void		{			super();			mouseEnabled = false;			// create layer registry			_layers = new Object();			_puppets = new Object();			GridActivity.startPosition = $startPositionId;			_startAt = $startPositionId;			_overlay = $overlay;			// store reference to data model.			_model = $model;		}		override public function destroy():void		{			// call cleanup script before destroying configuration.			var $cleanup:Script = model.getScript(model.cleanupScript);			if (!!$cleanup) gameController.processXML($cleanup.script, true);			// begin destruction...			super.destroy();			// destroy all layers in the layout.			for (var $layerId:String in _layers) {				RoomLayerDisplay(_layers[$layerId]).destroy();				delete _layers[$layerId];			}			// clear all puppet references			for (var $puppetId:String in _puppets) {				delete _puppets[$puppetId];			}			// destroy floating layer configuration.			if (_floats != null) _floats.destroy();			// clear all layers from the display.			_removeAllChildren();			// unsubscribe model listeners			_model.removeEventListener(ModelEvent.UPDATE_DISPLAY, this._onRefresh);			_bg = null;			_avatar = null;			_floats = null;			_model = null;			_layers = null;			_puppets = null;		}		/**		* Called upon the room display's first initialization on stage.		* Automatically starts the room's loading process.		*/		override protected function _finit():void {			load();		}		/**		* Initializes loading of the room layout.		* This method is build with a switch so that loading can only be initialized once.		* Load is called by the room itself, or by the LayoutManager while loading a room into the UI.		*/		final public function load():void		{			if (!_initLoad) {				// disable keyboard input while loading room data and assets.				// IMPORTANT: set these flags BEFORE calling the actual load process.				_setLoading(true);				_initLoad = true;				// perform the actual load of data.				_model.addEventListener(ModelEvent.MODEL_READY, this._onModelReady, false, 0, true);				_model.load();			}		}		/**		* Configures UI controls for load latency.		* Keyboard is disabled and wait cursor is displayed during load process.		*/		private function _setLoading($loading:Boolean):void {			uiKeyboard.systemEnabled = !$loading;			uiCursor.systemWait = $loading;		}	//-------------------------------------------------	// Read-only properties	//-------------------------------------------------		public function get model():Room {			return _model;		}		public function get background():BackgroundLayer {			return _bg;		}		public function get avatar():AvatarLayer {			return _avatar;		}		public function get hasAvatar():Boolean {			return _avatar != null;		}		public function get isOverlay():Boolean {			return _overlay;		}		public function get loaded():Boolean {			return _loaded;		}	//-------------------------------------------------	// Load / setup process	//-------------------------------------------------		/**		* 1a) load process starts in the constructor.		* 1b) Model has finished loading, so load assets.		*/		private function _onModelReady($event:Event):void {			_model.prerender();			_model.removeEventListener(ModelEvent.MODEL_READY, this._onModelReady);			_model.addEventListener(ModelEvent.UPDATE_DISPLAY, this._onRefresh, false, 0, true);			_loadAssets();		}		/**		* 2a) Load library assets		*/		private function _loadAssets():void		{			// load room assets			var $loaderName:String = gameLibrary.getUniqueLoaderName();			var $libsToLoad:Array = new Array(model.coreLibs);			if (gameModel.systemVoiceEnabled) $libsToLoad.push(model.voiceLibs);			//if (gameModel.voiceEnabled) $libsToLoad.push(model.voiceLibs);			gameLibrary.addLoadListener($loaderName, LibraryEvent.COMPLETE, this._onAssetsReady);			gameLibrary.load($loaderName, $libsToLoad.join(","));		}			/**			* 2b) Library assets have finished loading, so proceed to build room layout.			*/			private function _onAssetsReady($event:LibraryEvent):void {				gameLibrary.removeLoadListener($event.loaderName, LibraryEvent.COMPLETE, this._onAssetsReady);				_setLoading(false);				_build();			}		/**		* 3a) Render room layout after both model and library assets are ready.		*/		private function _build():void		{			// Background Layer			// do not display background plate if room is loaded as a layout overlay.			_bg = new BackgroundLayer(model.backgroundLayer, this);			_registerLayer(_bg);			if (!_overlay) addChild(_bg);			var $layer:RoomLayer;			// add all backdrop planes behind the background layer			for (var $bg:int=model.backgroundLayer.depth-1; $bg >= 0; $bg--)			{				$layer = model.getLayerAt($bg);				if ($layer.render)				{					var $plane:PlaneLayer = new PlaneLayer($layer, this, true);					_registerLayer($plane);					addChildAt($plane, 0);				}			}			// create new environment for floating layers.			_floats = new FloatContainer(this);			// add all puppets and planes to float container			for (var $fg:int=model.backgroundLayer.depth+1; $fg < model.numLayers; $fg++)			{				$layer = model.getLayerAt($fg);				if ($layer.render)				{					var $sprite:RoomLayerDisplay = RoomLayerDisplay.create($layer, this);					_registerLayer($sprite);					_floats.addLayer($sprite);				}			}			// add floating layers and initialize the layout.			addChild(_floats);			_initRoom();		}		/**		* 3b) Adds a layer reference to the room registry.		*/		private function _registerLayer($layer:RoomLayerDisplay):void		{			// record all layers in a master table			_layers[$layer.id] = $layer;			// additionally note all puppets.			if ($layer is PuppetLayer) {				_puppets[$layer.id] = $layer;			}		}		/**		* 4) initialize the room display.		*/		private function _initRoom():void		{			// set avatar reference.			_avatar = getLayer(LayerInstanceName.AVATAR) as AvatarLayer;			// pull starting position model.			var $startAt:Position = model.getPosition(_startAt);			// 1) PLACE AVATAR			// place and rotate the avatar to the starting queue position			if (_avatar != null && $startAt != null) {				_avatar.model.redrawEnabled = false;				_avatar.model.layerState.x = $startAt.x;				_avatar.model.layerState.y = $startAt.y;				_avatar.model.layerState.turnView = $startAt.turnView;				_avatar.model.redrawEnabled = true;				_avatar.redraw();				_avatar.setRestState( $startAt.turnView );				_avatar.applyGridFilter( $startAt.filter );			}			// 2) PLACE VIEWPORT			// center screen on target view			if (_avatar != null) {				// center upon avatar's bounding rectangle.				_bg.centerOnRect(_avatar.getRect(this));			}			else if ($startAt != null) {				// center upon starting position.				_bg.centerOnPoint($startAt.point);			}			else {				// otherwise, just update scroll to adjust all parallax layers.				_bg.updateScroll();			}			// 3) REFRESH MODEL CONFIG			// call for a model update to trigger a room refresh.			model.update();			// 4) CALL START-POSITION SCRIPT			// run any scripts associated with the starting position.			if (!!$startAt && $startAt.hasScript) {				/**				* Update grid activity status before and after calling the script.				* Grid activity will provide status information to conditional logic commands.				*/				GridActivity.callingPosition = true;				GridActivity.atNodeName = $startAt.id;				/**				* run scripts as a seperate process branch.				* this will avoid inteferance with the trunk process that is loading the room.				*/				gameController.processXML($startAt.script, true);				GridActivity.callingPosition = false;				GridActivity.atNodeName = "";			}			// 5) ROOM READY			// notify that the room display is ready.			// send out the event through the main game display controller when NOT rendering as a UI overlay.			// this will notify all global listeners of the room load.			// when loading as an overlay, just send out local notification from the room display itself.			var $scope:Sprite = _overlay ? this : gameDisplay;			$scope.dispatchEvent(new DisplayEvent(DisplayEvent.ROOM_DISPLAY_READY));			// 6) Flag room as being completely loaded.			_loaded = true;		}	//-------------------------------------------------	// Model refresh methods	//-------------------------------------------------		/**		* Called upon an update to the model.		*/		private function _onRefresh($event:Event=null):void		{			if (!_overlay)			{				// Set room's soundtrack.				if (model.soundtrack1 != RoomDisplay.NULL_SOUNDTRACK) gameSound.channel1 = model.soundtrack1;				if (model.soundtrack2 != RoomDisplay.NULL_SOUNDTRACK) gameSound.channel2 = model.soundtrack2;				//model.gridData.draw(_floats);				// restack all floats				_floats.restack();			}		}	//-------------------------------------------------	// Room methods	//-------------------------------------------------		/**		* Returns a reference to the background layer typed as a IRoomScroll controller object.		*/		public function get scroll():IRoomScroll {			return _bg;		}		/**		* Gets a room layer display object by Id.		*/		public function getLayer($id:String):IRoomLayerDisplay		{			if (_layers.hasOwnProperty($id)) {				return _layers[$id] as IRoomLayerDisplay;			}			return null;		}		/**		* Gets a puppet layer object by Id.		*/		public function getPuppet($id:String):IPuppetDisplay		{			if (_puppets.hasOwnProperty($id)) {				return _puppets[$id] as IPuppetDisplay;			}			return null;		}		/**		* Removes a layer from the layout.		*/		public function removeLayer($id:String):void		{			var $layer:RoomLayerDisplay = getLayer($id) as RoomLayerDisplay;			if (!!$layer)			{				// delete layer from the room registry.				if (_layers.hasOwnProperty( $layer.id )) delete _layers[ $layer.id ];				if (_puppets.hasOwnProperty( $layer.id )) delete _puppets[ $layer.id ];				// remove the layer from its display.				if ($layer.parent == _floats) _floats.removeLayer($layer);				else $layer.parent.removeChild($layer);				// destroy the layer				$layer.destroy();			}		}		//-------------------------------------------------		// Debug methods		//-------------------------------------------------		/**		private var _canvas:Sprite;		* Draws a line representing the path formed by an array of nodes.		internal function drawNodeArray($nodes:Array):void		{			if ($nodes.length > 0)			{				if (_canvas == null) {					_canvas = new Sprite();					_floats.addChild(_canvas);				}				_canvas.graphics.clear();				_canvas.graphics.lineStyle(1, 0xFF0000, 1);				_canvas.graphics.moveTo( $nodes[0].x, $nodes[0].y );				for each (var $pt:Point in $nodes)				{					trace($pt);					_canvas.graphics.lineTo($pt.x, $pt.y);				}			}		}		*/	}}