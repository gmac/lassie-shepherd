/*** Lassie Engine Game Player* @author Greg MacWilliam.*/package com.lassie.player.room{	import com.lassie.player.core.IRoomScroll;	import com.lassie.player.model.RoomLayer;	import com.lassie.player.events.ScrollEvent;	import flash.geom.Rectangle;	import flash.geom.Point;	import flash.events.Event;	final public class BackgroundLayer extends RoomLayerDisplay implements IRoomScroll	{		// private		private var _view:Rectangle;		private var _viewWidth:int = 0;		private var _viewHeight:int = 0;		private var _roomWidth:int = 0;		private var _roomHeight:int = 0;		private var _rangeX:int = 0;		private var _rangeY:int = 0;		private var _marginLeft:int = 0;		private var _marginRight:int = 0;		private var _marginTop:int = 0;		private var _marginBottom:int = 0;		private var _itemTooltipOnPress:Boolean = false;		private var _cropEnabled:Boolean = false;		public function BackgroundLayer($model:RoomLayer, $parent:RoomDisplay):void		{			super($model, $parent);			_viewWidth = gameDisplay.displayWidth;			_viewHeight = gameDisplay.displayHeight;			_view = new Rectangle(0, 0, _viewWidth, _viewHeight);			// frame oversize bitmap images within the view rectangle.			_cropEnabled = (_viewWidth > 2880 || _viewHeight > 2880);			_updateView();		}	//-------------------------------------------------	// Overrides	//-------------------------------------------------		override public function destroy():void		{			super.destroy();			cacheAsBitmap = false;			scrollRect = null;		}		override public function toString():String {			return "[BackgroundLayer]";		}	//-------------------------------------------------	// Read-only properties	//-------------------------------------------------		/**		* Gets the bounding width of the room layout.		*/		public function get roomWidth():int {			return _roomWidth;		}		/**		* Gets the bounding height of the room layout.		*/		public function get roomHeight():int {			return _roomHeight;		}		/**		* Gets the maximum possible range of scrolling along the X axis.		*/		public function get scrollRangeX():int {			return _rangeX;		}		/**		* Gets the maximum possible range of scrolling along the Y axis.		*/		public function get scrollRangeY():int {			return _rangeY;		}		/**		* Gets the current scroll along the X axis.		*/		public function get scrollX():int {			return _view.x;		}		/**		* Gets the current scroll along the Y axis.		*/		public function get scrollY():int {			return _view.y;		}		/**		* Specifies the current view coordinates of the background display.		*/		public function get viewRect():Rectangle {			return _view;		}		/**		* Specifies if scrolling is enabled.		*/		public function get scrollEnabled():Boolean {			return _rangeX > 0 || _rangeY > 0;		}	//-------------------------------------------------	// Public methods	//-------------------------------------------------		override public function redraw():void		{			x = y = 0;			_setHitArea();			_setAsset();			_setImage();			// update room dimensions			_roomWidth = Math.max(model.layerState.hitWidth, _viewWidth);			_roomHeight = Math.max(model.layerState.hitHeight, _viewHeight);			_rangeX = Math.max(0, _roomWidth - _viewWidth);			_rangeY = Math.max(0, _roomHeight - _viewHeight);			_marginLeft = model.layerState.scrollMarginLeft;			_marginRight = model.layerState.scrollMarginRight;			_marginTop = model.layerState.scrollMarginTop;			_marginBottom = model.layerState.scrollMarginBottom;			mouseEnabled = model.layerState.mouseEnabled;			cacheAsBitmap = true;			updateScroll();		}	//-------------------------------------------------	// Scrolling	//-------------------------------------------------		/**		* Alerts all listeners with information about the current room scroll.		*/		public function updateScroll():void {			dispatchEvent(new ScrollEvent(new Rectangle(0, 0, _roomWidth, _roomHeight), _view, _cropEnabled));		}		/**		* Sets the upper-left corner of the room's viewport to the specified position.		*/		public function scrollAt($upperLeft:Point):void		{			_view.x = Math.max(0, Math.min(_rangeX, $upperLeft.x));			_view.y = Math.max(0, Math.min(_rangeY, $upperLeft.y));			_view.width = _viewWidth;			_view.height = _viewHeight;			_updateView();		}		/**		* Centers the viewport on the specified point.		*/		public function centerOnPoint($pt:Point):void {			scrollAt( new Point($pt.x-Math.round(_viewWidth/2), $pt.y-Math.round(_viewHeight/2)) );		}		/**		* Centers the viewport on the specified rectangle.		*/		public function centerOnRect($rect:Rectangle):void {			centerOnPoint( $rect.topLeft.add(new Point($rect.width/2, $rect.height/2)) );		}		/**		* Tracks motion within the room's bounds and adjusts scrolling as needed.		* @param $target: the target coordinates within the room.		* @param $trend: the last change of movement within the room bounds.		*/		public function scroll($target:Point, $trend:Point):void		{			// HORIZONTAL SCROLL			// If room has a horiontal motion range			if (_rangeX > 0)			{				// IF:				// - adjusted reference point is within left or right margins				// - and motion is incrementing leftward or rightward respectively				if ($target.x - _view.x < _marginLeft && $trend.x < 0)				{					// scroll left					_view.x = Math.max(0, Math.round(_view.x + $trend.x));				}				else if ($target.x + _view.x > _view.width - _marginRight && $trend.x > 0)				{					// scroll right					_view.x = Math.min(Math.round(_view.x + $trend.x), _rangeX);				}			}			// VERTICAL SCROLL			// If room has a vertical motion range			if (_rangeY > 0)			{				// IF:				// - adjusted reference point is within top or bottom margins				// - and motion is incrementing upward or downward respectively				if ($target.y - _view.y < _marginTop && $trend.y < 0)				{					// scroll up					_view.y = Math.max(0, Math.round(_view.y + $trend.y));				}				else if ($target.y + _view.y > _view.height - _marginBottom && $trend.y > 0)				{					// scroll down					_view.y = Math.min(Math.round(_view.y + $trend.y), _rangeY);				}			}			// apply new view rectangle.			_updateView();		}		/**		* Updates the background position based on the current view rect.		* This display will be applied using either		*/		private function _updateView():void		{			// record current scroll coordinates			var $x:Number = !!scrollRect ? scrollRect.x : -x;			var $y:Number = !!scrollRect ? scrollRect.y : -y;			// apply new scroll rectangle			if (_cropEnabled) {				scrollRect = _view;			} else {				x = -_view.x;				y = -_view.y;			}			// if view is dirty, update all other scrollers.			if ($x != _view.x || $y != _view.y) {				updateScroll();			}		}	//-------------------------------------------------	// Avatar tweening	//-------------------------------------------------		/**		* Tweens avatar layer to the specified coordinates.		*/		private function _moveAvatarTo($x:int, $y:int):void		{			// if parent room has an avatar layer			if (parentRoom.hasAvatar) {				// generate tween XML script				var $moveTo:XML = PuppetTween.getPointXML(new Point($x, $y), LayerInstanceName.AVATAR, PuppetTween.MOVE, true, true);				// pass tween XML off to game controller for processing.				gameController.processXML($moveTo);			}		}	//-------------------------------------------------	// Event handlers	//-------------------------------------------------		/**		* Mouse click (mouse was pressed on and then release from this layer)		*/		override protected function _onMouseClick($event:Event):void		{			if (!_itemTooltipOnPress) {				// move avatar to mouse position if there was not an item cursor active upon mouse down.				_moveAvatarTo(mouseX, mouseY);			}			// reset item tooltip tracker.			_itemTooltipOnPress = false;		}		/**		* Mouse down		*/		override protected function _onMouseDown($event:Event):void		{			// record if there is an item cursor active upon mouse down.			_itemTooltipOnPress = uiCursor.hasItemTooltip;			uiContext.staticVerb = "";		}		/**		* Mouse up		*/		private function _onMouseUp($event:Event):void {			// do nothing		}	}}