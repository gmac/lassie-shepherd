/*** Lassie Engine Game Player* @author Greg MacWilliam.*/package com.lassie.player.room{	import com.lassie.player.model.Room;	import com.lassie.player.model.RoomLayer;	import com.lassie.player.events.PuppetEvent;	import com.lassie.player.geom.*;	import flash.geom.Point;	import flash.events.EventDispatcher;	import flash.events.Event;	final internal class PuppetTweener extends EventDispatcher	{		// private		private var _room:Room;		private var _puppet:PuppetLayer;		private var _activeTween:TweenParam;		private var _tweenQueue:Array;		private var _tweening:Boolean = false;		private var _animateMoves:Boolean = true;		private var _frameCount:int = 0;		private var _frameHold:int = 2;		public function PuppetTweener($puppet:PuppetLayer):void		{			super();			_puppet = $puppet;			_room = $puppet.parentRoom.model;			_tweenQueue = new Array();		}		public function destroy():void		{			_enableTween(false);			_activeTween = null;			_tweenQueue = null;			_puppet = null;			_room = null;		}	//-------------------------------------------------	// Public methods	//-------------------------------------------------		/**		* Queues up and plays a new tween sequence.		*/		public function queue($tween:PuppetTween):void		{			clear();			if ($tween.valid) {				_setGoals($tween);			}		}		/**		* Stops current tween sequence without clearing it.		*/		public function stop():void		{			if (!!_activeTween) {				_enableTween(false);				_puppet.setRestState();				_puppet.cacheDisplay();			}		}		/**		* Resumes a stopped tween sequence.		*/		public function resume():void		{			if (_activeTween != null) {				_enableTween(true);				if (_activeTween.type == PuppetTween.MOVE) {					_puppet.setMoveState();				}			}		}		/**		* Skips straight to the end point of all queued tweens.		*/		public function skip():void		{			// stop tweens			_enableTween(false);			var $target:Point;			var $view:int = -1;			// Skip ahead to the final motion sequence.			if (_tweenQueue.length > 0) {				while ( _tweenQueue.length > 0 )				{					// Search from the back of the queue for the last motion sequence.					var $tween:TweenParam = _tweenQueue.pop() as TweenParam;					// capture the final turn setting.					if ($tween.type == PuppetTween.TURN || $tween.type == PuppetTween.MOVE_THEN_TURN) {						$view = $tween.goalView;					}					// capture the final tween position.					if ($tween.type == PuppetTween.MOVE || $tween.type == PuppetTween.MOVE_THEN_TURN) {						$target = $tween.goalPoint;						break;					}				}			}			if (!!$target) _puppet.position = $target;			_puppet.setRestState($view);			// clear all tweens.			stop();			clear();		}		/**		* Clears all tween configuration.		*/		public function clear():void		{			_enableTween(false);			_activeTween = null;			_tweenQueue = new Array();			_puppet.setRestState();			_puppet.cacheDisplay();		}		/**		* Signals the completion of a tween sequence.		*/		private function _complete():void {			_puppet.dispatchEvent(new PuppetEvent(PuppetEvent.TWEEN_COMPLETE));		}	//-------------------------------------------------	// Configuration process	//-------------------------------------------------		/**		* 1) Set the tween's goal points		*/		private function _setGoals($tween:PuppetTween):void		{			if (!!$tween.targetPoint)			{				// set goal point based on a provided point.				// puppet will both move to and turn toward this point.				$tween.goalMovePoint = $tween.targetPoint;				$tween.goalTurnPoint = $tween.targetPoint;			}			else if (!!$tween.targetPosition && _room.hasPosition($tween.targetPosition))			{				// set goal point based on a named room position.				// puppet will both move to and turn toward this point.				$tween.goalMovePoint = _room.getPosition($tween.targetPosition).point;				$tween.goalTurnPoint = $tween.goalMovePoint;			}			else if (!!$tween.targetLayer && _room.hasLayer($tween.targetLayer))			{				// set goal point based on the target layer's mapping (floor) point.				// puppet will move to map point and then turn toward the layer's registration.				var $layer:RoomLayer = _room.getLayer($tween.targetLayer);				$tween.goalMovePoint = $layer.mapPoint;				$tween.goalTurnPoint = GeomUtil.turnOffset($layer.mapPoint, $layer.layerState.mapTurnTo);				// $tween.goalTurnPoint = $layer.regPoint;			}			// set global configurations			_animateMoves = $tween.animateMoves;			// proceed with tween if a goal point was resolved			if (!!$tween.goalMovePoint) {				_setQueue($tween);			}		}		/**		* 2) Evaluate tween type and goal points into a queue of tweens		*/		private function _setQueue($tween:PuppetTween):void		{			// Configure all movement tweens			if ($tween.type == PuppetTween.MOVE || $tween.type == PuppetTween.MOVE_THEN_TURN)			{				if ($tween.followGrid && !!_room.gridData)				{					// PATH TO TARGET					// generate a path from the puppet's current location to the target map point					var $path:Path = _room.gridData.getPath(_puppet.position, $tween.goalMovePoint, $tween.confineToWalkarea);					if (!!$path && $path.nodes.length > 0)					{						// A PATH WITH LENGTH WAS FOUND						// remove the first node from the path						// (first node is the puppet's current position)						var $prev:Node = $path.nodes.shift();						var $next:Node = $path.nodes[0];						var $node:Node;						// Call grid scripts assigned to the starting point before moving on.						_callGridScript($prev.script, -1, GeomUtil.turnView(GeomUtil.angleDegrees($prev, $next)), $prev.name, "", $next.name);						// add each additional node into the tween queue as a target						while ($path.nodes.length > 0) {							$node = $path.nodes.shift();							$next = ($path.nodes.length > 0) ? $path.nodes[0] : null;							// only queue turns for segments that have shifted from the previous node.							if (!$prev.equals($node)) _tweenQueue.push(new TweenParam(PuppetTween.TURN, $node));							_tweenQueue.push(new TweenParam(PuppetTween.MOVE, $node, 0, $prev, $next));							$prev = $node;						}						$path.destroy();					}				}				else				{					// DIRECT TO TARGET					_tweenQueue.push(new TweenParam(PuppetTween.MOVE, $tween.goalMovePoint, $tween.goalTurnView));				}			}			// Configure primary turn tween after all movements have been added.			if ($tween.type == PuppetTween.TURN || $tween.type == PuppetTween.MOVE_THEN_TURN) {				_tweenQueue.push(new TweenParam(PuppetTween.TURN, $tween.goalTurnPoint, $tween.goalTurnView));			}			_runQueue();		}		/**		* 3) Run the tween queue.		*/		private function _runQueue():void		{			if (_tweenQueue.length > 0)			{				// HAS TWEENS: run next tween.				_startNewTween( _tweenQueue.shift() );			}			else			{				// NO MORE TWEENS: clear queue.				clear();				_complete();			}		}	//-------------------------------------------------	// Frame rate methods	//-------------------------------------------------		/**		* Enables / disables the puppet's enterFrame handler.		*/		private function _enableTween($enable:Boolean):void		{			if (!_tweening && $enable) {				_puppet.addEventListener(Event.ENTER_FRAME, this._onTweenFrame, false, 0, true);			}			else if (_tweening && !$enable) {				_puppet.removeEventListener(Event.ENTER_FRAME, this._onTweenFrame);			}			_tweening = $enable;		}		/**		* EnterFrame event handler		*/		private function _onTweenFrame($event:Event):void		{			switch (_activeTween.type) {				case PuppetTween.MOVE: _moveFrame(); return;				case PuppetTween.TURN: _turnFrame(); return;			}		}	//-------------------------------------------------	// Tween frame methods	//-------------------------------------------------		/**		* Configures a new tween sequence.		*/		private function _startNewTween($tween:TweenParam):void		{			_activeTween = $tween;			// initialize tween with current puppet attributes as start values.			_activeTween.init(_puppet.position, _puppet.turnView, _puppet.model.layerState.tweenRate);			// VALIDATE MOVE			if (_activeTween.type == PuppetTween.MOVE)			{				if (_puppet.position.equals(_activeTween.goalPoint))				{					// abort tween if the puppet is already at the goal					_runQueue();					return;				}				else if (_animateMoves)				{					// set a directional move animation at the start of each move tween					_puppet.setMoveState(_activeTween.goalView);					_puppet.setGridFilterSegment(_activeTween.filter);				}			}			// VALIDATE TURN			else if (_activeTween.type == PuppetTween.TURN && _puppet.turnView == _activeTween.goalView)			{				_runQueue();				return;			}			// enable frame handler.			_enableTween(true);		}		/**		* Tweens a move frame.		*/		private function _moveFrame():void		{			// get puppet's current rate modifier (based on speed matrix) and current position.			var $rateModifier:Number = _puppet.rateFilterMatrix;			var $current:Point = _puppet.position;			// test if puppet's current position is within a single movement of goal point.			var $withinRange:Boolean = (GeomUtil.distance($current, _activeTween.goalPoint) <= (_activeTween.moveRate * $rateModifier));			// test if puppet has passed goal point			var $pastGoal:Boolean = (GeomUtil.distance($current, _activeTween.startPoint) >= _activeTween.moveDistance);			// test is tween has finished			if ($withinRange || $pastGoal)			{				// TWEEN HAS FINISHED				// snap puppet to goal point				_puppet.moveTo(_activeTween.goalPoint);				// call complete script				_callGridScript(_activeTween.completeScript, _activeTween.inboundTurn, _activeTween.outboundTurn, _activeTween.atNode, _activeTween.fromNode, _activeTween.toNode);				// close tween and proceed with queue.				_activeTween.close();				_runQueue();			}			else			{				// TWEEN STILL HAS DISTANCE TO COVER				// Add the scaled trajectory increment to the puppet's current position.				var $trend:Point = GeomUtil.scalePoint(_activeTween.moveIncrement, $rateModifier);				_puppet.moveTo( $current.add($trend) );			}		}		/**		* Tweens a turn frame.		*/		private function _turnFrame():void		{			if (_puppet.turnView == _activeTween.goalView)			{				// Puppet is at the goal view: Proceed.				_runQueue();			}			else if (_activeTween.turnIncrement == 0)			{				// No turn increment: set goal view and proceed.				_puppet.setRestState(_activeTween.goalView);				_runQueue();			}			else if (_frameCount == 0)			{				// otherwise, increment view.				var $view:int = _puppet.turnView + _activeTween.turnIncrement;				if ($view < 1) $view = 8;				if ($view > 8) $view = 1;				_puppet.setRestState($view);			}			_frameCount++;			if (_frameCount >= _frameHold) _frameCount = 0;		}		/**		* Calls a grid-based script with an inbound and outbound turn direction.		*/		private function _callGridScript($script:XML, $inbound:int=-1, $outbound:int=-1, $at:String="", $from:String="", $to:String=""):void		{			if (!!$script)			{				/*				* Update grid activity status before and after calling the script.				* Grid activity will provide status information to conditional logic commands.				*/				GridActivity.callingGrid = true;				GridActivity.inboundTurn = $inbound;				GridActivity.outboundTurn = $outbound;				GridActivity.atNodeName = $at;				GridActivity.fromNodeName = $from;				GridActivity.toNodeName = $to;				/*				* run script as a seperate process branch.				* this will avoid inteferance with the trunk process that is tweening the puppet.				*/				_puppet.gameController.processXML($script, true);				/*				* Reset all GridActivity fields.				*/				GridActivity.callingGrid = false;				GridActivity.inboundTurn = -1;				GridActivity.outboundTurn = -1;				GridActivity.atNodeName = "";				GridActivity.fromNodeName = "";				GridActivity.toNodeName = "";			}		}	}}import flash.geom.Point;import com.lassie.player.geom.Node;import com.lassie.player.geom.FilterPole;import com.lassie.player.geom.GeomUtil;/** Param object for configuring tween settings*/final internal class TweenParam{	private var _type:String = "";	private var _startPoint:Point;	private var _goalPoint:Point;	private var _nextPoint:Point;	private var _moveIncrement:Point;	private var _moveDistance:Number;	private var _moveRate:Number;	private var _startView:int;	private var _goalView:int = 0;	private var _turnIncrement:int;	// grid tracking settings.	private var _atNode:String = "";	private var _fromNode:String = "";	private var _toNode:String = "";	private var _inboundTurn:int = -1;	private var _outboundTurn:int = -1;	private var _filter:FilterPole;	private var _onComplete:XML;	/**	* Builds a new TweenParam object	* @param type the type of tween: move, turn, or moveThenTurn	* @param goal the goal point that this tween will target.	* @param prev the previous node in the queue; before the goal point.	* @param next the next node in the queue; after the goal point.	*/	public function TweenParam($type:String, $goalPoint:Point, $goalView:int=0, $prevNode:Node=null, $nextNode:Node=null):void	{		_type = $type;		_goalPoint = $goalPoint;		_nextPoint = $nextNode;		_goalView = $goalView;		if ($goalPoint is Node)		{			// GOAL POINT IS A VALID NODE			// store references to the goal's complete script, name, and filter settings.			var $target:Node = $goalPoint as Node;			if ($target.script.children().length() > 0) _onComplete = $target.script;			_filter = $target.filter;			_atNode = $target.name;		}		// collect origin and destination node name references.		if (!!$prevNode) _fromNode = $prevNode.name;		if (!!$nextNode) _toNode = $nextNode.name;	}	/*	* Initializes the Tween with a start point, start view, and a rate of movement.	* this method is called when puppet is in position and ready to start the tween.	*/	public function init($startPoint:Point, $startView:int, $moveRate:Number):void	{		// record start point and rate of movement		_startPoint = $startPoint;		_startView = $startView;		_moveRate = $moveRate;		// calculate a move's X and Y increment and the distance to travel.		_moveIncrement = GeomUtil.angleIncrement(_startPoint, _goalPoint, $moveRate);		_moveDistance = GeomUtil.distance(_startPoint, _goalPoint);		// calculate a turn's goal angle to face, if a custom goal view is not already set.		var $degrees:Number = GeomUtil.angleDegrees(_startPoint, _goalPoint);		if (_goalView < 1) _goalView = GeomUtil.turnView($degrees);		_turnIncrement = _getTurn(_startView, _goalView);		// calculate inbound direction: looks at angle from goal back to origin.		_inboundTurn = GeomUtil.turnView( GeomUtil.angleDegrees(_goalPoint, $startPoint) );		if (!!_nextPoint) {			// if there was a next destination point specified within the queue,			// calculate the outbound direction: looks at angle from goal out to next target.			_outboundTurn = GeomUtil.turnView( GeomUtil.angleDegrees(_goalPoint, _nextPoint) );		}	}	/*	* Configures a turn between two views	* @param $startView: the starting puppet view.	* @param $goalView: the target view to tween to.	*/	private function _getTurn($startView:int, $goalView:int):int	{		// calculate the positive turn range and its corresponding directional trend.		var $range:int = (($startView > $goalView) ? $startView - $goalView : $goalView - $startView) - 1;		var $trend:int = ($startView > $goalView) ? -1 : 1;		// configure two opposing turn options: omega is the inverse of alpha.		var $alpha:TurnParam = new TurnParam($range, $trend);		var $omega:TurnParam = new TurnParam(6-$range, -$trend);		var $best:TurnParam;		// compare the two turn options and select the best		if ($alpha.range == $omega.range)		{			// EQUAL-LENGTH TURN OPTIONS			// select the option that turns the puppet toward the camera.			if ($startView < $goalView) {				$best = ($alpha.trend < $omega.trend) ? $alpha : $omega;			} else {				$best = ($alpha.trend > $omega.trend) ? $alpha : $omega;			}		}		else		{			// ONE TURN OPTION IS SHORTER			// select more efficient option.			$best = ($alpha.range < $omega.range) ? $alpha : $omega;		}		// if final turn has no range, return no increment.		return ($best.range <= 0) ? 0 : $best.trend;	}	/*	* Closes the tween and optimizes it for garbage collection.	*/	public function close():void {		_startPoint = null;		_goalPoint = null;		_nextPoint = null;		_moveIncrement = null;	}	/*	* Gets the tween type (MOVE / TURN only).	*/	public function get type():String {		return _type;	}	/*	* MOVE: point from which puppet started moving.	*/	public function get startPoint():Point {		return _startPoint;	}	/*	* MOVE: point to which puppet will move to.	*/	public function get goalPoint():Point {		return _goalPoint;	}	/*	* TURN: view at which the puppet started this tween sequence.	*/	public function get startView():int {		return _startView;	}	/*	* MOVE: view at which puppet will display during movement.	* TURN: target view that puppet will tween to.	*/	public function get goalView():int {		return _goalView;	}	/*	* TURN: increment by which to adjust the puppet's turn view each frame (-1 / 1).	*/	public function get turnIncrement():int {		return _turnIncrement;	}	/*	* MOVE: total distance that puppet moves each frame.	*/	public function get moveRate():Number {		return _moveRate;	}	/*	* MOVE: X and Y increments by which to adjust the puppet's position each frame.	*/	public function get moveIncrement():Point {		return _moveIncrement;	}	/*	* MOVE: total length of movement from start point to goal point.	*/	public function get moveDistance():Number {		return _moveDistance;	}	/*	* MOVE: the inbound turn view of the last movement leading into this node.	*/	public function get inboundTurn():int {		return _inboundTurn;	}	/*	* MOVE: the outbound turn view of the next movement going away from this node.	*/	public function get outboundTurn():int {		return _outboundTurn;	}	/**	* Specifies the name of the node that the tween ends at.	*/	public function get atNode():String {		return _atNode;	}	/**	* Specifies the node name of the node that the tween originated from.	*/	public function get fromNode():String {		return _fromNode;	}	/**	* Specifies the node name of the next tween will be going to.	*/	public function get toNode():String {		return _toNode;	}	/**	* Specifies filters that are applied to the goal grid point.	*/	public function get filter():FilterPole {		return _filter;	}	/**	* Script to call upon completion of tween.	*/	public function get completeScript():XML {		return _onComplete;	}	/*	* Traces tween information.	*/	public function toString():String {		return "[TweenParam] type: "+ _type;	}}/** Param object for configuring turn settings*/final internal class TurnParam{	// private	public var range:int;	public var trend:int;	public function TurnParam($range:int, $trend:int):void {		range = $range;		trend = $trend;	}}