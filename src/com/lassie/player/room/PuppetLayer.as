/*** Lassie Engine Game Player* @author Greg MacWilliam.*/package com.lassie.player.room{	import com.lassie.player.model.RoomLayer;	import com.lassie.player.model.Action;	import com.lassie.player.core.IPuppetDisplay;	import com.lassie.player.core.IActionSelectable;	import com.lassie.player.core.ActionProperties;	import com.lassie.player.ui.ActionSelect;	import com.lassie.player.ui.ActionSelectMode;	import com.lassie.player.geom.*;	import flash.events.TimerEvent;	import flash.events.MouseEvent;	import flash.events.Event;	import flash.geom.ColorTransform;	import flash.geom.Point;	import flash.utils.Timer;		public class PuppetLayer extends RoomLayerDisplay implements IPuppetDisplay, IActionSelectable	{		/** @private  */		static private var _clickTimer:Timer = new Timer(300, 1);		static private var _clickId:String = "";				/**		* Resets the puppet click timer and tests if this new click counts for a double click.		*/		static private function _multiClick($id:String):Boolean		{			var $multi:Boolean = (_clickTimer.running && $id == _clickId);			_clickId = $id;			_clickTimer.reset();			_clickTimer.start();			return $multi;		}			//-------------------------------------------------	// Instance configuration	//-------------------------------------------------				// action select		private var _hovering:Boolean = false;		private var _timerEnabled:Boolean = false;		private var _actionFocus:Boolean = false;		private var _actionIndex:int = -1;		// filters		private const _GRID:String = "_grid";		private var _tweener:PuppetTweener;		private var _scaleFilter:Filter;		private var _rateFilter:Filter;		private var _colorFilter:Filter;		private var _blurFilter:Filter;		private var _gridFilter:Filter;		private var _hasScale:Boolean = false;		private var _hasColor:Boolean = false;		private var _hasBlur:Boolean = false;		private var _scrollEnabled:Boolean = false;				public function PuppetLayer($model:RoomLayer, $parent:RoomDisplay):void		{			super($model, $parent);			_tweener = new PuppetTweener(this);			_gridFilter = new Filter(_GRID, FilterAxis.RADIAL);		}			//-------------------------------------------------	// Overrides	//-------------------------------------------------				override public function destroy():void		{			super.destroy();						// clear timer references			_enableTimer(false);						// kill all tweening			_tweener.destroy();			_tweener = null;						// nullify all filters			_scaleFilter = null;			_rateFilter = null;			_colorFilter = null;			_blurFilter = null;			_gridFilter = null;		}		override public function redraw():void		{			super.redraw();			mouseEnabled = model.layerState.mouseEnabled;			_scrollEnabled = model.layerState.scrollEnabled;						// register all current filter settings with the grid.			_registerGrid();						// update all filters.			_scaleFilter = (model.layerState.scaleFilter == _GRID) ? _gridFilter : parentRoom.model.getFilter(model.layerState.scaleFilter);			_rateFilter = (model.layerState.rateFilter == _GRID) ? _gridFilter : parentRoom.model.getFilter(model.layerState.rateFilter);			_colorFilter = (model.layerState.colorFilter == _GRID) ? _gridFilter : parentRoom.model.getFilter(model.layerState.colorFilter);			_blurFilter = (model.layerState.blurFilter == _GRID) ? _gridFilter : parentRoom.model.getFilter(model.layerState.blurFilter);						// apply all updated filter settings.			_applyScale();			_applyColor();			_applyBlur();		}				override public function set position($point:Point):void		{			var $prev:Point = this.position;			super.position = $point;			if (_scrollEnabled) {				// set background scrolling.				parentRoom.background.scroll($point, $point.subtract($prev));			}						// update layering and reapply all filters.			_updateLayering();			_applyScale();			_applyColor();			_applyBlur();		}				override public function toString():String {			return "[PuppetLayer] id: "+ id;		}			//-------------------------------------------------	// Filter methods	//-------------------------------------------------			/** @private gets the scale modifier at the puppet's current position. */		internal function get scaleFilterMatrix():Number {			return (_scaleFilter != null) ? _scaleFilter.getScale(this.position) : scaleX;		}				/** @private gets the rate modifier at the puppet's current position. */		internal function get rateFilterMatrix():Number {			return (_rateFilter != null) ? _rateFilter.getRate(this.position) : 1;		}				/** @private gets the blur filter radius at the puppet's current position. */		internal function get blurFilterMatrix():Number {			return (_blurFilter != null) ? _blurFilter.getBlur(this.position).blurX : 0;		}				/** @private gets the puppet image's color transform at the current position. */		internal function get colorFilterMatrix():ColorTransform		{			if (_colorFilter != null) {				// return current grid setting, if available.				return _colorFilter.getColor(this.position);			}			else if (_image != null) {				// return current image transform, if available.				return GeomUtil.copyColorTransform(_image.transform.colorTransform);			}			// otherwise, return a blank color transform.			return new ColorTransform();		}				/**		* Registers all current display settings with the puppet's grid filter.		*/		private function _registerGrid():void		{			var $pole:FilterPole = new FilterPole(x, y);			$pole.scale = scaleFilterMatrix;			$pole.rate = rateFilterMatrix;			$pole.blur = blurFilterMatrix;			$pole.color = colorFilterMatrix;			_gridFilter.alphaPole = $pole;			_gridFilter.omegaPole = $pole.copy();		}				/**		* Applies a scale filter effect.		*/		private function _applyScale():void		{			if (_scaleFilter != null) {				scaleX = scaleY = _scaleFilter.getScale(this.position);				_hasScale = true;			}			else if (_hasScale) {				scaleX = scaleY = 1;				_hasScale = false;			}		}				/**		* Applies a color filter effect.		*/		private function _applyColor():void		{			if (_image != null) {				if (_colorFilter != null) {					_image.transform.colorTransform = _colorFilter.getColor(this.position);					_hasColor = true;				}				else if (_hasColor) {					_image.transform.colorTransform = Filter.clearColor();					_hasColor = false;				}			}		}				/**		* Applies a blur filter effect.		*/		private function _applyBlur():void		{			if (_image != null) {				if (_blurFilter != null) {					_image.filters = [_blurFilter.getBlur(this.position)];					_hasBlur = true;				}				else if (_hasBlur) {					_image.filters = [];					_hasBlur = false;				}			}		}				/**		* Immediately renders all settings of a filter onto the puppet.		*/		internal function applyGridFilter($filter:FilterPole):void		{			if (!!$filter) {				// scale filter				if (model.layerState.scaleFilter == _GRID && $filter.scaleEnabled) {					_gridFilter.alphaPole.scale = _gridFilter.omegaPole.scale = $filter.scale;					_applyScale();				}								// rate filter				if (model.layerState.rateFilter == _GRID && $filter.rateEnabled) {					_gridFilter.alphaPole.rate =  _gridFilter.omegaPole.rate = $filter.rate;				}								// color filter				if (model.layerState.colorFilter == _GRID && $filter.colorEnabled) {					_gridFilter.alphaPole.color =  _gridFilter.omegaPole.color = $filter.color;					_applyColor();				}								// blur filter				if (model.layerState.blurFilter == _GRID && $filter.blurEnabled) {					_gridFilter.alphaPole.blur =  _gridFilter.omegaPole.blur = $filter.blur;					_applyBlur();				}			}		}				/**		* Sets alpha pole to match current puppet configuration, then applies a new omega target.		*/		internal function setGridFilterSegment($filter:FilterPole):void		{			if (!!$filter) {				// scale filter				if (model.layerState.scaleFilter == _GRID) {					_gridFilter.alphaPole.scale = scaleFilterMatrix;					_gridFilter.omegaPole.scale = ($filter.scaleEnabled) ? $filter.scale : _gridFilter.alphaPole.scale;				}								// rate filter				if (model.layerState.rateFilter == _GRID) {					_gridFilter.alphaPole.rate = rateFilterMatrix;					_gridFilter.omegaPole.rate = ($filter.rateEnabled) ? $filter.rate : _gridFilter.alphaPole.rate;				}								// color filter				if (model.layerState.colorFilter == _GRID) {					_gridFilter.alphaPole.color = colorFilterMatrix;					_gridFilter.omegaPole.color = ($filter.colorEnabled) ? $filter.color : _gridFilter.alphaPole.color;				}								// blur filter				if (model.layerState.blurFilter == _GRID) {					_gridFilter.alphaPole.blur = blurFilterMatrix;					_gridFilter.omegaPole.blur = ($filter.blurEnabled) ? $filter.blur : _gridFilter.alphaPole.blur;				}								// update coordinates with new target positions.				// IMPORTANT: this must come after filter calibration.				_gridFilter.alphaPole.x = x;				_gridFilter.alphaPole.y = y;				_gridFilter.omegaPole.x = $filter.x;				_gridFilter.omegaPole.y = $filter.y;			}		}			//-------------------------------------------------	// Action methods	//-------------------------------------------------				/**		* Returns an object detailing parameters of this actionable target.		*/		public function get actionProps():Object {			return ActionProperties.create(ActionProperties.TYPE_PUPPET, model.id, model.layerState.actionProps);		}				/**		* Sets the current action targeting the layer.		*/		public function setAction($index:int):void		{			_actionIndex = _actionFocus ? $index : -1;			_setContext();		}				/**		* Clears the current action targeting the layer.		* @param $release: if true, the layer's link to the action selector is severed.		*/		public function clearAction($releaseFocus:Boolean=false):void		{			if ($releaseFocus) _actionFocus = false;			_actionIndex = -1;			_setContext();		}				/**		* Calls a layer action.		*/		public function callAction($index:int=-1, $itemId:String="", $repeat:Boolean=false):void		{			var $action:Action;						// resolve Action			if ($index >= 0)			{				// get action by index				// missing actions will be ignored and produce no results.				$action = model.layerState.actions.getActionAt($index);								// if an action was found, create a copy of it and populate default responses.				// default responses will only play if action has a "playDialogue" command.				if (!!$action) {					$action = $action.clone();					$action.populateDefaultResponse();				}			}			else if ($itemId != "")			{				// get an item action by id.				$action = model.layerState.itemActions.getAction($itemId);								if (!$action) {					// If no object action was found, then try pulling the item's default action.					try {						$action = gameModel.getItem( $itemId ).defaultAction;					} catch ($error:Error) {						// do nothing.					}				}								// Make a copy of the target action, or create a new action if no target has been found.				$action = (!!$action) ? $action.clone() : new Action();								// forcibly populate the action with a default item response.				$action.populateDefaultResponse("item", true);			}						// process Action			if (!!$action)			{				// if parent room has an avatar layer				if (parentRoom.hasAvatar) {					// stack a tween script into the action's script.					$action.setWalkTo(_getAvatarTweenXML(), $repeat);				}								// send the action to the controller for processing.				gameController.process($action);								// flash the contextual summary.				uiContext.execute();			}		}				/**		* Runs any action that is currently targeting the layer.		* Resets and clears all actions and action focus.		*/		private function _runAction():void		{			if (_actionFocus && _actionIndex > -1) {				callAction(_actionIndex);				clearAction();			}			_actionFocus = false;		}				/**		* Updates the context display		*/		private function _setContext():void		{			var $noun:String = (_hovering || _actionFocus) ? model.layerState.title : "";			var $verb:String = (_actionIndex >= 0 && ActionSelect.mode == ActionSelectMode.DYNAMIC) ? model.layerState.actions.getTitleAt(_actionIndex) : "";			var $item:String = "";						if (_hovering && uiCursor.itemId != "") {				// if hovering and there is currently an item cursor, then try to get a custom context.				var $action:Action = model.layerState.itemActions.getAction(uiCursor.itemId);				if (!!$action) $item = $action.title;			}						uiContext.setSummary($noun, $verb, $item);		}	//-------------------------------------------------	// Tween methods	//-------------------------------------------------				/**		* Loads a tween into the puppet's tween engine.		*/		public function tween($param:PuppetTween):void {			return _tweener.queue($param);		}				/**		* Stops the active tween.		*/		public function stopTween():void {			_tweener.stop();		}				/**		* Resumes a stopped tween.		*/		public function resumeTween():void {			_tweener.resume();		}		/**		* Skips to directly to a tween's final goal point.		*/		public function skipTween():void {			_tweener.skip();		}				/**		* Clears a tween configuration.		*/		public function clearTween():void {			_tweener.clear();		}				/**		* Moves the puppet to a target point, then updates all layering and filters relative to its new position.		*/		public function moveTo($target:Point):void {			this.position = $target;		}				/**		* Gets an XML token that will call the avatar over to the puppet's map point.		*/		private function _getAvatarTweenXML():XML {			return PuppetTween.getLayerXML(id, LayerInstanceName.AVATAR, PuppetTween.MOVE_THEN_TURN, true, false);		}			//-------------------------------------------------	// Animation	//-------------------------------------------------			/**		* Sets the puppet to the model's resting state frame label.		*/		public function setRestState( $turnView:int=-1 ):void {			this.setImageFrame( model.layerState.restState, $turnView );		}				/**		* Sets the puppet to the model's moving state frame label.		*/		public function setMoveState( $turnView:int=-1 ):void {			this.setImageFrame( model.layerState.moveState, $turnView );		}				/**		* Sets the puppet to the model's speaking state frame label.		*/		public function setSpeakState( $frame:String="", $turnView:int=-1 ):void {			this.setImageFrame( ($frame != "") ? $frame : model.layerState.speakState, $turnView );		}				/**		* Sets the puppet to the model's dialogue resting state frame label.		* * Currently not in use. ... possibly unneeded?		*/		public function setDiaRestState( $turnView:int=-1 ):void {			this.setImageFrame( model.layerState.diaRestState, $turnView );		}				/**		* Sets the puppet's image frame based on a frame label and a turn view angle.		*/		override public function setImageFrame( $frameLabel:String, $turnView:int=-1 ):void		{			// ABORT: if there is no image.			if (_image == null) return;						// update the requested label with any frame prefix assigned to the puppet.			$frameLabel = model.layerState.framePrefix + $frameLabel;						// set puppet's view angle if defined by arguments.			if ($turnView > -1) _turnView = $turnView;			_frameLabel = $frameLabel;						// reset mirroring to clear any existing flip			_image.scaleX = model.layerState.imageScaleX;						// compose the new target frame label value			var $newLabel:String = $frameLabel + _adjustTurnView(_turnView);						// Run decision tree to select a valid frame label.			if (_image.currentLabel == $newLabel) 			{				// TARGET LABEL IS ALREADY SET.				// exit process.				return;			}			else if (_frameTable.hasOwnProperty($newLabel))			{				// IMAGE HAS TARGET LABEL				// set frame and exit process.				_gotoImageFrame($newLabel);				return;			}			else if (_turnView >= 6 && _turnView <= 8)			{				// VIEW IS LEFT-FACING				// attempt setting a left-mirrored display.				// mirror image scale and select corresponding right-turn label.				_image.scaleX = -model.layerState.imageScaleX;				$newLabel = $frameLabel + _adjustTurnView(10 - _turnView);								// Attempt setting right-facing frame label.				if (_frameTable.hasOwnProperty($newLabel))				{					// set frame and exit process.					_gotoImageFrame($newLabel);					return;				}			}						// Attempt to set non-directional angle			// mirroring will be retained from previous test						if (_frameTable.hasOwnProperty($frameLabel))			{				_gotoImageFrame($frameLabel);				return;			}						// Default to phase's base-frame value or else frame-one if no value is set			_gotoImageFrame(model.layerState.frameLabel != "" ? model.layerState.frameLabel : "1");		}				/**		* Adjusts the puppet's turnView with any modifications currently applied to the layer.		* This method handles inverting turn views, which flips the use of front and back view angles.		*/		private function _adjustTurnView($view:int):int		{			if (invertTurn) {				// Turn view is inverted:				// replace front/back values with their corresponding opposite.				switch ($view) {					// front/back					case 1: return 5;					case 5: return 1;					// right quarters					case 2: return 4;					case 4: return 2;					// left quarters					case 6: return 8;					case 8: return 6;				}			}			return $view;		}				/*		override public function setImageFrame($frameLabel:String, $turnView:int=-1):void		{			// ABORT: if there is no image.			if (_image == null) return;						// set puppet's view angle if defined by arguments.			if ($turnView > -1) _turnView = $turnView;			_frameLabel = $frameLabel;						// reset mirroring to clear any existing flip			_image.scaleX = model.imageScaleX;						// compose the new target frame label value			var $newLabel:String = $frameLabel + _turnView;						// ABORT: if new label is already set.			if (_image.currentLabel == $newLabel) return;						// Attempt setting new frame label.			_image.gotoAndStop($newLabel);						// ABORT: if new label was successfully set.			if (_image.currentLabel == $newLabel) return;			// attempt a left-mirrored display			if (_turnView >= 6 && _turnView <= 8)			{				// compose the new target frame label value with the mirrored view angle				$newLabel = $frameLabel + (10 - _turnView);								// set new frame display and flip scale				_image.gotoAndStop($newLabel);				_image.scaleX = -model.imageScaleX;								// ABORT: if new label was successfully set.				if (_image.currentLabel == $newLabel) return;			}						// Attempt to set non-directional angle			// mirroring will be retained from previous test						_image.gotoAndStop($frameLabel);						// ABORT: if new label was successfully set.			if (_image.currentLabel == $frameLabel) return;						// Default to phase's base-frame value or else frame-one if no value is set			_image.gotoAndStop(model.frameLabel != "" ? model.frameLabel : 1);		}*/			//-------------------------------------------------	// Mouse-hold timer	//-------------------------------------------------				/**		* Enable mouse-hold timer for verb disc interaction mode		*/		private function _enableTimer($enable:Boolean):void		{			if ($enable && !_timerEnabled)			{				// START				ActionSelect.dynamicTimer.addEventListener(TimerEvent.TIMER_COMPLETE, this._onMouseTimeOut);				ActionSelect.dynamicTimer.reset();				ActionSelect.dynamicTimer.start();			}			else if (!$enable && _timerEnabled)			{				// STOP				ActionSelect.dynamicTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, this._onMouseTimeOut);				ActionSelect.dynamicTimer.reset();			}			_timerEnabled = $enable;		}			//-------------------------------------------------	// Event handlers	//-------------------------------------------------				/**		* Generic MouseOver		*/		override protected function _onMouseOver(evt:Event):void		{			// enable cursor hover state			// IMPORTANT: do this BEFORE setting context.			_hovering = true;			uiCursor.setTooltip(model.layerState.hoverCursor);						// update contextual display.			_setContext();						// set rollover display state, if enabled.			if (model.layerState.hoverState != "") {				setImageFrame( model.layerState.hoverState );			}		}				/**		* Generic MouseOut		*/		override protected function _onMouseOut(evt:Event):void		{			// clear any pending timer operation			_enableTimer(false);						// disable cursor hover state			// IMPORTANT: do this BEFORE setting context.			_hovering = false;			uiCursor.hover = false;						// update contextual display.			_setContext();						// clear rollover display state, if enabled.			if (model.layerState.hoverState != "") {				setImageFrame( model.layerState.frameLabel );			}		}				/**		* Generic Mouse Press		* Tests for onclick action, then proceeds to interaction model handlers.		*/		override protected function _onMouseDown($event:Event):void		{			$event.stopImmediatePropagation();			var $onclick:int = model.layerState.clickAction;			if ($onclick >= 0 && $onclick < model.layerState.actions.numActions) {				// onclick action				callAction($onclick, "", _multiClick(id));			}			else if (uiCursor.hasItemTooltip) {				// item tooltip interaction.				callAction(-1, uiCursor.itemId);			}			else if (ActionSelect.mode == ActionSelectMode.DYNAMIC) {				// disc action				_onMouseDownDynamic($event);			}			else if (ActionSelect.mode == ActionSelectMode.STATIC) {				// console action				_onMouseDownStatic($event);			}		}			//-------------------------------------------------	// Disc interaction mode	//-------------------------------------------------				/**		* MouseDown in DISC mode		*/		private function _onMouseDownDynamic($event:Event):void		{			// If puppet layer is configured for 			stage.addEventListener(MouseEvent.MOUSE_UP, this._onMouseUpDynamic);			_enableTimer(true);		}				/**		* MouseUp in DISC mode		*/		private function _onMouseUpDynamic($event:Event):void		{			stage.removeEventListener(MouseEvent.MOUSE_UP, this._onMouseUpDynamic);						if (_actionFocus)			{				// if puppet had ActionSelect focus fixed on it, attempt to run actions.				// timer was cleared by timeout.				_runAction();			}			else if (_hovering && parentRoom.hasAvatar)			{				// tween avatar over to puppet map point.				gameController.processXML( _getAvatarTweenXML() );			}						// always clear the timer on mouse up			_enableTimer(false);		}				/**		* Mouse TimeOut in DISC mode		*/		private function _onMouseTimeOut($event:Event):void		{			_actionFocus = true;			uiActionSelector.activate(this);		}			//-------------------------------------------------	// Console interaction mode	//-------------------------------------------------				private function _onMouseDownStatic(evt:Event):void		{			// call action selector						if (uiActionSelector.staticActionIndex >= 0)			{				// Has selected action.								_actionFocus = true;				uiActionSelector.activate(this);				_runAction();				clearAction(true);			}			else if (parentRoom.hasAvatar)			{				// No selected action.								// tween avatar over to puppet map point.				gameController.processXML( _getAvatarTweenXML() );			}		}				private function _onMouseUpStatic(evt:Event):void		{			// do nothing		}			}}