/*** Lassie Engine Game Player* @author Greg MacWilliam.*/package com.lassie.player.room{	import com.lassie.player.model.RoomLayer;	import com.lassie.player.events.ScrollEvent;	import flash.geom.Rectangle;	import flash.geom.Point;		final public class PlaneLayer extends RoomLayerDisplay	{		// private		private var _backdrop:Boolean = false;		private var _parallaxAxis:String = ParallaxAxis.NONE;		private var _boundingBox:Rectangle;				public function PlaneLayer($model:RoomLayer, $parent:RoomDisplay, $backdrop:Boolean=false):void		{			// IMPORTANT: set backdrop status BEFORE running super constructor.			_backdrop = $backdrop;			super($model, $parent);		}	//-------------------------------------------------	// Overrides	//-------------------------------------------------			override public function destroy():void		{			super.destroy();		}		override public function toString():String {			return "[PlaneLayer] id:"+ id;		}			//-------------------------------------------------	// Public methods	//-------------------------------------------------				override public function redraw():void		{			// Backdrop planes anchor in the upper-left corner and mask with a scrollRect.			// Foreground planes behave normally.			x = _backdrop ? 0 : model.layerState.x;			y = _backdrop ? 0 : model.layerState.y;			scrollRect = _backdrop ? new Rectangle(-model.layerState.x, -model.layerState.y, gameDisplay.displayWidth, gameDisplay.displayHeight) : null;			rotation = model.layerState.rotation;			visible = model.visible;						_setHitArea();			_setAsset();			_setImage();						mouseEnabled = false;			mouseChildren = model.layerState.mouseEnabled;			_parallaxAxis = model.layerState.parallaxAxis;						// apply scroll listeners based on backdrop status			if (_backdrop) parentRoom.background.addEventListener(ScrollEvent.SCROLL, this._onBackdropScroll);			else parentRoom.background.addEventListener(ScrollEvent.SCROLL, this._onForegroundScroll);		}				override protected function _setHitArea():void		{			// set bounding box based on hit area properties.			_boundingBox = (model.layerState.hitEnabled) ? new Rectangle(model.layerState.hitX, model.layerState.hitY, model.layerState.hitWidth, model.layerState.hitHeight) : null;		}			//-------------------------------------------------	// Public properties	//-------------------------------------------------				/**		* Gets the plane's bounding box within the parent coordinate space.		*/		private function _getBounding():Rectangle		{			// Use custom bounding (hit area) if enabled			if (_boundingBox != null)			{				var $rect:Rectangle = _boundingBox.clone();				$rect.x += x;				$rect.y += y;				return $rect;			}			// Otherwise, use graphical bounds.			return getRect(parent);		}			//-------------------------------------------------	// Event handlers	//-------------------------------------------------			/**		* Scroll handler for backdrop planes.		*/		private function _onBackdropScroll($event:ScrollEvent):void		{			// get the plane's bounding box within parent coordinate space.			var $rect:Rectangle = _getBounding();			// get the offset between the upperLeft bounding and the registration point.			var $offset:Point = position.add($rect.topLeft);			// get the default scroll rect and offset it by the plane's registration point.			var $viewport:Rectangle = $event.scrollRect;			$viewport.offset($offset.x, $offset.y);						// X-axis shift			if ($event.rangeX > 0 && (_parallaxAxis == ParallaxAxis.X || _parallaxAxis == ParallaxAxis.X_AND_Y))			{				var $rangeX:int = $rect.width - $event.viewWidth;				$viewport.x = Math.floor(($rangeX * $event.percentX) + $offset.x);			}						// Y-axis shift			if ($event.rangeY > 0 && (_parallaxAxis == ParallaxAxis.Y || _parallaxAxis == ParallaxAxis.X_AND_Y))			{				var $rangeY:int = $rect.height - $event.viewHeight;				$viewport.y = Math.floor(($rangeY * $event.percentY) + $offset.y);			}						scrollRect = $viewport;		}				/**		* Scroll handler for planes within the foreground float stack.		*/		private function _onForegroundScroll($event:ScrollEvent):void		{			// get the plane's bounding box within parent coordinate space			var $rect:Rectangle = _getBounding();			// get the offset between the upperLeft bounding and the registration point			var $offset:Point = position.subtract($rect.topLeft);			// create holder for calculating scroll range			var $range:int;			// X-axis shift			if ($event.rangeX > 0 && (_parallaxAxis == ParallaxAxis.X || _parallaxAxis == ParallaxAxis.X_AND_Y))			{				$range = $event.totalWidth - $rect.width;				x = Math.floor(($range * $event.percentX) + $offset.x);			}						// Y-axis shift			if ($event.rangeY > 0 && (_parallaxAxis == ParallaxAxis.Y || _parallaxAxis == ParallaxAxis.X_AND_Y))			{				$range = $event.totalWidth - $rect.height;				y = Math.floor(($range * $event.percentY) + $offset.y);			}		}			}}