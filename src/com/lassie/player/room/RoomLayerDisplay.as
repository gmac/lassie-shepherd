/*** Lassie Engine Game Player* @author Greg MacWilliam.*/package com.lassie.player.room{	import com.lassie.player.core.IRoomLayerDisplay;	import com.lassie.player.model.RoomLayer;	import com.lassie.player.events.ModelEvent;	import com.lassie.player.events.RoomEvent;	import com.lassie.utils.DisplayUtil;	import flash.display.FrameLabel;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.Point;	internal class RoomLayerDisplay extends RoomObject implements IRoomLayerDisplay	{		// public		// important: this must be public so that the FloatContainer can access it.		public var layeringScore:int = 0;		// protected		protected var _hitArea:Sprite;		protected var _image:MovieClip;		protected var _imageAsset:String = "";		protected var _frameLabel:String = "";		protected var _frameTable:Object;		protected var _turnView:int = 0;		protected var _floatEnabled:Boolean = false;		// private		private var _model:RoomLayer;		private var _floatBehind:String = "";		private var _frameOffset:int = 0;		private var _invertTurn:Boolean = false;	//-------------------------------------------------	// Object methods	//-------------------------------------------------		public function RoomLayerDisplay($model:RoomLayer, $parent:RoomDisplay):void		{			super($parent);			_model = $model;			_frameTable = new Object();			_hitArea = new Sprite();			mouseChildren = false;			//configure event listeners			addEventListener(MouseEvent.CLICK, this._onMouseClick);			addEventListener(MouseEvent.MOUSE_DOWN, this._onMouseDown);			addEventListener(MouseEvent.MOUSE_OVER, this._onMouseOver);			addEventListener(MouseEvent.MOUSE_OUT, this._onMouseOut);			_model.addEventListener(ModelEvent.UPDATE_DISPLAY, this._onRefresh);		}		override public function destroy():void		{			super.destroy();			// clear event handlers			removeEventListener(MouseEvent.CLICK, this._onMouseClick);			removeEventListener(MouseEvent.MOUSE_DOWN, this._onMouseDown);			removeEventListener(MouseEvent.MOUSE_OVER, this._onMouseOver);			removeEventListener(MouseEvent.MOUSE_OUT, this._onMouseOut);			_model.removeEventListener(ModelEvent.UPDATE_DISPLAY, this._onRefresh);			// clear display			while (numChildren > 0) removeChildAt(0);			// stop all image animations			if (_image != null) {				_image.cacheAsBitmap = false;				DisplayUtil.stopAllClips(_image);			}			// nullify object references			_model = null;			_image = null;			_hitArea = null;		}		override public function toString():String {			return "[RoomLayerDisplay] id:"+ id +", type:"+ type;		}		override protected function _finit():void {			redraw();		}	//-------------------------------------------------	// Factory	//-------------------------------------------------		static public function create($model:RoomLayer, $parent:RoomDisplay):RoomLayerDisplay		{			switch($model.type)			{				case LayerType.PUPPET:				return new PuppetLayer($model, $parent);				case LayerType.PLANE:				return new PlaneLayer($model, $parent);				case LayerType.BACKGROUND:				return new BackgroundLayer($model, $parent);				case LayerType.AVATAR:				return new AvatarLayer($model, $parent);				default:				return new RoomLayerDisplay($model, $parent);			}			return null;		}	//-------------------------------------------------	// Read-only properties	//-------------------------------------------------		public function get model():RoomLayer {			return _model;		}		public function get id():String {			return model.id;		}		public function get type():String {			return model.type;		}		public function get image():MovieClip {			return _image;		}		public function get nativeDepth():int {			return _model.depth;		}		public function get floatEnabled():Boolean {			return _floatEnabled;		}		public function get turnView():int {			return _turnView;		}	//-------------------------------------------------	// Get/set properties	//-------------------------------------------------		/**		* Specifies the layer's X and Y coordinates using a Point object.		*/		public function get position():Point {			return new Point(x, y);		}		public function set position($pt:Point):void {			x = $pt.x;			y = $pt.y;		}		/**		* Specifies a custom layer Id that this layer should float behind.		*/		public function get floatBehind():String {			return _floatBehind;		}		public function set floatBehind($id:String):void		{			// locally store previous source value, then update.			var $prev:String = _floatBehind;			_floatBehind = (!!$id) ? $id : "";			// if the new value is different than the old value,			// call for the layering stack to update.			if ($prev != _floatBehind) _updateLayering();		}		/**		* Specifies a number of frames to offset the image's timeline by whenever seeking a new frame.		*/		public function get frameOffset():int {			return _frameOffset;		}		public function set frameOffset($offset:int):void {			_frameOffset = $offset;			setImageFrame(_frameLabel);		}		/**		* Specifies if the layer's front-to-back turn view displays should be inverted.		*/		public function get invertTurn():Boolean {			return _invertTurn;		}		public function set invertTurn($invert:Boolean):void {			_invertTurn = $invert;			setImageFrame(_frameLabel);		}	//-------------------------------------------------	// Basic display methods	//-------------------------------------------------		/**		* Draws the layer display.		*/		public function redraw():void		{			visible = model.visible;			x = model.layerState.x;			y = model.layerState.y;			rotation = model.layerState.rotation;			_setHitArea();			_setAsset();			_setImage();		}		/**		* Configures the hitArea shape.		*/		protected function _setHitArea():void		{			// enabled / disable display			if (model.layerState.hitEnabled && !this.contains(_hitArea)) addChildAt(_hitArea, 0);			else if (!model.layerState.hitEnabled && this.contains(_hitArea)) removeChild(_hitArea);			// set hitArea reference property			hitArea = model.layerState.hitEnabled ? _hitArea : null;			// set position and draw shape			_hitArea.x = model.layerState.hitX;			_hitArea.y = model.layerState.hitY;			_hitArea.visible = false;			_hitArea.graphics.clear();			_hitArea.graphics.beginFill(0x000000, 0.5);			// draw hit area shape			if (model.layerState.hitShape == HitAreaShape.ELLIPSE) {				_hitArea.graphics.drawEllipse(0, 0, model.layerState.hitWidth, model.layerState.hitHeight);			} else {				_hitArea.graphics.drawRect(0, 0, model.layerState.hitWidth, model.layerState.hitHeight);			}			_hitArea.graphics.endFill();		}		/**		* Configures the image asset.		*/		protected function _setAsset():void		{			// if image asset is not already set			if (_imageAsset != model.asset)			{				if (!!_image) {					// destroy any existing image asset					DisplayUtil.stopAllClips(_image);					_frameTable = new Object();					_image = null;				}				// get the new image asset				_image = gameLibrary.getMovieClipByAddress(model.asset);				if (!!_image)				{					// if image asset was successfully found,					// create a table of all frameLabel values.					var $labels:Array = _image.currentLabels;					// assign each frame index to the table using it's label as a key.					for each (var $label:FrameLabel in $labels) {						_frameTable[ $label.name ] = $label.frame;					}				}			}			// set reference to new image asset			_imageAsset = model.asset;		}		/**		* Configures the image display.		*/		protected function _setImage():void		{			if (!!_image)			{				// enabled / disable display				if (model.layerState.imageEnabled && !this.contains(_image)) addChild(_image);				else if (!model.layerState.imageEnabled && this.contains(_image)) removeChild(_image);				// set position and appearance				_image.x = model.layerState.imageX;				_image.y = model.layerState.imageY;				_image.scaleX = model.layerState.imageScaleX;				_image.scaleY = model.layerState.imageScaleY;				_image.alpha = model.layerState.alpha;				_image.blendMode = model.layerState.blendMode;				_image.cacheAsBitmap = model.layerState.cacheAsBitmap;				if (_image.cacheAsBitmap) DisplayUtil.stopAllClips(_image);				setImageFrame(model.layerState.frameLabel, model.layerState.turnView);			}			// [performance]: update display properties locally on object			_floatEnabled = _model.layerState.floatEnabled;		}		/**		* Dispatches a bubbling FLOAT event.		* If layer exists within the FloatContainer,		* then event will be caught and layers will be restacked.		*/		protected function _updateLayering():void {			if (floatEnabled || floatBehind != "") {				// only call for restacking if float is enabled,				// or if layer has a manual float-behind specification.				dispatchEvent(new RoomEvent(RoomEvent.RESTACK_LAYERS, true));			}		}		/**		* Sets the image frame to an angle-specific view frame		* @param $frameName: base frame label name.		* @param $viewAngle: view angle (1-8) to append to frame label.		*/		public function setImageFrame($frameLabel:String, $turnView:int=-1):void		{			// Override this method in sub-classes for more advanced frame-setting logic.			_gotoImageFrame($frameLabel);			_frameLabel = $frameLabel;			_turnView = $turnView;		}		/**		* Sets the image asset's frame, then modifies the frame number by any additional offset value.		*/		protected function _gotoImageFrame($frame:String):void		{			if (!!_image) {				// attempt to parse the frame number directly.				var $frameNum:Number = parseInt($frame);				// if numeric parse did not work, attempt to pull the frame number from the label table.				// default missing values with frame-1.				if (isNaN($frameNum)) {					$frameNum = _frameTable.hasOwnProperty($frame) ? _frameTable[$frame] : 1;				}				// if a valid frame number was resolved, set the frame along with the frame offset.				if (!isNaN($frameNum)) {					_image.gotoAndStop( $frameNum + _frameOffset );				}			}		}		/**		* Commits current display settings to the layer model.		* (disables layer redrawing while setting current properties)		*/		public function cacheDisplay():void		{			model.redrawEnabled = false;			model.layerState.x = x;			model.layerState.y = y;			model.layerState.turnView = _turnView;			model.layerState.frameLabel = _frameLabel;			model.redrawEnabled = true;		}	//-------------------------------------------------	// Event handlers	//-------------------------------------------------		protected function _onMouseClick($event:Event):void {			// override in sub-class.		}		protected function _onMouseDown($event:Event):void {			// override in sub-class.		}		protected function _onMouseOver($event:Event):void {			// override in sub-class.		}		protected function _onMouseOut($event:Event):void {			// override in sub-class.		}		protected function _onRefresh($event:Event):void {			redraw();		}	}}