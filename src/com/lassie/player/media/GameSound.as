/*** Lassie Engine Game Player* @author Greg MacWilliam.*/package com.lassie.player.media{	import com.gmac.sound.*;	import com.lassie.player.core.LPDispatcher;	import com.lassie.player.core.IGameSound;	import com.lassie.player.events.ModelEvent;	import flash.events.EventDispatcher;	import flash.events.Event;	import flash.media.Sound;		public class GameSound extends LPDispatcher implements IGameSound	{		// duration of audio crossfades.		private const TRANSITION_SECONDS:Number = 1.5;				private var _soundChannel1:Crossfader;		private var _soundChannel2:Crossfader;		private var _voiceControl:SoundGroupControl;		private var _soundfxControl:SoundGroupControl;		private var _sound1:String = "";		private var _sound2:String = "";		private var _playing:Boolean = false;				/**		* Creates a singleton instance of the GameSound component.		*/		public function GameSound($enforcer:GameSoundEnforcer):void		{			super();						// create channel1 crossfader.			_soundChannel1 = new Crossfader();			_soundChannel1.garbageCollectionMode = true;			_soundChannel1.transitionSeconds = TRANSITION_SECONDS;						// create channel2 crossfader.			_soundChannel2 = new Crossfader();			_soundChannel2.garbageCollectionMode = true;			_soundChannel2.transitionSeconds = TRANSITION_SECONDS;						// create voice group control.			_voiceControl = new SoundGroupControl();			_voiceControl.garbageCollectionMode = true;						// create soundfx group control.			_soundfxControl = new SoundGroupControl();			_soundfxControl.garbageCollectionMode = true;		}				/** @private Singleton instance reference */		static private var _instance:GameSound;				/**		* Gets the singleton instance reference.		*/		static public function getInstance():GameSound {			if (_instance == null) _instance = new GameSound(new GameSoundEnforcer());			return _instance;		}	// --------------------------------------------------	//  Component controls	// --------------------------------------------------			/**		* Destroys the sound controller component.		*/		public function destroy():void		{			// unsubscribe listeners to the model for capturing changed to volume.			gameModel.removeEventListener(ModelEvent.CHANGE_VOLUME, this._onVolumeChange);						// destroy all dependents			_soundChannel1.destroy();			_soundChannel2.destroy();			_voiceControl.destroy();			_soundfxControl.destroy();		}				/**		* Loads the component configuration.		*/		public function load():void		{			// subscribe listeners to the model for capturing changed to volume.			gameModel.addEventListener(ModelEvent.CHANGE_VOLUME, this._onVolumeChange);						// Set initial volume settings:			_onVolumeChange();						// set all sound containers to play.			play();		}				/**		* Plays all sounds within the sound controller.		*/		public function play():void {			_soundChannel1.play();			_soundChannel2.play();			_voiceControl.play();			_soundfxControl.play();			_playing = true;		}				/**		* Stops all sounds within the sound controller.		*/		public function stop():void {			_soundChannel1.stop();			_soundChannel2.stop();			_voiceControl.stop();			_soundfxControl.stop();			_playing = false;		}				/**		* Toggles current sound playback state.		*/		public function toggle():void {			_playing ? stop() : play();		}			// --------------------------------------------------	//  Soundtrack controls	// --------------------------------------------------			/**		* Specifies the library path of the current sound playing in channel-1.		*/		public function get channel1():String {			return _sound1;		}		public function set channel1($libPath:String):void		{			if (_sound1 != $libPath)			{				var $sound:Sound = gameLibrary.getSoundByAddress($libPath);								if ($sound != null) {					_sound1 = $libPath;					_soundChannel1.addRawSound($sound, 0);				}				else {					_sound1 = "";					_soundChannel1.fadeOut();				}			}		}				/**		* Specifies the library path of the current sound playing in channel-2.		*/		public function get channel2():String {			return _sound2;		}		public function set channel2($libPath:String):void		{			if (_sound2 != $libPath)			{				var $sound:Sound = gameLibrary.getSoundByAddress($libPath);								if ($sound != null) {					_sound2 = $libPath;					_soundChannel2.addRawSound($sound, 0);				}				else {					_sound2 = "";					_soundChannel2.fadeOut();				}			}		}			// --------------------------------------------------	//  Voice controls	// --------------------------------------------------			/**		* Plays a voice sound.		* @param libPath  The library path of the sound to play.		* @return  Returns a reference to the sound as a simple EventDispatcher.		* External objects can listen to the returned EventDispatcher for a COMPLETE event.		*/		public function playVoice($libPath:String):ISoundObject		{			// pull raw sound from the library			var $rawSound:Sound = gameLibrary.getSoundByAddress($libPath);						// if sound is valid			if (!!$rawSound)			{				// create child sound and play it within the voice group.				var $sound:SoundChild = new SoundChild($rawSound);				$sound.addEventListener(SoundObjectEvent.SOUND_COMPLETE, this._onSoundComplete);				_voiceControl.addChild($sound);				return $sound;			}			return null;		}			// --------------------------------------------------	//  SoundFX controls	// --------------------------------------------------			/**		* Plays a sound effect.		* @param libPath  The library path of the sound to play.		* @return  Returns a reference to the sound as a simple EventDispatcher.		* External objects can listen to the returned EventDispatcher for a COMPLETE event.		*/		public function playSound($libPath:String):ISoundObject		{			// pull raw sound from the library			var $rawSound:Sound = gameLibrary.getSoundByAddress($libPath);						// if sound is valid			if (!!$rawSound)			{				// create child sound and play it within the soundfx group.				var $sound:SoundChild = new SoundChild($rawSound);				$sound.addEventListener(SoundObjectEvent.SOUND_COMPLETE, this._onSoundComplete);				_soundfxControl.addChild($sound);				return $sound;			}			return null;		}			// --------------------------------------------------	//  Event handlers	// --------------------------------------------------			/**		* @private		* Called upon completion of any voice or soundfx.		* Sound is cleaned up and dispatches COMPLETE notification.		*/		private function _onSoundComplete($event:Event):void		{			var $sound:SoundChild = $event.target as SoundChild;			$sound.removeEventListener(SoundObjectEvent.SOUND_COMPLETE, this._onSoundComplete);			$sound.dispatchEvent(new Event(Event.COMPLETE));			$sound.parent.removeChild($sound);			$sound.destroy();		}				/**		* @private		* Called in response to volume settings being changed within the model.		*/		private function _onVolumeChange($event:Event=null):void		{			_soundChannel1.volume = gameModel.soundtrackVolume;			_soundChannel2.volume = gameModel.soundtrackVolume;			_voiceControl.volume = gameModel.voiceVolume;			_soundfxControl.volume = gameModel.soundfxVolume;			//trace(_soundChannel1.volume, _voiceControl.volume, _soundfxControl.volume);		}	}}/*** @private* Local class required for Singleton instantiation.*/internal final class GameSoundEnforcer {}