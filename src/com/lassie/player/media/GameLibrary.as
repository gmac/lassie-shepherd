/*** Lassie Engine Game Player* @author Greg MacWilliam.*/package com.lassie.player.media{	import flash.events.Event;	import flash.events.ProgressEvent;	import flash.events.IOErrorEvent;	import flash.display.MovieClip;	import flash.system.LoaderContext;	import flash.system.ApplicationDomain;	import flash.system.SecurityDomain;	import flash.media.Sound;	import com.lassie.lib.ILibrary;	import com.lassie.player.core.IGameLibrary;	import com.lassie.player.core.LPDispatcher;	import com.lassie.player.events.LibraryEvent;	import com.stimuli.loading.BulkLoader;	import com.stimuli.loading.BulkErrorEvent;	/**	*  Dispatched on download progress of a batch load.	*  @event: com.lassie.lib.LibraryEvent.PROGRESS	*/	[Event(name="progress", type="com.lassie.player.events.LibraryEvent")]		/**	* Dispatched when all loads have been resolved and parsed.	* @event: com.lassie.lib.LibraryEvent.COMPLETE	*/	[Event(name="complete", type="com.lassie.player.events.LibraryEvent")]		final public class GameLibrary extends LPDispatcher implements IGameLibrary	{		static public var baseURL:String = "";				// private constants		private const EXCLUDE_NONE:String = "";		private const EXCLUDE_REDUNDANT:String = "redundant";		private const EXCLUDE_MISSING:String = "missing";				// private		private var _loadCount:int = 0;		private var _libCache:Object = new Object();		private var _swfCache:Object = new Object();		private var _relTable:Object = new Object();		private var _pending:Object = new Object();			// --------------------------------------------------	//  Instance management	// --------------------------------------------------			/** @private singleton constructor */		public function GameLibrary($enforcer:LibraryEnforcer):void {			super();		}				/** @private singleton instance holder */		static private var _instance:GameLibrary;				/** singleton instance getter */		static public function getInstance():GameLibrary {			if (_instance == null) _instance = new GameLibrary(new LibraryEnforcer());			return _instance;		}			// --------------------------------------------------	//  ILibrary methods	// --------------------------------------------------				/**		* Creates a unique name for a new load operation		* @return: unique name		*/		public function getUniqueLoaderName():String		{			_loadCount++;			return "load" + _loadCount;		}				/**		* Loads a list of library SWFs		* @param: reference name for load operation		* @param: files to load formatted as comma seperated values		* @param: automatically start operation after loader configuration		* @return: true / false concerning if a load operation was configured		*/		public function load($loadName:String, $csv:String):void		{			var $list:Array = _parseFilesList($csv, EXCLUDE_REDUNDANT);						if ($list.length > 0)			{				var $bulk:BulkLoader = new BulkLoader($loadName);				$bulk.addEventListener(BulkLoader.COMPLETE, this._onLoadComplete);				$bulk.addEventListener(BulkLoader.PROGRESS, this._onLoadProgress);				$bulk.addEventListener(BulkLoader.ERROR, this._onLoadError);				// add each URL to load.				for each (var $id:String in $list)				{					var $params:Object = new Object();										if (GameLibrary.baseURL != "") {						// build a LoaderContext params object for each request when loading across domains.						$params[ BulkLoader.CONTEXT ] = new LoaderContext(true, null, SecurityDomain.currentDomain);					}									_pending[ $id ] = true;					$bulk.add( GameLibrary.baseURL + $id, $params );				}								$bulk.start();			}			else			{				_complete($loadName);			}		}				/**		* Purges all library contents not present in load request, then loads requested files.		* @param: reference name for load operation		* @param: files to load formatted as comma seperated values		* @param: automatically start operation after loader configuration		* @return: true / false concerning if a load operation was configured		*/		public function purgeAndLoad($loadName:String, $csv:String):void		{			var $load:Array = _parseFilesList($csv, EXCLUDE_NONE);			var $contents:Array = getLibrariesList();			var $purge:Array = new Array();						for each (var j:String in $contents)			{				// add contents item to purge queue if it is not part of the new load request.				if ($load.indexOf(j) < 0) $purge.push(j);			}						unload($purge.join(","));			load($loadName, $load.join(","));		}				/**		* Purges a list of library SWFs		* @param: files to purge formatted as comma seperated values		*/		public function unload($csv:String):void		{			var $list:Array = _parseFilesList($csv, EXCLUDE_MISSING);						// loop through each item to unload.			for each (var $j:String in $list)			{				if (_relTable.hasOwnProperty($j))				{					// get reference to item's cache through the relationship table.					var $cache:Object = _relTable[$j];										// delete item from the source table and from the relationship table.					delete $cache[$j];					delete _relTable[$j];				}			}		}				/**		* Registers a dynamic-typed event specific to one loader		*/		public function addLoadListener($loaderName:String, $event:String, $handler:Function):void {			addEventListener(_parseEventType($loaderName, $event), $handler);		}				/**		* Removes a dynamic-typed event		*/		public function removeLoadListener($loaderName:String, $event:String, $handler:Function):void {			removeEventListener(_parseEventType($loaderName, $event), $handler);		}				/**		* Checks if a library SWF is present within the directory		* @param: file to check for		* @param: include pending queue in check		* @return: file found boolean		*/		public function hasLibrary($libKey:String, $checkPending:Boolean=false):Boolean {			return $checkPending ? (_libCache[$libKey] != undefined || _pending[$libKey] != undefined) : (_libCache[$libKey] != undefined);		}				/**		* Checks if all libraries in a comma seperated list are present		* @param: files to check for formatted as comma seperated values		* @return: true if all libraries are present		*/		public function hasAllLibraries($csv:String):Boolean		{			var list:Array = _parseFilesList($csv, EXCLUDE_NONE);						for each (var j:String in list)			{				if (!hasLibrary(j)) return false;			}			return true;		}				/**		* Creates a list of all library files in directory		* @return: array of file keys		*/		public function getLibrariesList():Array		{			var $list:Array = new Array();			for (var $j:String in _libCache) $list.push($j);			$list.sort();			return $list;		}				/**		* Gets a library by key		* @param: library name		* @return: media library interface		*/		public function getLibraryById($libKey:String):ILibrary		{			if (hasLibrary($libKey))			{				return _libCache[$libKey] as ILibrary;			}			return null;		}				/**		* Returns a list of all classes contained within the specified library file		* @return: array of class names		*/		// MovieClips		public function getMovieClipContents($libKey:String):Array		{			try {				return ILibrary(_libCache[$libKey]).movieClipContents;			}			catch ($e:Error) {				trace("[LibraryManager] getLibraryMovieClips(), contents could not be acquired.");			}			return null;		}				// Sounds		public function getSoundContents($libKey:String):Array		{			try {				return ILibrary(_libCache[$libKey]).soundContents;			}			catch ($e:Error) {				trace("[LibraryManager] getLibrarySounds(), contents could not be acquired.");			}			return null;		}				// XML		public function getXMLContents($libKey:String):Array		{			try {				return ILibrary(_libCache[$libKey]).xmlContents;			}			catch ($e:Error) {				trace("[LibraryManager] getLibraryXML(), contents could not be acquired.");			}			return null;		}				/**		* Retrieves a class asset from the specified library		* @param: library file directory key		* @param: library class name		* @return: instance of the target class		*/		// MovieClip		public function getMovieClip($libKey:String, $class:String):MovieClip		{			try {				return ILibrary(_libCache[$libKey]).getMovieClip($class);			}			catch($e:Error) {				trace("[LibraryManager] getMovieClip(), \"" + $libKey +":"+ $class + "\" could not be acquired.");			}			return null;		}				// Sound		public function getSound($libKey:String, $class:String):Sound		{			try {				return ILibrary(_libCache[$libKey]).getSound($class);			}			catch($e:Error) {				trace("[LibraryManager] getSound(), \"" + $libKey +":"+ $class + "\" could not be acquired.");			}			return null;		}				// XML		public function getXML($libKey:String, $id:String):XML		{			try {				return ILibrary(_libCache[$libKey]).getXML($id);			}			catch($e:Error) {				trace("[LibraryManager] getXML(), \"" + $libKey +":"+ $id + "\" could not be acquired.");			}			return null;		}				// Flash Movie (full SWF)		public function getSWF($id:String):MovieClip		{			if (_swfCache.hasOwnProperty($id)) {				return _swfCache[$id] as MovieClip;			}			else {				trace("[LibraryManager] getSWF(), \"" + $id + "\" could not be acquired.");			}			return null;		}				/**		* Retrieves a class asset from the specified library		* @param: library file directory key		* @param: library class name		* @return: instance of the target class		*/		public function getMovieClipByAddress($address:String):MovieClip		{			var $list:Array = _parseAddress($address);						if ($list.length == 2 && hasLibrary($list[0]))			{				try {					return getMovieClip($list[0], $list[1]);				}				catch($e:Error) {					trace("[LibraryManager] getMovieClipByAddress(), \"" + $address + "\" could not be acquired.");				}			}			return null;		}				public function getSoundByAddress($address:String):Sound		{			var $list:Array = _parseAddress($address);						if ($list.length == 2 && hasLibrary($list[0]))			{				try {					return getSound($list[0], $list[1]);				}				catch($e:Error) {					trace("[LibraryManager] getSoundByAddress(), \"" + $address + "\" could not be acquired.");				}			}			return null;		}				public function getXMLByAddress($address:String):XML		{			var $list:Array = _parseAddress($address);						if ($list.length == 2 && hasLibrary($list[0]))			{				try {					return getXML($list[0], $list[1]);				}				catch($e:Error) {					trace("[LibraryManager] getXMLByAddress(), \"" + $address + "\" could not be acquired.");				}			}			return null;		}			// --------------------------------------------------	//  Private methods	// --------------------------------------------------					/**		* Splits a library address into identifier fields		* @param $address: library file address		* @return Array: a list of address IDs		*/		private function _parseAddress($address:String):Array		{			$address = $address.split(" ").join("");			return $address.split(":");		}		/**		* Parses a comma-seperated list of files into a filtered array.		* @param $csv: comma seperated list of file names.		* @param $filter: a filter method for excluding redundacies (uses const exclusion values)		* @return Array: parsed list of file names		*/		private function _parseFilesList($csv:String, $filter:String=EXCLUDE_NONE):Array		{			$csv = $csv.split(" ").join("");			var $all:Array = $csv.split(",");			var $keep:Array = new Array();						for each (var $j:String in $all)			{				// restrict to swf files that are not already logged				if ($j.substr(-4) == ".swf" && $keep.indexOf($j) < 0)				{					var $hasLib:Boolean = hasLibrary($j, true);										if (($filter == EXCLUDE_REDUNDANT && !$hasLib) || ($filter == EXCLUDE_MISSING && $hasLib) || $filter == EXCLUDE_NONE)					{						$keep.push($j);					}				}			}						return $keep;		}			/**		* Parses an event type by combining event name with specific loader name.		* @param $loaderName: the name of the loader that the event concerns.		* @param $event: the constant event type		* @return String: the parsed event type		*/		private function _parseEventType($loaderName:String, $event:String):String {			return $loaderName + "_" + $event;		}				/**		* Calls a completion event for a specific loader.		* @param $loaderName: the name of the loader that has completed.		*/		private function _complete($loadName:String):void {			dispatchEvent(new LibraryEvent(_parseEventType($loadName, LibraryEvent.COMPLETE), $loadName, 1));		}			// --------------------------------------------------	//  Event handlers	// --------------------------------------------------				/** @private called upon completion of a load */		private function _onLoadComplete($event:Event):void		{			var $bulk:BulkLoader = BulkLoader($event.target);						// copy all valid media libraries from bulk loader into directory			for (var $j:String in $bulk.contents)			{				var $id:String = $j.replace(GameLibrary.baseURL, "");				if ($bulk.contents[$j] is ILibrary) {					_libCache[$id] = $bulk.contents[$j];					_relTable[$id] = _libCache;				}				else if ($bulk.contents[$j] is MovieClip) {					_swfCache[$id] = $bulk.contents[$j];					_relTable[$id] = _swfCache;				}				else {					trace("[LibraryManager] _onLoadComplete: unknown library format encountered.");				}				// clear the media references in the loads-pending queue				delete _pending[$id];			}			// clean up BulkLoader instance			var $name = $bulk.name;			$bulk.removeEventListener(BulkLoader.COMPLETE, this._onLoadComplete);			$bulk.removeEventListener(BulkLoader.PROGRESS, this._onLoadProgress);			$bulk.removeEventListener(BulkLoader.ERROR, this._onLoadError);			$bulk.removeAll();			$bulk.clear();						_complete($name);		}				/** @private called upon a load progress update */		private function _onLoadProgress($event:Event):void		{			var $bulk:BulkLoader = BulkLoader($event.target);			//dispatchEvent(new LibraryEvent(_parseEventType($bulk.name, LibraryEvent.PROGRESS), $bulk.name, $bulk.percentLoaded));			root.dispatchEvent(new ProgressEvent(ProgressEvent.PROGRESS, false, false, $bulk.bytesLoaded, $bulk.bytesTotal));		}				/** @private called upon encountering a load error */		private function _onLoadError($event:BulkErrorEvent):void {			root.dispatchEvent(new IOErrorEvent(IOErrorEvent.IO_ERROR, false, false, "Library load error. " + $event.errors));			trace("[LibraryManager] Load error. " + $event.errors);		}	}}/** @private singleton class enforcer */final internal class LibraryEnforcer {}