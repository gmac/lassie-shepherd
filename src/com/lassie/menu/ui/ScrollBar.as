package com.lassie.menu.ui{	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.utils.Timer;	import flash.geom.Rectangle;		internal class ScrollBar extends UIComponent	{		// display components		private var _well:Sprite;		private var _bar:UIRect;		private var _up:ScrollArrow;		private var _down:ScrollArrow;				// formatting and controls		private var _contentRatio:Number = 1;		private var _constraint:Rectangle;		private var _scrollTrend:int = 1;		private var _timer:Timer;				public function ScrollBar( $style:UIStyle ):void		{			super();						_timer = new Timer(150, 0);			_timer.addEventListener(TimerEvent.TIMER, this._onArrowHold, false, 0, true);						_well = new Sprite;			_well.addEventListener(MouseEvent.MOUSE_DOWN, this._onWellPress, false, 0, true);			addChild(_well);						_bar = new UIRect( $style.scrollBarColor );			_bar.buttonMode = true;			_bar.useHandCursor = true;			_bar.addEventListener(MouseEvent.MOUSE_DOWN, this._onBarPress, false, 0, true);			_bar.mouseEnabled = _bar.mouseChildren = $style.scrollDragEnabled;			addChild(_bar);						_up = new ScrollArrow($style);			_up.addEventListener(MouseEvent.MOUSE_DOWN, this._onArrowPress, false, 0, true);			addChild(_up);						_down = new ScrollArrow($style);			_down.addEventListener(MouseEvent.MOUSE_DOWN, this._onArrowPress, false, 0, true);			addChild(_down);						style = $style;		}				/**		* Destroys the scroll bar to optimize for garbage collection.		*/		override public function destroy():void		{			super.destroy();			while (numChildren > 0) removeChildAt(0);			_timer.removeEventListener(TimerEvent.TIMER, this._onArrowHold);			_well.removeEventListener(MouseEvent.MOUSE_DOWN, this._onWellPress);			_bar.removeEventListener(MouseEvent.MOUSE_DOWN, this._onBarPress);			_up.removeEventListener(MouseEvent.MOUSE_DOWN, this._onArrowPress);			_down.removeEventListener(MouseEvent.MOUSE_DOWN, this._onArrowPress);			_timer.stop();			_up.destroy();			_down.destroy();			_timer = null;			_well = null;			_bar = null;			_up = null;			_down = null;		}			// --------------------------------------------------	// External interface	// --------------------------------------------------			/**		* Overrides the default height getter/setter to proportionally scale the scroll bar.		*/		override public function get width():Number {			return style.scrollWidth;		}		override public function set width($w:Number):void {			style.scrollWidth = $w;			super.width = $w;		}				/**		* Specifies the visual style formatting applied to the scroll bar.		*/		override public function set style($style:UIStyle):void {			_up.style = $style;			_down.style = $style;			super.style = $style;		}				/**		* Provides a reference to the scroll bar display component.		*/		public function get scrollButton():UIRect {			return _bar;		}		public function set scrollButton($rect:UIRect):void		{			if (!!$rect) {				$rect.x = _bar.x;				$rect.y = _bar.y;				$rect.buttonMode = _bar.buttonMode;				$rect.useHandCursor = _bar.useHandCursor;				$rect.redraw(_bar.width, _bar.height);				$rect.addEventListener(MouseEvent.MOUSE_DOWN, this._onBarPress, false, 0, true);				_bar.removeEventListener(MouseEvent.MOUSE_DOWN, this._onBarPress);								removeChild(_bar);				addChild($rect);				_bar = $rect;			}		}				/**		* Specifies the percentage of area scrolled based on the current scroll bar position.		*/		public function get scroll():Number {			return (_bar.y - _constraint.y) / _constraint.height;		}		public function set scroll($percent:Number):void		{			if (!isNaN($percent) && $percent <= 1) {				_bar.y = _constraint.y + Math.round(_constraint.height * $percent);				visible = style.scrollEnabled;			}			else {				visible = false;			}		}				/**		* Configures the scrollbar to reflect new content height.		*/		internal function configure($frameHeight:Number, $contentHeight:Number, $contentY:Number=0):void		{			if ($contentHeight > $frameHeight)			{				// content is taller than scrollbar:				// configure and display scroll.				_contentRatio = ($frameHeight / $contentHeight);				_redraw();				scroll = Math.abs($contentY) / ($contentHeight - $frameHeight);				visible = style.scrollEnabled;			}			else			{				// content is shorter than scrollbar:				// hide scrollbar.				visible = false;			}		}			// --------------------------------------------------	// Private methods	// --------------------------------------------------				/** @private Sets the scroll bar position, while locking it within the constraint. */		private function _scrollTo($y:int):void {			_bar.y = Math.max(_constraint.top, Math.min($y, _constraint.bottom));			update();		}				/** @private Bumps the scrollbar based on the current trend. */		private function _bump():void {			_scrollTo(_bar.y + (_scrollTrend * style.scrollIncrement));		}				/** @private redraws the component graphics. */		override protected function _redraw():void		{			// draw background fill			graphics.clear();			graphics.beginFill(style.scrollBorderColor, 1);			graphics.drawRect(0, 0, style.scrollWidth, height);			graphics.endFill();						// draw scroll well			var $w:int = style.scrollWidth - (style.scrollBorderSize * 2);			var $wellH:int = height - ((style.scrollBorderSize * 4) + (style.arrowHeight * 2));			_well.x = style.scrollBorderSize;			_well.y = style.arrowHeight + (style.scrollBorderSize * 2);			_well.graphics.clear();			_well.graphics.beginFill(style.scrollWellColor, 1);			_well.graphics.drawRect(0, 0, $w, $wellH);			_well.graphics.endFill();						// draw scroll bar			var $barH:int = $wellH * _contentRatio;			_bar.x = style.scrollBorderSize;			_bar.redraw($w, $barH);			// set the scroll bar constraint.			_constraint = new Rectangle(_well.x, _well.y, 0, $wellH - $barH);						// configure the UP arrow.			_up.x = style.scrollBorderSize;			_up.y = style.scrollBorderSize;			_up.style = style;						// configure the DOWN arrow.			_down.x = style.scrollBorderSize;			_down.y = height - style.scrollBorderSize;			_down.style = style;			_down.scaleY = -1;		}			// --------------------------------------------------	// Event handlers	// --------------------------------------------------				/** @private called upon mouseDown on a scroll arrow. */		private function _onArrowPress($event:MouseEvent):void {			stage.addEventListener(MouseEvent.MOUSE_UP, this._onArrowRelease, false, 0, true);			_timer.reset();			_timer.start();			_scrollTrend = ($event.target == _up) ? -1 : 1;			_bump();		}				/** @private called upon mouseUp after clicking on a scroll arrow. */		private function _onArrowRelease($event:MouseEvent):void {			stage.removeEventListener(MouseEvent.MOUSE_UP, this._onArrowRelease);			_timer.stop();		}				/** @private called upon timer cycles fired while an arrow button is held. */		private function _onArrowHold($event:Event):void {			_bump();		}				/** @private called upon mouseDown on the scroll well. */		private function _onWellPress($event:MouseEvent):void {			_scrollTo(mouseY - (_bar.height / 2));		}				/** @private called upon mouseDown on the scroll bar. */		private function _onBarPress($event:MouseEvent):void {			stage.addEventListener(MouseEvent.MOUSE_UP, this._onBarRelease, false, 0, true);			addEventListener(Event.ENTER_FRAME, this._onBarDrag, false, 0, true);			_bar.startDrag(false, _constraint);			update();		}				/** @private called upon mouseUp after clicking on the scroll bar. */		private function _onBarRelease($event:MouseEvent):void {			stage.removeEventListener(MouseEvent.MOUSE_UP, this._onBarRelease);			removeEventListener(Event.ENTER_FRAME, this._onBarDrag);			_bar.stopDrag();			update();		}				/** @private called on enterFrame while the scroll bar drags. */		private function _onBarDrag($event:Event):void {			update();		}	}}