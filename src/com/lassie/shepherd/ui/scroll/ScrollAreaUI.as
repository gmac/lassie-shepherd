package com.lassie.shepherd.ui.scroll{	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.Rectangle;		internal class ScrollAreaUI extends Sprite	{	// --------------------------------------------------	//  Constants	// --------------------------------------------------		private static const BAR_WIDTH:int = 7;		private static const PADDING:int = 1;		private static const ARROW_HEIGHT:int = 9;		private static const WELL_COLOR:uint = 0xFFFFFF;		private static const BUTTON_COLOR:uint = 0x90C1EF;		private static const STEPS:int = 10;			// --------------------------------------------------	//  Private members	// --------------------------------------------------			private var _areaHeight:int;		private var _scrollArea:int;		private var _scrollHeight:int;		private var _bounds:Rectangle;		private var _well:ScrollWell;		private var _grip:ScrollGrip;		private var _up:ScrollArrow;		private var _down:ScrollArrow;	// --------------------------------------------------	//  Constructor	// --------------------------------------------------				public function ScrollAreaUI():void		{			super();						// hide component until configured			visible = false;			// add scroll well			_well = new ScrollWell(BAR_WIDTH, WELL_COLOR);			addChild(_well);						// add up arrow			_up = new ScrollArrow(-1, BAR_WIDTH, ARROW_HEIGHT, PADDING, BUTTON_COLOR, WELL_COLOR);			addChild(_up);						// add down arrow			_down = new ScrollArrow(1, BAR_WIDTH, ARROW_HEIGHT, PADDING, BUTTON_COLOR, WELL_COLOR);			addChild(_down);						// add scroll bar grip			_grip = new ScrollGrip(BAR_WIDTH, PADDING, BUTTON_COLOR, WELL_COLOR);			addChild(_grip);						// configure interactive elements			_well.addEventListener(MouseEvent.MOUSE_DOWN, this.handleWellPress);			_grip.addEventListener(MouseEvent.MOUSE_DOWN, this.handleGripPress);			_up.addEventListener(MouseEvent.MOUSE_DOWN, this.handleArrowPress);			_down.addEventListener(MouseEvent.MOUSE_DOWN, this.handleArrowPress);		}				public function dispose():void		{			_well.removeEventListener(MouseEvent.MOUSE_DOWN, this.handleWellPress);			removeChild(_well);			_well = null;						_grip.removeEventListener(MouseEvent.MOUSE_DOWN, this.handleGripPress);			removeChild(_grip);			_grip = null;						_up.removeEventListener(MouseEvent.MOUSE_DOWN, this.handleArrowPress);			removeChild(_up);			_up = null;						_down.removeEventListener(MouseEvent.MOUSE_DOWN, this.handleArrowPress);			removeChild(_down);			_down = null;		}			// --------------------------------------------------	//  Public methods	// --------------------------------------------------				public function setScroll(areaHeight:int, ratio:Number, offset:Number):void		{			// if content height is greater than area height			if (ratio < 1)			{				_areaHeight = areaHeight;				_scrollArea = _areaHeight - (ARROW_HEIGHT * 2);				_scrollHeight = Math.max(_scrollArea * ratio, 15);				_bounds = new Rectangle(0, ARROW_HEIGHT, 0, _scrollArea - _scrollHeight);								_down.y = _areaHeight;				_grip.y = _bounds.top + (_bounds.height * offset);								_well.redraw(_areaHeight);				_grip.redraw(_scrollHeight);								visible = true;			}			else			{				// hide scroll bar if content is smaller than area				visible = false;			}		}			// --------------------------------------------------	//  Private methods	// --------------------------------------------------				private function stepGripPosition(dir:int):void		{			_grip.y = restrictGripBounds(_grip.y + (10 * dir));			updateScroll();		}				private function restrictGripBounds(ypos:int):int		{			return Math.max(_bounds.top, Math.min(ypos, _bounds.bottom));		}				private function updateScroll():void		{			var percent:Number = (_grip.y - _bounds.y) / _bounds.height;			dispatchEvent(new ScrollAreaEvent(ScrollAreaEvent.UPDATE_SCROLL, percent));		}			// --------------------------------------------------	//  Event handlers	// --------------------------------------------------				private function handleGripPress(evt:MouseEvent):void		{			_grip.startDrag(false, _bounds);			addEventListener(Event.ENTER_FRAME, this.handleGripDrag);			stage.addEventListener(MouseEvent.MOUSE_UP, this.handleGripRelease);		}				private function handleGripRelease(evt:MouseEvent):void		{			stage.removeEventListener(MouseEvent.MOUSE_UP, this.handleGripRelease);			removeEventListener(Event.ENTER_FRAME, this.handleGripDrag);			_grip.stopDrag();		}				private function handleGripDrag(evt:Event):void		{			updateScroll();		}				private function handleArrowPress(evt:MouseEvent):void		{			var button:ScrollArrow = ScrollArrow(evt.currentTarget);			stepGripPosition(button.direction);		}				private function handleWellPress(evt:MouseEvent):void		{			_grip.y = restrictGripBounds(mouseY - (_scrollHeight / 2));			updateScroll();		}	}}import flash.display.Sprite;import flash.geom.Point;// --------------------------------------------------//  Scroll Bar Well// --------------------------------------------------internal final class ScrollWell extends Sprite{	private var _barWidth:int;	private var _barColor:int;		public function ScrollWell(w:int, col:uint):void	{		super();				_barWidth = w;		_barColor = col;	}		public function redraw(h:int):void	{		graphics.clear();		graphics.beginFill(_barColor, 1);		graphics.drawRect(0, 0, _barWidth, h);		graphics.endFill();	}}// --------------------------------------------------//  Scroll Bar Grip// --------------------------------------------------internal final class ScrollGrip extends Sprite{	private var _barWidth:int;	private var _padding:int;	private var _barColor:int;	private var _padColor:int;		public function ScrollGrip(w:int, pad:int, barColor:uint, padColor:uint):void	{		super();				_barWidth = w;		_padding = pad;		_barColor = barColor;		_padColor = padColor;				buttonMode = true;		useHandCursor = true;	}		public function redraw(h:int):void	{		graphics.clear();				// draw bar padding		graphics.beginFill(_padColor, 1);		graphics.drawRect(0, 0, _barWidth, h);		graphics.endFill();				// draw bar		graphics.beginFill(_barColor, 1);		graphics.drawRect(_padding, _padding, _barWidth - (_padding * 2), h - (_padding * 2));		graphics.endFill();	}}// --------------------------------------------------//  Scroll Bar Arrow Buttons// --------------------------------------------------internal final class ScrollArrow extends Sprite{	private static const ARROW_PAD_X:int = 0;	private static const ARROW_PAD_Y:int = 2;	private static const ARROW_COLOR:uint = 0xFFFFFF;		private var _direction:int;	private var _boxWidth:int;	private var _boxHeight:int;	private var _padding:int;	private var _arrow0:Point;	private var _arrow1:Point;	private var _arrow2:Point;	private var _boxColor:int;	private var _padColor:int;			public function ScrollArrow(dir:int, w:int, h:int, pad:int, boxColor:uint, padColor:uint):void	{		super();				_direction = dir;		_boxWidth = w;		_boxHeight = h;		_padding = pad;		_boxColor = boxColor;		_padColor = padColor;				buttonMode = true;		useHandCursor = true;				var bottom:int = _boxHeight - ARROW_PAD_Y;		// map three points of traingle		_arrow0 = new Point(_boxWidth/2, _padding + ARROW_PAD_Y);		_arrow1 = new Point(_padding + ARROW_PAD_X, bottom);		_arrow2 = new Point(_boxWidth - _padding - ARROW_PAD_X, bottom);				redraw();	}		public function get direction():int	{		// return increment direction		return _direction;	}		private function redraw():void	{		graphics.clear();				// draw box padding		graphics.beginFill(_padColor, 1);		graphics.drawRect(0, 0, _boxWidth, _boxHeight);		graphics.endFill();				// draw box		graphics.beginFill(_boxColor, 1);		graphics.drawRect(_padding, _padding, _boxWidth - (_padding * 2), _boxHeight - _padding);		graphics.endFill();				// draw arrow		graphics.beginFill(ARROW_COLOR, 1);		graphics.moveTo(_arrow0.x , _arrow0.y);		graphics.lineTo(_arrow1.x , _arrow1.y);		graphics.lineTo(_arrow2.x , _arrow2.y);		graphics.lineTo(_arrow0.x , _arrow0.y);		graphics.endFill();				// set button flip		scaleY = _direction * -1;	}}