package com.lassie.shepherd.ui.scroll{	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.Rectangle;	import com.lassie.shepherd.ui.scroll.ScrollAreaUI;	import com.lassie.shepherd.ui.scroll.ScrollAreaEvent;		public class ScrollArea extends Sprite	{	// --------------------------------------------------	//  Constants	// --------------------------------------------------			private static const WELL_PAD:int = 1;		private static const WELL_COLOR:uint = 0x000000;		private static const BAR_COLOR:uint = 0x666666;			// --------------------------------------------------	//  Private members	// --------------------------------------------------				private var _scope:Sprite;		private var _area:Rectangle;		private var _content:Sprite;		private var _contentRange:int;		private var _scrollbar:ScrollAreaUI;			// --------------------------------------------------	//  Constructor	// --------------------------------------------------				public function ScrollArea(area:Rectangle, target:Sprite=null):void		{			super();			// create and add scroll bar			_scrollbar = new ScrollAreaUI();			_scrollbar.addEventListener(ScrollAreaEvent.UPDATE_SCROLL, this.handleScroll);						// set initial scroll area if parameters are provided			if (target != null)			{				setScrollArea(area, target);			}			else			{				setScrollRect(area);			}		}				public function dispose():void		{			_scrollbar.removeEventListener(ScrollAreaEvent.UPDATE_SCROLL, this.handleScroll);			_scrollbar.dispose();		}			// --------------------------------------------------	//  Public methods	// --------------------------------------------------				public function setScrollArea(area:Rectangle, target:Sprite):void		{			// clear all existing asset scope and configuration			clearScrollArea();						try			{				// set ScrollArea's scope as target's parent				_scope = Sprite(target.parent);			}			catch(e)			{				trace("ScrollArea must target media that exists within Flash display.");				return;			}						if (_scope != null)			{				// add ScrollArea and ScrollBar to display				_scope.addChild(this);				_scope.addChild(_scrollbar);								// set ScrollArea rect and content mask				_area = area;				_content = target;				_content.y = _area.y;				_content.mask = this;								// position ScrollArea and scroll bar				x = _area.x;				y = _area.y;				_scrollbar.x = _area.x + _area.width;				_scrollbar.y = _area.y;					// restrict scroll height				setScrollHeight(_area.height);			}		}				public function clearScrollArea():void		{			// clear any existing content masks			if (_content != null)			{				_content.mask = null;				_content = null;			}						// remove scrollbar from any existing scope			if (_scrollbar.parent != null)			{				_scrollbar.parent.removeChild(_scrollbar);			}						// remove ScrollArea from any existing scope			if (parent != null)			{				parent.removeChild(this);			}		}				public function setScrollHeight(h:int):void		{			// set ScrollArea's height			_area.height = h;						if (_content != null)			{				// set content's range of scroll				_contentRange = _content.height - h;								// calculate ratio of visible height and content's offset from total scroll				var scrolled:int = _area.y - _content.y;				var ratio:Number = _area.height / _content.height;				var offset:Number = scrolled / _contentRange;				// restrict offset to current maximum range of scrolling				if (offset > 1)				{					offset = 1;					_content.y = -_contentRange;				}				else if (offset < 0)				{					_content.y = _area.y;				}								// reset scrollbar				_scrollbar.setScroll(_area.height, ratio, offset);				redraw();			}		}				public function setScrollRect(rect:Rectangle):void		{			_area = rect;						if (_content != null)			{				setScrollArea(_area, _content);			}		}				public function setScrollTarget(target:Sprite):void		{			setScrollArea(_area, target);		}			// --------------------------------------------------	//  Private methods	// --------------------------------------------------			private function redraw():void		{			graphics.clear();			graphics.beginFill(0x000000, 0);			graphics.drawRect(0, 0, _area.width, _area.height);			graphics.endFill();		}			// --------------------------------------------------	//  Event handlers	// --------------------------------------------------				private function handleScroll(evt:ScrollAreaEvent):void		{			_content.y = int(_area.y - (_contentRange * evt.scrollPercentage));		}	}}