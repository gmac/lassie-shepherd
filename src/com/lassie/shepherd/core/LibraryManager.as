package com.lassie.shepherd.core{	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.display.MovieClip;	import flash.media.Sound;	import com.lassie.lib.ILibrary;	import com.lassie.shepherd.core.ILibraryManager;	import com.lassie.player.events.LibraryEvent;	import com.stimuli.loading.BulkLoader;	/**	*  Dispatched on download progress of a batch load.	*  @event: com.lassie.lib.LibraryEvent.PROGRESS	*/	[Event(name="progress", type="com.lassie.player.events.LibraryEvent")]		/**	* Dispatched when all loads have been resolved and parsed.	* @event: com.lassie.lib.LibraryEvent.COMPLETE	*/	[Event(name="complete", type="com.lassie.player.events.LibraryEvent")]		public final class LibraryManager extends EventDispatcher implements ILibraryManager	{		// LOCAL_HOST: tells if SWF is running locally or not.		// set by root player application.		public static var LOCAL_HOST:Boolean = false;				// Private constants		private const EXCLUDE_NONE:String = "";		private const EXCLUDE_REDUNDANT:String = "redundant";		private const EXCLUDE_MISSING:String = "missing";				// static loader instance counter		private static var _loadCount:int = 0;				// Private variables		private var _libs:Object;		private var _pending:Object;			// --------------------------------------------------	//  Constructor	// --------------------------------------------------			private static var _instance:LibraryManager;				public static function get instance():LibraryManager {			if (_instance == null) _instance = new LibraryManager(new LibraryManagerEnforcer());			return _instance;		}				public function LibraryManager($enforcer:LibraryManagerEnforcer):void		{			super();			_libs = new Object();			_pending = new Object();		}			// --------------------------------------------------	//  ILibrary methods	// --------------------------------------------------				/**		* Creates a unique name for a new load operation		* @return: unique name		*/		public function getUniqueLoaderName():String		{			_loadCount++;			return "load" + _loadCount;		}				/**		* Loads a list of library SWFs		* @param: reference name for load operation		* @param: files to load formatted as comma seperated values		* @param: automatically start operation after loader configuration		* @return: true / false concerning if a load operation was configured		*/		public function load($loadName:String, $csv:String):void		{			var $list:Array = _parseFilesList($csv, EXCLUDE_REDUNDANT);						if ($list.length > 0)			{				var $bulk:BulkLoader = new BulkLoader($loadName);				$bulk.addEventListener(BulkLoader.COMPLETE, this._onLoadComplete);				$bulk.addEventListener(BulkLoader.PROGRESS, this._onLoadProgress);				$bulk.addEventListener(BulkLoader.ERROR, this._onLoadError);								for each (var j:String in $list)				{					trace("[Library] add: " + j);										// configure no-cache string if running remotely					//var nocache:String = (!Library.LOCAL_HOST) ? "?nocache="+Math.random().toString() : "";					_pending[j] = true;					$bulk.add(j);				}								$bulk.start();			}			else			{				_callComplete($loadName);			}		}				/**		* Purges all library contents not present in load request, then loads requested files.		* @param: reference name for load operation		* @param: files to load formatted as comma seperated values		* @param: automatically start operation after loader configuration		* @return: true / false concerning if a load operation was configured		*/		public function purgeAndLoad($loadName:String, $csv:String):void		{			var $load:Array = _parseFilesList($csv, EXCLUDE_NONE);			var $contents:Array = getLibrariesList();			var $purge:Array = new Array();						for each (var j:String in $contents)			{				// add contents item to purge queue if it is not part of the new load request.				if ($load.indexOf(j) < 0) $purge.push(j);			}						unload($purge.join(","));			load($loadName, $load.join(","));		}				/**		* Purges a list of library SWFs		* @param: files to purge formatted as comma seperated values		*/		public function unload($csv:String):void		{			var $list:Array = _parseFilesList($csv, EXCLUDE_MISSING);						for each (var j:String in $list)			{				delete _libs[j];			}		}				/**		* Registers a dynamic-typed event specific to one loader		*/		public function addLoadListener($loaderName:String, $event:String, $handler:Function):void		{			this.addEventListener(_parseEventType($loaderName, $event), $handler);		}				/**		* Removes a dynamic-typed event		*/		public function removeLoadListener($loaderName:String, $event:String, $handler:Function):void		{			this.removeEventListener(_parseEventType($loaderName, $event), $handler);		}				/**		* Checks if a library SWF is present within the directory		* @param: file to check for		* @param: include pending queue in check		* @return: file found boolean		*/		public function hasLibrary($libKey:String, $checkPending:Boolean=false):Boolean		{			return $checkPending ? (_libs[$libKey] != undefined || _pending[$libKey] != undefined) : (_libs[$libKey] != undefined);		}				/**		* Checks if all libraries in a comma seperated list are present		* @param: files to check for formatted as comma seperated values		* @return: true if all libraries are present		*/		public function hasAllLibraries($csv:String):Boolean		{			var list:Array = _parseFilesList($csv, EXCLUDE_NONE);						for each (var j:String in list)			{				if (!hasLibrary(j)) return false;			}			return true;		}				/**		* Creates a list of all library files in directory		* @return: array of file keys		*/		public function getLibrariesList():Array		{			var list:Array = new Array();			for (var j:String in _libs) list.push(j);			list.sort();			return list;		}				/**		* Gets a library by key		* @param: library name		* @return: media library interface		*/		public function getLibraryById($libKey:String):ILibrary		{			if (hasLibrary($libKey))			{				return _libs[$libKey] as ILibrary;			}			return null;		}				/**		* Returns a list of all classes contained within the specified library file		* @return: array of class names		*/		// MovieClips		public function getLibraryMovieClips($libKey:String):Array		{			try			{				return ILibrary(_libs[$libKey]).movieClipContents;			}			catch (e:Error)			{				trace("[Library] getLibraryMovieClips(), contents could not be acquired.");			}			return null;		}				// Sounds		public function getLibrarySounds($libKey:String):Array		{			try			{				return ILibrary(_libs[$libKey]).soundContents;			}			catch (e:Error)			{				trace("[Library] getLibrarySounds(), contents could not be acquired.");			}			return null;		}				// XML		public function getLibraryXML($libKey:String):Array		{			try			{				return ILibrary(_libs[$libKey]).xmlContents;			}			catch (e:Error)			{				trace("[Library] getLibraryXML(), contents could not be acquired.");			}			return null;		}				/**		* Retrieves a class asset from the specified library		* @param: library file directory key		* @param: library class name		* @return: instance of the target class		*/		// MovieClip		public function getMovieClip($libKey:String, $class:String):MovieClip		{			try			{				return ILibrary(_libs[$libKey]).getMovieClip($class);			}			catch(e:Error)			{				trace("[Library] getMovieClip(), \"" + $libKey +":"+ $class + "\" could not be acquired.");			}			return null;		}				// Sound		public function getSound($libKey:String, $class:String):Sound		{			try			{				return ILibrary(_libs[$libKey]).getSound($class);			}			catch(e:Error)			{				trace("[Library] getSound(), \"" + $libKey +":"+ $class + "\" could not be acquired.");			}			return null;		}				// XML		public function getXML($libKey:String, $id:String):XML		{			try			{				return ILibrary(_libs[$libKey]).getXML($id);			}			catch(e:Error)			{				trace("[Library] getXML(), \"" + $libKey +":"+ $id + "\" could not be acquired.");			}			return null;		}				/**		* Retrieves a class asset from the specified library		* @param: library file directory key		* @param: library class name		* @return: instance of the target class		*/		public function getMovieClipByAddress($address:String):MovieClip		{			var $list:Array = _parseAddress($address);						if ($list.length == 2 && hasLibrary($list[0]))			{				try				{					return getMovieClip($list[0], $list[1]);				}				catch(e:Error)				{					trace("[Library] getMovieClipByAddress(), \"" + $address + "\" could not be acquired.");				}			}			return null;		}				public function getSoundByAddress($address:String):Sound		{			var $list:Array = _parseAddress($address);						if ($list.length == 2 && hasLibrary($list[0]))			{				try				{					return getSound($list[0], $list[1]);				}				catch(e:Error)				{					trace("[Library] getSoundByAddress(), \"" + $address + "\" could not be acquired.");				}			}			return null;		}				public function getXMLByAddress($address:String):XML		{			var $list:Array = _parseAddress($address);						if ($list.length == 2 && hasLibrary($list[0]))			{				try				{					return getXML($list[0], $list[1]);				}				catch(e:Error)				{					trace("[Library] getXMLByAddress(), \"" + $address + "\" could not be acquired.");				}			}			return null;		}			// --------------------------------------------------	//  Private methods	// --------------------------------------------------					/**		* Splits a library address into fields		* @param: library file address		* @return: array of address fields		*/		private function _parseAddress($address:String):Array		{			$address = $address.split(" ").join("");			return $address.split(":");		}		private function _parseFilesList($csv:String, $filter:String=EXCLUDE_NONE):Array		{			$csv = $csv.split(" ").join("");			var $all:Array = $csv.split(",");			var $keep:Array = new Array();						for each (var j:String in $all)			{				// restrict to swf files that are not already logged				if (j.substr(-4) == ".swf" && $keep.indexOf(j) < 0)				{					var $hasLib:Boolean = hasLibrary(j, true);										if (($filter == EXCLUDE_REDUNDANT && !$hasLib) || ($filter == EXCLUDE_MISSING && $hasLib) || $filter == EXCLUDE_NONE)					{						$keep.push(j);					}				}			}						return $keep;		}			private function _parseEventType($loaderName:String, $event:String):String		{			return $loaderName + "_" + $event;		}				private function _callComplete($loadName:String):void		{			dispatchEvent(new LibraryEvent(_parseEventType($loadName, LibraryEvent.COMPLETE), $loadName, 1));		}			// --------------------------------------------------	//  Event handlers	// --------------------------------------------------				private function _onLoadProgress($evt:Event):void		{			var $bulk:BulkLoader = BulkLoader($evt.currentTarget);			dispatchEvent(new LibraryEvent(_parseEventType($bulk.name, LibraryEvent.PROGRESS), $bulk.name, $bulk.percentLoaded));		}				private function _onLoadComplete($evt:Event):void		{			var $bulk:BulkLoader = BulkLoader($evt.currentTarget);						// copy all valid media libraries from bulk loader into directory			for (var j:String in $bulk.contents)			{				if ($bulk.contents[j] is ILibrary)				{					_libs[j] = $bulk.contents[j];					delete _pending[j];				}				else				{					trace("[Library] _onLoadComplete: unknown library format encountered.");				}			}			// clean up BulkLoader instance			var $name = $bulk.name;			$bulk.removeEventListener(BulkLoader.COMPLETE, this._onLoadComplete);			$bulk.removeEventListener(BulkLoader.PROGRESS, this._onLoadProgress);			$bulk.removeEventListener(BulkLoader.ERROR, this._onLoadError);			$bulk.removeAll();			$bulk.clear();						_callComplete($name);		}						private function _onLoadError($evt:Event):void		{			trace("[Library] Load error.");			//dispatchEvent(new LibraryEvent(LibraryEvent.COMPLETE, $name, 1));		}	}}internal class LibraryManagerEnforcer {}