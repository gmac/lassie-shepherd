package com.lassie.shepherd.data.game{	import com.lassie.shepherd.data.*;	import com.lassie.utils.KeyUtil;	import com.adobe.crypto.MD5;		public class GameXMLCompiler extends XMLCompiler	{	// --------------------------------------------------	// Static interface	// --------------------------------------------------			private static var _instance:GameXMLCompiler;				public static function parse(game:GameData):String		{			if (_instance == null) _instance = new GameXMLCompiler(new Enforcer());			return _instance.parseGame(game);		}				public static function get transcript():String		{			if (_instance == null) _instance = new GameXMLCompiler(new Enforcer());			return _instance._transcript;		}			// --------------------------------------------------	// Instance	// --------------------------------------------------				public function GameXMLCompiler(enforcer:Enforcer):void {			super();		}	// --------------------------------------------------	// Grid compiler	// --------------------------------------------------				protected function parseGame(dat:GameData):String		{			reset();						var $voiceLibs:String = normalize(dat.voiceLibs);			_defaultVoiceLib = ($voiceLibs.indexOf("voice/") == 0) ? $voiceLibs.split(",")[0] : "";			_defaultVoiceClass = "global";						var j:int;			var xml:String = xmlHeader;			xml += '<global ';			xml += 'id="_'+ MD5.hash(dat.title) +'" ';			xml += 'key="" ';			xml += 'compact="'+ boolean(_compact) +'" ';			xml += 'stageWidth="'+ dat.stageWidth +'" ';			xml += 'stageHeight="'+ dat.stageHeight +'" ';			xml += 'coreLibs="'+ normalize(dat.coreLibs) +'" ';			xml += 'voiceLibs="'+ $voiceLibs +'" ';			xml += 'langOptions="'+ dat.gameLang +'">\n';						// extract default actor record.			for each (var $actor:CastRecord in dat.actors) {				if ($actor.id == dat.defaultActor) break;			}						// config			xml += tab(1) + '<config ';			xml += 'language="'+ dat.gameLang +'" ';			xml += 'actor="'+ dat.defaultActor +'" ';			xml += 'room="'+ dat.defaultRoom +'" ';			xml += 'soundtrackVolume="0.5" ';			xml += 'soundfxVolume="0.5" ';			xml += 'voiceVolume="0.5" ';			xml += 'voices="0" ';			xml += 'subtitles="1"/>\n';						// title and author			xml += tab(1) + '<title><![CDATA['+ dat.title +']]></title>\n';			xml += tab(1) + '<author><![CDATA['+ dat.author +']]></author>\n';						// verb dialect			xml += tab(1) + '<verbDialect>\n';			xml += tab(2) + compileLang(dat.verbDialect) +'\n';			xml += tab(1) + '</verbDialect>\n';						// item dialect			xml += tab(1) + '<itemDialect>\n';			xml += tab(2) + compileLang(dat.itemDialect) +'\n';			xml += tab(1) + '</itemDialect>\n';						// actors			xml += tab(1) + '<actors>\n';						for (j = 0; j < dat.actors.length; j++)			{				xml += _compileActor(CastRecord(dat.actors[j]));			}						xml += tab(1) + '</actors>\n';						_transcript += "RESPONSES\n";						// responses			xml += tab(1) + '<responses>\n';						for (j = 0; j < dat.responses.length; j++)			{				xml += _compileResponse(ResponseRecord(dat.responses[j]));			}						xml += tab(1) + '</responses>\n';						_transcript += "\n\n\nITEMS\n";						// items			xml += tab(1) + '<items>\n';						for (j = 0; j < dat.items.length; j++)			{				xml += _compileItem(ItemRecord(dat.items[j]));			}						xml += tab(1) + '</items>\n';						// collections			xml += tab(1) + '<inventories>\n';							for (j = 0; j < dat.collections.length; j++)			{				xml += _compileCollection(CollectionRecord(dat.collections[j]));			}							xml += tab(1) + '</inventories>\n';						_transcript += "\n\n\nCOMBOS\n";						// combos			xml += tab(1) + '<combos>\n';							for (j = 0; j < dat.combos.length; j++)			{				xml += _compileCombo(ComboRecord(dat.combos[j]));			}							xml += tab(1) + '</combos>\n';						// scripts			xml += tab(1) + '<scripts>\n';							for (j = 0; j < dat.scripts.length; j++)			{				xml += compileScript(ScriptRecord(dat.scripts[j]));			}							xml += tab(1) + '</scripts>\n';						xml += '</global>';			_transcript += "\n\n\n" + _dialogueCSV;			_transcript += "\n\n\n" + _dialogueAS;						var $xml:XML = new XML(xml);			XML.prettyPrinting = !_compact;							// add security key if authorization key checks out.			if (dat.serialKey == KeyUtil.authorKey(dat.author)) {				$xml = KeyUtil.secure( $xml );			}						var $return:String = $xml.toXMLString();			XML.prettyPrinting = true;			return $return;		}			// --------------------------------------------------	// Grid compiler	// --------------------------------------------------				private function _compileActor(dat:CastRecord, t:int=2):String		{			var xml:String = tab(t) + '<actor id="'+ dat.id +'" ';			xml += 'asset="'+ dat.asset +'" ';			xml += 'regX="'+ dat.regX +'" ';			xml += 'regY="'+ dat.regY +'" ';			xml += 'response="'+ dat.response +'" ';			xml += 'inventory="'+ dat.inventory +'" ';			xml += 'subtitle="'+ color(dat.diaColor) +'"><![CDATA['+ dat.title +']]></actor>\n';			return xml;		}				private function _compileResponse(dat:ResponseRecord, t:int=2):String		{			_transcript += '\n'+ _textRule;			_transcript += "- Response: "+ dat.id +"\n";			_transcript += _textRule;			var xml:String = tab(t) + '<response id="'+ dat.id +'">\n';						// compile actions			for (var j:int = 0; j < dat.actions.length; j++)			{				var $action:InteractionData = InteractionData(dat.actions[j]);								if ($action.title == "_default") {					$action.id = "_default";				} else {					$action.id = actionIdList[Math.min(j, actionIdList.length-1)];				}								_transcript += '  -----\n  Action: "'+ $action.id +'" (response: '+ dat.id +")\n\n";				xml += compileAction($action, t+1);			}						xml += tab(t) + '</response>\n';			return xml;		}				private function _compileItem(dat:ItemRecord, t:int=2):String		{			_transcript += '\n'+ _textRule;			_transcript += "- Item: "+ dat.id +"\n";			_transcript += _textRule;			_transcript += 'title: "'+ dat.title +'"\n';						var xml:String = tab(t) + '<item id="'+ dat.id +'" ';			xml += 'asset="'+ dat.asset +'" ';			xml += 'frame="'+ dat.frame +'" ';			xml += 'hover="'+ dat.hoverFrame +'">\n';			xml += tab(t+1) + '<title>\n';			xml += tab(t+2) + compileLang(includeNode(dat.title)) +'\n';			xml += tab(t+1) +'</title>\n';						// compile actions			for (var j:int = 0; j < dat.actions.length; j++)			{				var $action:InteractionData = InteractionData(dat.actions[j]);				$action.id = ($action.title == "_default" || $action.title.indexOf("[_default]") > 0) ? "_default" : actionIdList[Math.min(j, actionIdList.length-1)];				_transcript += '  -----\n  Action: "'+ $action.title +'" (item: '+ dat.id +")\n\n";				xml += compileAction($action, t+1);			}						xml += tab(t) + '</item>\n';			return xml;		}				private function _compileCollection(dat:CollectionRecord, t:int=2):String		{			var xml:String = tab(t) + '<inventory id="'+ dat.id +'" ';			xml += 'items="'+ dat.items.join(",") +'" ';			xml += 'hoverStyle="'+ (dat.hoverMode ? "outline" : "tint") +'" ';			xml += 'hoverColor="'+ color(dat.hoverColor) +'"/>\n';			return xml;		}				private function _compileCombo(dat:ComboRecord, t:int=2):String		{			_transcript += '\n'+ _textRule;			_transcript += "- Combo: "+ dat.id +" ["+ dat.primary +" >> "+ dat.items.join(",") +"]\n";			_transcript += _textRule;						var xml:String = tab(t) + '<combo id="'+ dat.id +'" ';			xml += 'primary="'+ dat.primary +'" ';			xml += 'pool="'+ dat.items.join(",") +'">\n';			xml += compileAction(dat.action, t+1);			xml += tab(t) + '</combo>\n';			return xml;		}	}}internal final class Enforcer {}