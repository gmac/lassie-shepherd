package com.lassie.shepherd.data.game{	import com.lassie.shepherd.data.game.GameDataParser;	import com.lassie.utils.ObjectUtil;		public final class TierData	{		public var id:String = "";		public var lockId:Boolean = false;		public var topics:Array;		public var spawn:int = 0;				public function TierData(i:String=""):void		{			id = i;			topics = new Array();		}				/*		* Adds a topic to the tier and returns the new topic's index.		*/		public function addTopic():TopicData		{			var topic:TopicData = new TopicData(spawn++);			topics.push(topic);			return topic;		}				/*		* Copies an existing topic and returns the copy's index.		*/		public function copyTopic($index:int):TopicData		{			if ($index >= 0 && $index < topics.length) {				var $topic:TopicData = topics[ $index ] as TopicData;				var $copy:TopicData = GameDataParser.toTopicData( ObjectUtil.clone($topic) );				$copy.setTopicKey(spawn++);				topics.push($copy);				return $copy;			}			return addTopic();		}				/*		* Deletes a topic from the tier and returns the previous topic's index.		*/		public function deleteTopic(index:int):int		{			// if index is within valid range of contents			if (index >= 0 && index < topics.length)			{				// remove selected index				topics.splice(index, 1);								if (index > 0)				{					return index-1;				}				else if (topics.length > 0)				{					return 0;				}			}			return -1;		}				/*		* Returns the number of topics within the tier.		*/		public function get numTopics():int		{			return topics.length;		}				public function getTopicByIndex(index:int):TopicData		{			if (index >= 0 && index < topics.length)			{				return topics[index] as TopicData;			}			return null;		}				public function getTopicByKey(k:String):TopicData		{			for each (var j:TopicData in topics)			{				if (TopicData(j).key == k) return j;			}			return null;		}				public function setTopicIndex(index:int, shiftTo:int):int		{			if (index >= 0 && index < topics.length && index != shiftTo)			{				shiftTo = Math.max(0, Math.min(shiftTo, topics.length-1));				var dat:Array = topics.splice(index, 1);				topics.splice(shiftTo, 0, dat[0]);				return shiftTo;			}			return index;		}	}}