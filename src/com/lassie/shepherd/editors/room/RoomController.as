package com.lassie.shepherd.editors.room{	import flash.geom.Rectangle;	import flash.events.Event;	import flash.events.EventDispatcher;	import com.lassie.shepherd.core.LSDispatcher;	import com.lassie.shepherd.core.ILibraryManager;	import com.lassie.shepherd.core.IServicePackage;	import com.lassie.shepherd.data.game.GameData;	import com.lassie.shepherd.data.room.NodeData;	import com.lassie.shepherd.events.ShepherdEvent;	import com.lassie.shepherd.editors.room.interfaces.*;	import com.lassie.shepherd.editors.room.data.WalkDataService;	import com.lassie.shepherd.editors.room.data.FilterDataService;	import com.lassie.shepherd.editors.room.events.RoomEditorEvent;	public final class RoomController extends LSDispatcher	{			// --------------------------------------------------	//  Singleton	// --------------------------------------------------			private static var _instance:RoomController;				public static function get instance():RoomController		{			if (_instance == null)			{				_instance = new RoomController(new SingletonEnforcer());			}			return _instance;		}			// --------------------------------------------------	//  Constructor	// --------------------------------------------------			private var _walkData:WalkDataService;		private var _filterData:FilterDataService;		private var _selectedLayer:ILayer;		private var _selectedNode:NodeData;		private var _layersList:Array;		private var _layout:ILayout;		private var _layers:ILayerControl;		private var _targets:ITargetControl;		private var _nodes:INodeControl;		private var _boxes:IBoxControl;		private var _filters:IFilterControl;		private var _layoutWidth:int=800;		private var _layoutHeight:int=600;		private var _layoutMode:String;				public function RoomController(enforcer:SingletonEnforcer):void		{			super();			lsRoomData.addEventListener(ShepherdEvent.ROOM_DATA_CLEAR, this._onClearRoomData);			lsRoomData.addEventListener(ShepherdEvent.ROOM_DATA_LOG, this._onLogRoomData);		}				public function configure():void		{			_walkData = new WalkDataService(lsRoomData.walkareas);			_filterData = new FilterDataService(lsRoomData.filters);		}				public function setLayouts(layout:ILayout, layer:ILayerControl, target:ITargetControl, node:INodeControl, box:IBoxControl, filter:IFilterControl):void		{			_layout = layout;			_layers = layer;			_targets = target;			_nodes = node;			_boxes = box;			_filters = filter;		}				private function _onClearRoomData(evt:Event):void		{			if (!!_walkData) _walkData.clear();			if (!!_filterData) _filterData.clear();		}				private function _onLogRoomData(evt:Event):void		{			// called by listener applied to game data			// updates source with latest information before saving			if (RoomController.layersList != null)			{				layerData = new Array();				var layers:Array = RoomController.layersList;								for (var j:int = 0; j < layers.length; j++)				{					layerData.push(ILayer(layers[j]).data);				}			}			if (walkareaData != null && filterData != null)			{				// collect systems data				lsRoomData.walkareas = walkareaData.data;				lsRoomData.filters = filterData.data;			}		}			// --------------------------------------------------	//  Static getter / setters	// --------------------------------------------------				/**		* Read-Write :		* Layer data array		*/		public static function get layerData():Array		{			return instance.lsRoomData.layers;		}				public static function set layerData(layers:Array):void		{			instance.lsRoomData.layers = layers;		}					/**		* Read-only :		* Walkable area data		*/		public static function get walkareaData():WalkDataService		{			return instance._walkData;		}				/**		* Read-only :		* Matrix filter data		*/		public static function get filterData():FilterDataService		{			return instance._filterData;		}			// --------------------------------------------------	//  Selected Layer	// --------------------------------------------------				/**		* Read / Write :		* Selected room layer		*/		public static function get selectedLayer():ILayer		{			return instance._selectedLayer;		}				public static function set selectedLayer(layer:ILayer):void		{			instance._selectedLayer = layer;						if (layer != null)			{				instance.dispatchEvent(new RoomEditorEvent(RoomEditorEvent.UPDATE_LAYER_SELECTION));			}		}				/**		* Called by layout, listened by controls		*/		public static function updateLayerControls():void		{			instance.dispatchEvent(new RoomEditorEvent(RoomEditorEvent.UPDATE_LAYER_CONTROLS));		}		public static function updatePositionControls():void		{			instance.dispatchEvent(new RoomEditorEvent(RoomEditorEvent.UPDATE_POSITION_CONTROLS));		}				public static function updateHitControls():void		{			instance.dispatchEvent(new RoomEditorEvent(RoomEditorEvent.UPDATE_HITAREA_CONTROLS));		}				public static function updateImageControls():void		{			instance.dispatchEvent(new RoomEditorEvent(RoomEditorEvent.UPDATE_IMAGE_CONTROLS));		}				/**		* Called by controls, listened by layout		*/		public static function updateLayerLayout():void		{			instance.dispatchEvent(new RoomEditorEvent(RoomEditorEvent.UPDATE_SELECTED_LAYER_LAYOUT));		}			// --------------------------------------------------	//  Layers List	// --------------------------------------------------				/**		* Read / Write :		* List of layer objects within room layout		*/		public static function get layersList():Array		{			return instance._layersList;		}				public static function set layersList(list:Array):void		{			instance._layersList = list;			instance.dispatchEvent(new RoomEditorEvent(RoomEditorEvent.UPDATE_LAYERS_LIST));		}				/**		* Read Only :		* Lists npc-enabled puppet layers formatted as a dataProvider		*/		/*		public static function get puppetNpcList():Array		{			var layers:Array = layersList;			var list:Array = new Array();						for (var j:int = 0; j < layers.length; j++)			{				var layer:ILayer = ILayer(layers[j]);								if (layer.npc)				{					list.push({label:layer.id, data:layer.id});				}			}						return list;		}		*/			// --------------------------------------------------	//  Selected Node	// --------------------------------------------------				/**		* Read / Write :		* Selected grid node, set by NodeControl		*/		public static function get selectedNode():NodeData		{			return instance._selectedNode;		}				public static function set selectedNode(node:NodeData):void		{			instance._selectedNode = node;			instance.dispatchEvent(new RoomEditorEvent(RoomEditorEvent.UPDATE_NODE_SELECTION));		}			// --------------------------------------------------	//  Control systems	// --------------------------------------------------				public static function get layers():ILayerControl		{			return instance._layers;		}				public static function get targets():ITargetControl		{			return instance._targets;		}				public static function get nodes():INodeControl		{			return instance._nodes;		}				public static function get boxes():IBoxControl		{			return instance._boxes;		}				public static function get filters():IFilterControl		{			return instance._filters;		}			// --------------------------------------------------	//  Layout settings	// --------------------------------------------------			public static function get viewportWidth():int		{			return instance._layout.scrollRect.width;		}				public static function get viewportHeight():int		{			return instance._layout.scrollRect.height;		}				public static function get layoutWidth():int		{			return instance._layoutWidth;		}				public static function get layoutHeight():int		{			return instance._layoutHeight;		}				public static function get layoutScrollX():int		{			return instance._layout.scrollRect.x;		}		public static function get layoutScrollY():int		{			return instance._layout.scrollRect.y;		}				public static function get layoutScrollPercentX():Number		{			var perc:Number = layoutScrollX / (layoutWidth - viewportWidth);			return isNaN(perc) ? 0 : perc;		}		public static function get layoutScrollPercentY():Number		{			var perc:Number = layoutScrollY / (layoutHeight - viewportHeight);			return isNaN(perc) ? 0 : perc;		}		public static function get layoutCenterX():int		{			return (viewportWidth / 2) + layoutScrollX;		}				public static function get layoutCenterY():int		{			return (viewportHeight / 2) + layoutScrollY;		}			// --------------------------------------------------	//  Scroll methods	// --------------------------------------------------		public static function setViewport(x:int, y:int, w:int, h:int):void		{			instance._layout.scrollRect = new Rectangle(x, y, w, h);			instance.dispatchEvent(new RoomEditorEvent(RoomEditorEvent.UPDATE_VIEWPORT));		}				public static function setLayoutScroll(x:Number, y:Number):void		{			var rangeX:int = layoutWidth - viewportWidth;			var rangeY:int = layoutHeight - viewportHeight;			setViewport(rangeX * x, rangeY * y, viewportWidth, viewportHeight);		}				public static function setLayoutSize(w:int, h:int):void		{			// set new layout size			instance._layoutWidth = w;			instance._layoutHeight = h;						// configure data for updating scroll offset			var offsetX:int = layoutScrollX;			var offsetY:int = layoutScrollY;			var update:Boolean = false;						// offset X scroll offset to minimum range			if (layoutScrollX + viewportWidth > layoutWidth)			{				offsetX = Math.max(0, layoutWidth - viewportWidth);				update = true;			}						// offset Y scroll offset to minimum range			if (layoutScrollY + viewportHeight > layoutHeight)			{				offsetY = Math.max(0, layoutHeight - viewportHeight);				update = true;			}						// update viewport if offset was adjusted			if (update)			{				setViewport(offsetX, offsetY, viewportWidth, viewportHeight);			}						// notify of change			instance.dispatchEvent(new RoomEditorEvent(RoomEditorEvent.CHANGE_LAYOUT_SIZE));		}	}}class SingletonEnforcer {}