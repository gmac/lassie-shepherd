package com.lassie.shepherd.editors.room.layout.filters{	import com.lassie.shepherd.core.LSSprite;	import com.lassie.shepherd.editors.room.interfaces.IFilterControl;	import com.lassie.shepherd.editors.room.RoomController;	import com.lassie.shepherd.data.room.FilterData;	import com.lassie.shepherd.editors.room.data.FilterDataService;	import com.lassie.shepherd.editors.room.layout.filters.MatrixGrip;	import com.lassie.shepherd.data.room.FilterAxis;	import com.lassie.shepherd.editors.room.events.RoomEditorEvent;	import com.lassie.shepherd.editors.room.display.RoomStyles;	import flash.events.MouseEvent;	import flash.events.Event;	import flash.geom.Point;		public final class FilterControl extends LSSprite implements IFilterControl	{		private var _axis:String;		private var _grip0:MatrixGrip;		private var _grip1:MatrixGrip;		private var _drag:MatrixGrip;		private var _follow:MatrixGrip;		private var _frameHandler:Function;			// --------------------------------------------------	//  Constructor	// --------------------------------------------------				public function FilterControl():void		{			super();						// disable mouse for main layer			mouseEnabled = false;						// add matrix plotters			_grip0 = addGrip("A", 0);			_grip1 = addGrip("B", 1);		}			// --------------------------------------------------	//  Init / uninit	// --------------------------------------------------			protected override function init():void		{			// listen to data for layout changes			RoomController.filterData.addEventListener(RoomEditorEvent.UPDATE_FILTER_LAYOUT, this.handleUpdateLayout);			updateGraph();		}				protected override function uninit():void		{			// stop listening for layout changes			RoomController.filterData.removeEventListener(RoomEditorEvent.UPDATE_FILTER_LAYOUT, this.handleUpdateLayout);		}			// --------------------------------------------------	//  IControlSystem interface	// --------------------------------------------------			public function get active():Boolean		{			return visible;		}				public function activate():void		{			visible = true;		}				public function deactivate():void		{			visible = false;		}				public function updateDisplay():void		{			// nothing		}				public function setLock(val:Boolean):void		{			mouseChildren = !val;		}				public function setVisible(val:Boolean):void		{			visible = val;		}			// --------------------------------------------------	//  Methods	// --------------------------------------------------				private function addGrip(id:String, index:int):MatrixGrip		{			var plotter:MatrixGrip = new MatrixGrip(id, index);			plotter.addEventListener(MouseEvent.MOUSE_DOWN, this.handleGripDown);			addChild(plotter);			return plotter;		}				private function updateData():void		{			var filter:FilterData = RoomController.filterData.activeFilterData;			filter.x0 = _grip0.x;			filter.y0 = _grip0.y;			filter.x1 = _grip1.x;			filter.y1 = _grip1.y;			RoomController.filterData.updateFilterPreview();		}			// --------------------------------------------------	//  Event handlers	// --------------------------------------------------			private function handleGripDown(evt:MouseEvent):void		{			// specify draging and following targets			_drag = MatrixGrip(evt.currentTarget);			_follow = (_drag.index == 0) ? _grip1 : _grip0;						// start dragging grip, listen for release			_drag.startDrag(false);			stage.addEventListener(MouseEvent.MOUSE_UP, this.handleGripRelease);						// select enterframe method based on matrix axis			switch (_axis)			{				case FilterAxis.R:									_frameHandler = this.handleRadialDrag;					break;									case FilterAxis.Y:										_frameHandler = this.handleLinearYDrag;					break;									case FilterAxis.X:										_frameHandler = this.handleLinearXDrag;					break;			}						// add enterframe event to redraw axis while dragging			addEventListener(Event.ENTER_FRAME, _frameHandler);		}				private function handleGripRelease(evt:MouseEvent):void		{			stage.removeEventListener(MouseEvent.MOUSE_UP, this.handleGripRelease);			removeEventListener(Event.ENTER_FRAME, _frameHandler);			_drag.stopDrag();			updateData();		}				private function handleLinearXDrag(evt:Event):void		{			_follow.y = _drag.y;			drawLinearGraph();			updateData();		}				private function handleLinearYDrag(evt:Event):void		{			_follow.x = _drag.x;			drawLinearGraph();			updateData();		}				private function handleRadialDrag(evt:Event):void		{			drawRadialGraph();			updateData();		}				private function handleUpdateLayout(evt:Event):void		{			updateGraph();		}			// --------------------------------------------------	//  Graph drawing	// --------------------------------------------------				private function updateGraph():void		{			// get active data			var filter:FilterData = RoomController.filterData.activeFilterData;			_axis = filter.axis;						// if graph is plotted off-stage (ie: new graph)			if (filter.x0 < 0 && filter.x1 < 0)			{				// plot grips at center of work area				_grip0.x = _grip1.x = RoomController.layoutCenterX;				_grip0.y = _grip1.y = RoomController.layoutCenterY;			}			else			{				// plot grips at data coordinates				_grip0.x = filter.x0;				_grip0.y = filter.y0;				_grip1.x = filter.x1;				_grip1.y = filter.y1;			}						// if axis is radial			if (_axis == FilterAxis.R)			{				// draw radial graph				drawRadialGraph();			}			else			{				// otherwise, draw linear graph				drawLinearGraph();			}		}				private function drawRadialGraph(clear:Boolean=true):void		{			var pt0:Point = new Point(_grip0.x, _grip0.y);			var pt1:Point = new Point(_grip1.x, _grip1.y);						if (clear)			{				graphics.clear();			}						graphics.lineStyle(RoomStyles.FILTER_GRAPH_WEIGHT, RoomStyles.FILTER_GRAPH_COLOR, RoomStyles.FILTER_GRAPH_ALPHA);			graphics.drawCircle(pt0.x, pt0.y, Point.distance(pt0, pt1));			drawLinearGraph(false);		}				private function drawLinearGraph(clear:Boolean=true):void		{			if (clear)			{				graphics.clear();			}						graphics.lineStyle(RoomStyles.FILTER_GRAPH_WEIGHT, RoomStyles.FILTER_GRAPH_COLOR, RoomStyles.FILTER_GRAPH_ALPHA);			graphics.moveTo(_grip0.x, _grip0.y);			graphics.lineTo(_grip1.x, _grip1.y);		}	}}