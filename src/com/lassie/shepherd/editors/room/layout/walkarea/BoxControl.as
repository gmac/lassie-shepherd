package com.lassie.shepherd.editors.room.layout.walkarea{	import flash.display.Sprite;	import flash.events.MouseEvent;	import com.lassie.shepherd.editors.room.layout.walkarea.WalkareaLayout;	import com.lassie.shepherd.editors.room.interfaces.IBoxControl;	import com.lassie.shepherd.data.room.BoxData;	import com.lassie.shepherd.editors.room.layout.walkarea.BoxObject;		public final class BoxControl extends WalkareaLayout implements IBoxControl	{	// --------------------------------------------------	//  Private members	// --------------------------------------------------		private var _selectedBox:BoxObject;			// --------------------------------------------------	//  Constructor	// --------------------------------------------------				public function BoxControl():void		{			super();		}	// --------------------------------------------------	//  Layout methods	// --------------------------------------------------			protected override function updateLayout():void		{			// load new layout when active editor data changes			loadLayout(walkData.boxes);			updateDisplay();		}				public override function loadLayout(boxes:Array):void		{			clearLayout();						for (var j:int=0; j < boxes.length; j++)			{				addBoxLayout(BoxData(boxes[j]));			}		}				public override function clearLayout():void		{			// clear all boxes			while (numChildren > 0)			{				removeBoxLayout(BoxObject(getChildAt(0)));			}			_selectedBox = null;		}				public override function updateDisplay():void		{			if (active && !walkData.showBoxes)			{				deactivate();			}			else if (!active && walkData.showBoxes)			{				activate();			}		}				public function setLock(val:Boolean):void		{			mouseChildren = !val;		}				public function setVisible(val:Boolean):void		{			visible = val;		}			// --------------------------------------------------	//  Methods	// --------------------------------------------------				public function addBox():void		{			// create new node data element			var box:BoxData = new BoxData(walkData.newBoxIndex);						// add element to current walkable nodes data			walkData.boxes.push(box);						// create a new node display object			addBoxLayout(box);		}				private function addBoxLayout(dat:BoxData):void		{			// create a new node display element			var box:BoxObject = new BoxObject(dat);						// listen to node for mouse down			box.addEventListener(MouseEvent.MOUSE_DOWN, this.handleBoxSelect, false, 0, true);						// create a new node display object			addChild(box);		}				public function removeBox():void		{			if (_selectedBox != null)			{				// try to find and remove box's source data				try				{					var index:int = walkData.boxes.indexOf(_selectedBox.data);					walkData.boxes.splice(index, 1);				}				catch(e)				{					// do nothing if the sounce data could not be found for removal				}								// remove active box layout object				removeBoxLayout(_selectedBox);								// clear selected box reference				_selectedBox = null;			}		}				private function removeBoxLayout(box:BoxObject):void		{			// remove box listeners and clear display object			box.removeEventListener(MouseEvent.MOUSE_DOWN, this.handleBoxSelect);			removeChild(box);		}			// --------------------------------------------------	//  Event handlers	// --------------------------------------------------			private function handleBoxSelect(evt:MouseEvent):void		{			// if a box is currently selected			if (_selectedBox != null)			{				// deselect it				_selectedBox.selected = false;			}						// set new selected box			_selectedBox = BoxObject(evt.target);			_selectedBox.selected = true;			setChildIndex(_selectedBox, numChildren-1);						if (!walkData.lockBoxes)			{				if (evt.shiftKey)				{					// start the box resizing					_selectedBox.enableResize(true);					stage.addEventListener(MouseEvent.MOUSE_UP, this.handleStopResize, false, 0, true);				}				else				{					// start the box dragging					_selectedBox.startDrag(false);					stage.addEventListener(MouseEvent.MOUSE_UP, this.handleStopDrag);				}			}		}				private function handleStopDrag(evt:MouseEvent):void		{			// stop listening for mouse up and end drag scenario			stage.removeEventListener(MouseEvent.MOUSE_UP, this.handleStopDrag);			_selectedBox.stopDrag();		}				private function handleStopResize(evt:MouseEvent):void		{			// stop listening for mouse up and end resize scenario			stage.removeEventListener(MouseEvent.MOUSE_UP, this.handleStopResize);			_selectedBox.enableResize(false);		}	}}