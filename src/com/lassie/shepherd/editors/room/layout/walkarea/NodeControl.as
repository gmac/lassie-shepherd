package com.lassie.shepherd.editors.room.layout.walkarea{	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import com.lassie.shepherd.editors.room.interfaces.INodeControl;	import com.lassie.shepherd.editors.room.RoomController;	import com.lassie.shepherd.data.room.NodeData;	import com.lassie.shepherd.ui.RolloverLabel;		public final class NodeControl extends WalkareaLayout implements INodeControl	{		private static const BEAM_WEIGHT:int = 2;		private static const BEAM_COLOR:uint = 0x000000;		private static const BEAM_ALPHA:Number = 0.5;		private const OVERHEAD:int = 8;			// --------------------------------------------------	//  Private members	// --------------------------------------------------				private var _selectedNodes:Array = new Array();		private var _draggingBeams:Boolean=false;		private var _draggingNode:Boolean = false;		private var _dragBeams:Array;		private var _dragCanvas:Sprite;		private var _label:RolloverLabel;		private var _labelEnabled:Boolean=true;	// --------------------------------------------------	//  Constructor	// --------------------------------------------------				public function NodeControl():void		{			super();						// create rollover label			_label = new RolloverLabel();						// disable mouse response to full layer			mouseEnabled = false;						// listen for mouse events within layer			addEventListener(MouseEvent.MOUSE_DOWN, this.handleNodeSelect);			addEventListener(MouseEvent.MOUSE_OVER, this.handleNodeRollOver);			addEventListener(MouseEvent.MOUSE_OUT, this.handleNodeRollOut);		}	// --------------------------------------------------	//  Layout methods	// --------------------------------------------------			protected override function updateLayout():void		{			// load new layout when active editor data changes			RoomController.selectedNode = null;			loadLayout(walkData.nodes);			updateDisplay();		}				public override function loadLayout(nodes:Array):void		{			clearLayout();						for (var j:int=0; j < nodes.length; j++)			{				addNodeLayout(NodeData(nodes[j]));			}						drawBeams();		}				public override function clearLayout():void		{			// clear all nodes			while (numChildren > 0)			{				removeNodeLayout(NodeObject(getChildAt(0)));			}						// clear beam graphics			graphics.clear();						// purge array of selected nodes			_selectedNodes = new Array();		}				public override function updateDisplay():void		{			if (active && !walkData.showNodes)			{				deactivate();			}			else if (!active && walkData.showNodes)			{				activate();			}		}				public function setLock(val:Boolean):void {			mouseChildren = !val;		}				public function setVisible(val:Boolean):void {			visible = val;		}				public function updateSelection():void {			for each (var $node:NodeObject in _selectedNodes) {				$node.redraw();			}		}			// --------------------------------------------------	//  Property getters	// --------------------------------------------------				public function get firstSelected():NodeObject		{			if (_selectedNodes.length > 0)			{				return NodeObject(_selectedNodes[0]);			}			return null;		}			// --------------------------------------------------	//  Methods	// --------------------------------------------------				public function addNode():void		{			// create new node data element			var nodeData:NodeData = new NodeData(walkData.newNodeIndex);						// add element to current walkable nodes data			walkData.nodes.push(nodeData);						// create a new node display object			addNodeLayout(nodeData);		}				private function addNodeLayout(dat:NodeData):void		{			// create a new node display element			var node:NodeObject = new NodeObject(dat);						// assign the child a name reference			node.name = dat.id;						// listen to node for mouse down			//node.addEventListener(MouseEvent.MOUSE_DOWN, this.handleNodeSelect);						// create a new node display object			addChild(node);		}				public function removeNodes():void		{			for (var j:int=0; j < _selectedNodes.length; j++)			{				// pull node reference				var node:NodeObject = NodeObject(_selectedNodes[j]);								// break the node from all of its neighbors				breakFromAll(node);								// try to remove the node's data from source				try				{					var index:int = walkData.nodes.indexOf(node.data);					walkData.nodes.splice(index, 1);				}				catch(e)				{					// do nothing if data was not available				}								// clear node from display				removeNodeLayout(node);			}						// clear list of selected nodes			_selectedNodes = new Array();			RoomController.selectedNode = null;						// update beams drawing			drawBeams();		}				private function removeNodeLayout(node:NodeObject):void		{			//node.removeEventListener(MouseEvent.MOUSE_DOWN, this.handleNodeSelect);			removeChild(node);		}				public function joinNodes():void		{			// loop through selected list			for (var i:int=0; i < _selectedNodes.length; i++)			{				// pull next node in list to operate on				var targetNode:NodeObject = NodeObject(_selectedNodes[i]);								// loop through selected list again to assign neighbors				// start loop cycle at next selected index				for (var j:int = i+1; j < _selectedNodes.length; j++)				{					// pull next selected node to join					var nextNode:NodeObject = NodeObject(_selectedNodes[j]);										// test if target node is already joined with next selected					if (targetNode.neighbors.indexOf(nextNode.id) < 0)					{						// join nodes if not already joined						targetNode.neighbors.push(nextNode.id);						nextNode.neighbors.push(targetNode.id);					}				}			}						drawBeams();		}				public function breakNodes():void		{			// if there are multiple selcted nodes			if (_selectedNodes.length > 1)			{				// loop through selected list				for (var i:int=0; i < _selectedNodes.length; i++)				{					// pull next node in list to operate on					var targetNode:NodeObject = NodeObject(_selectedNodes[i]);										// loop through selected list again to assign neighbors					// start loop cycle at next selected index					for (var j:int = i+1; j < _selectedNodes.length; j++)					{						// pull next selected node to join						var nextNode:NodeObject = NodeObject(_selectedNodes[j]);												// get index of next selected node in neighbors list						var index:int = targetNode.neighbors.indexOf(nextNode.id);												// test if target node joined with next selected						if (index > -1)						{							// break nodes if already joined							targetNode.neighbors.splice(index, 1);							index = nextNode.neighbors.indexOf(targetNode.id);							nextNode.neighbors.splice(index, 1);						}					}				}			}			else if (_selectedNodes.length == 1)			{				// if only a single node, break node from all its neighbors				breakFromAll(firstSelected);			}						drawBeams();		}				private function breakFromAll(node:NodeObject):void		{			while (node.neighbors.length > 0)			{				var n:String = node.neighbors.shift();								try				{					// try to isolate and break this node from its neighbor					var breakNode:NodeObject = NodeObject(getChildByName(n));					var index:int = breakNode.neighbors.indexOf(node.id);					breakNode.neighbors.splice(index, 1);				}				catch(e)				{					// do nothing				}			}		}				private function drawBeams(excludeId:String=""):void		{			// create array to hold drawn beam references			var drawn:Array = new Array();						// clear graphics and set line style			graphics.clear();			graphics.lineStyle(BEAM_WEIGHT, BEAM_COLOR, BEAM_ALPHA);						// loop through node data.			// end at second to last node since all connections will be drawn before the final node			for (var i:int=0; i < numChildren-1; i++)			{				var startNode:NodeObject = NodeObject(getChildAt(i));								// if this node is not specified as the exclude				if (startNode.id != excludeId)				{					// loop through each of node's neighbors					for (var j:int=0; j < startNode.neighbors.length; j++)					{						// get ID of neighbor node						var endId:String = startNode.neighbors[j];												// if neighbor node is not marked as the exclude						if (endId != excludeId)						{							// if beam to neighbor has not already been drawn							if (drawn.indexOf(endId +"-"+ startNode.id) < 0)							{								// get end node's data reference								var endNode:NodeObject = NodeObject(getChildByName(endId));																// draw beam								graphics.moveTo(startNode.x, startNode.y);								graphics.lineTo(endNode.x, endNode.y);																// add reference to drawn line								drawn.push(startNode.id +"-"+ endId);							}						}						// end if's					}					//end for				}				// end if			}			//end for		}				private function deselectAll():void		{			for (var j:int=0; j < _selectedNodes.length; j++)			{				NodeObject(_selectedNodes[j]).selected = false;			}		}			// --------------------------------------------------	//  Live drawing of beams while dragging	// --------------------------------------------------				private function setDragBeams(node:NodeObject):void		{			// redraw all beams without dragging node			drawBeams(node.id);						// create a list of static beam end-points			_dragBeams = new Array();						// loop through dragging node neighbors and collect references			for (var j:int=0; j < node.neighbors.length; j++)			{				var drawTo:NodeObject = NodeObject(getChildByName(node.neighbors[j]));								if (drawTo != null)				{					_dragBeams.push(drawTo);				}			}						if (_dragBeams.length > 0)			{				// create canvas to draw dragging beams into				_dragCanvas = new Sprite();				_dragCanvas.mouseEnabled = false;				addChildAt(_dragCanvas, 0);								// flag beam-drag mode as active				_draggingBeams = true;			}		}				private function clearDragBeams():void		{			if (_draggingBeams)			{				// update beam-drag status				_draggingBeams = false;								// clear the drawing canvas				removeChild(_dragCanvas);				_dragCanvas = null;								// clear list of updating beam displays				_dragBeams = null;			}			// redraw full display			drawBeams();		}			// --------------------------------------------------	//  Node label methods	// --------------------------------------------------				private function setNameLabel(node:NodeObject):void		{			if (_labelEnabled && !_draggingNode && node.data.name != "")			{				_label.label = node.data.name;				setNodeLabel(node);			}			else			{				clearNodeLabel();			}		}				private function setCoordLabel(node:NodeObject):void		{			if (_labelEnabled)			{				_label.label = "x:" + node.x +", y:"+ node.y;				setNodeLabel(node);			}		}				private function setNodeLabel(node:NodeObject):void		{			_label.x = node.x;			_label.y = node.y - OVERHEAD;							if (!this.contains(_label))			{				addChild(_label);			}		}				private function clearNodeLabel():void		{			if (this.contains(_label))			{				removeChild(_label);			}		}			// --------------------------------------------------	//  Event handlers	// --------------------------------------------------			private function handleNodeSelect(evt:MouseEvent):void		{			// isolate target (clicked) node			var targetNode:NodeObject = NodeObject(evt.target);						// if shift was pressed while selecting			// and if target node was not selected			if (evt.shiftKey && !targetNode.selected)			{				targetNode.selected = true;				_selectedNodes.push(targetNode);			}			// if sheft key and target node IS selected			else if (evt.shiftKey && targetNode.selected)			{				targetNode.selected = false;				_selectedNodes.splice(_selectedNodes.indexOf(targetNode), 1);			}			// otherwise, if shift key was not pressed			else if (!evt.shiftKey)			{				// deselect all nodes and set the new node as the sole selection				deselectAll();				targetNode.selected = true;				_selectedNodes = [targetNode];			}						// if shift is not held and selection process resolved with only one node selected			if (!evt.shiftKey && _selectedNodes.length == 1 && !walkData.lockNodes)			{				// set beam drawing targets				setDragBeams(targetNode);								// update display while dragging				addEventListener(Event.ENTER_FRAME, this.handleDragNode);				_draggingNode = true;								// start the node dragging				targetNode.startDrag(false);				stage.addEventListener(MouseEvent.MOUSE_UP, this.handleNodeStopDrag);			}						// if there is only a single node selected			if (_selectedNodes.length == 1)			{				// push its data into the room interface				RoomController.selectedNode = targetNode.data;			}			else			{				// otherwise, clear interface data				RoomController.selectedNode = null;			}		}				private function handleNodeStopDrag(evt:MouseEvent):void		{			// stop listening for mouse up and end the drag scenario			removeEventListener(Event.ENTER_FRAME, this.handleDragNode);			stage.removeEventListener(MouseEvent.MOUSE_UP, this.handleNodeStopDrag);			firstSelected.stopDrag();			clearDragBeams();			// reset node name label			_draggingNode = false;			setNameLabel(firstSelected);		}				private function handleDragNode(evt:Event):void		{			// if dragging beams display along with node			if (_draggingBeams)			{				// clear dragging-beam canvas				_dragCanvas.graphics.clear();				_dragCanvas.graphics.lineStyle(BEAM_WEIGHT, BEAM_COLOR, BEAM_ALPHA);								// get reference to actively dragging node				var targetNode:NodeObject = firstSelected;								// loop through static beam end-points and redraw display				for (var j:int=0; j < _dragBeams.length; j++)				{					_dragCanvas.graphics.moveTo(targetNode.x, targetNode.y);					_dragCanvas.graphics.lineTo(_dragBeams[j].x, _dragBeams[j].y);				}			}						// show noode coordinate label			setCoordLabel(firstSelected);		}				private function handleNodeRollOver(evt:MouseEvent):void		{			setNameLabel(NodeObject(evt.target));		}				private function handleNodeRollOut(evt:MouseEvent):void		{			clearNodeLabel();		}	}}