package com.lassie.shepherd.editors.room.layout.layering{	import flash.display.Sprite;	import flash.events.MouseEvent;	import flash.geom.Point;	import com.lassie.shepherd.editors.room.interfaces.ITarget;	import com.lassie.shepherd.editors.room.interfaces.ILayer;	import com.lassie.shepherd.editors.room.events.RoomEditorEvent;	import com.lassie.player.geom.GeomUtil;		internal final class TargetObject extends Sprite implements ITarget	{		private const TARGET_RADIUS:int = 4;				private var _layerTarget:ILayer;		private var _binding:Boolean = false;		private var _turning:Boolean = false;		private var _turnView:int = 0;				public function TargetObject():void		{			super();						x=100;			y=100;			_redraw();						addEventListener(MouseEvent.MOUSE_DOWN, this.handleMouseDown, false, 0, true);		}				public function dispose():void		{			_layerTarget = null;			removeEventListener(MouseEvent.MOUSE_DOWN, this.handleMouseDown);			parent.removeChild(this);		}				private function _redraw($active:Boolean=true):void {			// draw target display			_binding = !$active;			graphics.clear();			graphics.lineStyle(1, 0x000000, 1);			graphics.beginFill(0xFFFFFF, 0.75);			graphics.moveTo(0, -TARGET_RADIUS);			graphics.lineTo(15, 0);			graphics.lineTo(0, TARGET_RADIUS);			graphics.endFill();			graphics.beginFill($active ? 0x00CCFF : 0xCCCCCC, 1);			graphics.drawCircle(0, 0, TARGET_RADIUS);			graphics.endFill();		}				public function get layerId():String		{			if (!!_layerTarget) {				return _layerTarget.id;			}			return "";		}				public function setLayerTarget(layer:ILayer):void		{			if (!_layerTarget) {				turnView = layer.activePhaseData.turnTo;				_layerTarget = layer;			}		}				public function plot(xpos:int, ypos:int):void {			x = xpos;			y = ypos;		}				public function setTargetStatus($active:Boolean, $turn:int=0):void {			_redraw($active);			if ($turn > 0) turnView = $turn;		}				public function updateTurn():void {			var $degrees:Number = GeomUtil.angleDegrees(new Point(x, y), new Point(parent.mouseX, parent.mouseY));			turnView = GeomUtil.turnView( $degrees );		}				public function get hasBinding():Boolean {			return _binding;		}				public function get turning():Boolean {			return _turning;		}				public function get turnView():int {			return _turnView;		}		public function set turnView($turn:int):void {			_turnView = $turn;			rotation = ($turn * 45) - (3 * 45);			if (!!_layerTarget) _layerTarget.activePhaseData.turnTo = $turn;		}				private function handleMouseDown(evt:MouseEvent):void		{			if (!evt.shiftKey) {				startDrag(false);				_turning = false;			} else {				updateTurn();				_turning = true;			}			stage.addEventListener(MouseEvent.MOUSE_UP, this.handleMouseUp);		}				private function handleMouseUp(evt:MouseEvent):void		{			stage.removeEventListener(MouseEvent.MOUSE_UP, this.handleMouseUp);						if (!_turning) {				stopDrag();			} else {				updateTurn();			}			_turning = false;						// notify of target update			dispatchEvent(new RoomEditorEvent(RoomEditorEvent.UPDATE_LAYER_TARGET));		}	}}