package com.lassie.shepherd.editors.room.layout.layering{	import com.lassie.utils.ObjectUtil;	import com.lassie.shepherd.core.LSSprite;	import com.lassie.shepherd.editors.room.RoomController;	import com.lassie.shepherd.editors.room.interfaces.ITarget;	import com.lassie.shepherd.editors.room.display.AlertMessages;	import com.lassie.shepherd.data.room.*;	import com.lassie.shepherd.data.InteractionData;	import flash.display.Sprite;	import flash.display.MovieClip;	import flash.geom.ColorTransform;	import flash.events.Event;		internal class LayerProperties extends LSSprite	{		private const TINT:ColorTransform = new ColorTransform(0.5, 0.5, 0.5, 1, 0, 50, 255, 0);				private const NO_TINT:ColorTransform = new ColorTransform(1, 1, 1, 1, 0, 0, 0, 0);			// --------------------------------------------------	// Private variables	// --------------------------------------------------		protected var _img:Sprite;		protected var _imgDisplay:MovieClip;		protected var _hit:HitArea;		protected var _reg:Registration;		protected var _tar:ITarget;		protected var _permanentLockId:Boolean = false;		protected var _permanentLockArt:Boolean = false;		protected var _permanentLockPos:Boolean = false;		protected var _allowInteractions:Boolean = false;		protected var _allowNPC:Boolean = false;				private var _data:LayerData;		private var _pdata:PhaseData;		private var _selected:Boolean = false;		private var _editable:Boolean = true;		private var _scaleListener:String = "";		private var _colorListener:String = "";		private var _focusListener:String = "";			// --------------------------------------------------	// Constructor	// --------------------------------------------------				public function LayerProperties(dat:LayerData):void		{			super();						// set source data object			_data = dat;						// create image holder (used by all layer types)			_img = new Sprite();			addChild(_img);						// if there are no phases (initial construction)			if (phaseData.length < 1)			{				// NEW LAYOUT								// add a starting phase				addPhase();			}			else			{				// LOADED LAYOUT								// set active phase data				_pdata = _data.phases[_data.editorPhase];				asset = asset;			}		}				protected override function uninit():void		{			// clear all filter listeners while unitializing 			setFilterListener(_scaleListener, "", this.applyScaleFilter, this.clearScaleFilter);			setFilterListener(_colorListener, "", this.applyColorFilter, this.clearColorFilter);			setFilterListener(_focusListener, "", this.applyFocusFilter, this.clearFocusFilter);		}			// --------------------------------------------------	// Update methods	// --------------------------------------------------				protected function update():void		{			// override in sub-classes		}				protected function updateDisplay():void		{			// update display properties			x = posX;			y = posY;			image = image;			imgX = imgX;			imgY = imgY;			imgW = imgW;			imgH = imgH;			frame = frame;			blend = blend;			bind = bind;			hit = hit;			hitX = hitX;			hitY = hitY;			hitW = hitW;			hitH = hitH;			hitShape = hitShape;			rotate = rotate;			scale = scale;			color = color;			focus = focus;			// plot floor target			_tar.plot(floorX, floorY);			_tar.setTargetStatus(bind == "", _pdata.turnTo);			setSelectedDisplay(_selected);		}			// --------------------------------------------------	// DATA / PHASE methods	// --------------------------------------------------				/**		* Array of phase data [read-only]		*/		public function get data():LayerData		{			return _data;		}				/**		* Array of phase data [read-only]		*/		public function get phaseData():Array		{			return _data.phases;		}				/**		* Active phase's source data [read-only]		*/		public function get activePhaseData():PhaseData		{			return _pdata;		}				/**		* Active phase number		*/		public function get activePhase():int		{			return _data.editorPhase;		}		public function set activePhase(val:int):void		{			_data.editorPhase = Math.max(0, Math.min(val, phaseData.length));			_pdata = PhaseData(phaseData[_data.editorPhase]);			update();		}				/**		* get list of phase names		*/		public function get phaseList():Array		{			var list:Array = new Array();						for (var j:int = 0; j < phaseData.length; j++)			{				list.push(PhaseData(phaseData[j]).id);			}						return list;		}				public function addPhase():void		{			// get current number of phases			var preCount:int = phaseData.length;						// create new phase, add to data, and update index			_pdata = PhaseFactory.create(type, preCount);			phaseData.push(_pdata);			_data.editorPhase = preCount;			// update phase if this was NOT its initial construction			if (preCount > 0)			{				update();			}		}				public function clonePhase():void		{			// create copy of phase data			_pdata = RoomDataParser.toPhaseData(ObjectUtil.clone(_pdata));			_pdata.id += "Copy";						// add to record list			phaseData.push(_pdata);			_data.editorPhase = phaseData.length-1;						// update layer.			update();		}				public function deletePhase():void		{			// if layer has more than one phase			if (phaseData.length > 1)			{				// delete current phase				phaseData.splice(activePhase, 1);				activePhase -= 1;			}			else			{				lsServices.alert(AlertMessages.CANNOT_DELETE_ONLY_PHASE);			}		}	// --------------------------------------------------	// Selection methods	// --------------------------------------------------				/**		* Selected status [read-only]		*/		public function get selected():Boolean		{			return _selected;		}				protected function setAsSelected(sel:Boolean):void		{			// property setter is isolated from display setter to allow			// the display to be changed without altering selection status			_selected = sel;			setSelectedDisplay(sel);		}				private function setSelectedDisplay(sel:Boolean):void		{			// tint and untint the layer graphics			if (sel)			{				// tint layer display				_hit.transform.colorTransform = TINT;				_img.transform.colorTransform = new ColorTransform(0.8, 0.8, 0.8, 1, 0, 20, 51, 0);				_tar.visible = true;			}			else			{				// clear display tint				_hit.transform.colorTransform = NO_TINT;				_img.transform.colorTransform = NO_TINT;				_tar.visible = false;			}						// if selecting and hit area is set to show			if (sel && hit)			{				// show rect display				_hit.visible = true;			}			// if deselecting and layer has an asset			else if (!sel && asset != "")			{				// hide rect display				_hit.visible = false;			}						// if layer display is visible			if (vis && (hit || _imgDisplay != null))			{				// toggle reg-point visibility with selection				_reg.visible = sel;								// apply no tint to reg-point				_reg.transform.colorTransform = NO_TINT;			}			else			{				// if layer is hidden, always show reg-point				_reg.visible = true;								// tint and untint reg-point with selection				_reg.transform.colorTransform = sel ? TINT : NO_TINT;			}		}			// --------------------------------------------------	// LAYER EDITOR properties	// --------------------------------------------------				/**		* Type [read only]		*/		public function get type():String		{			return _data.type;		}				/**		* Layer ID name		*/		public function get id():String		{			return _data.id;		}		public function set id(val:String):void		{			_data.id = val;		}				/**		* Lock layer ID name		*/		public function get lockId():Boolean		{			return _data.lockId;		}		public function set lockId(val:Boolean):void		{			_data.lockId = val;		}				/**		* Image asset class		*/		public function get asset():String		{			return _data.asset;		}		public function set asset(val:String):void		{			if (val.indexOf(":") > 0)			{				try				{					// attempt to pull and set image from the library					var libAsset:MovieClip = lsLibrary.getMovieClipByAddress(val);					setImageDisplay(libAsset);				}				catch(e)				{					val = "";					clearImage();					lsServices.alert(AlertMessages.INVALID_LAYER_MEDIA);				}			}			else			{				val = "";				clearImage();			}			_data.asset = val;		}				/**		* Layer depth within room layering		*/		public function get depth():int		{			return parent.getChildIndex(this);		}		public function set depth(val:int):void		{			_data.depth = Math.min(val, parent.numChildren-1);			parent.setChildIndex(this, _data.depth);		}				/**		* Common layer actions		*/		public function get layerActions():Array		{			return _data.actions;		}		public function set layerActions(val:Array):void		{			_data.actions = val;		}				/**		* Layer position lock		*/		public function get locked():Boolean		{			return _data.locked;		}		public function set locked(val:Boolean):void		{			_data.locked = val;		}				public function get permanentLockId():Boolean		{			return _permanentLockId;		}				public function get permanentLockArt():Boolean		{			return _permanentLockArt;		}				public function get permanentLockPos():Boolean		{			return _permanentLockPos;		}				/**		* Allow layer interactions [read only]		*/		public function get allowInteractions():Boolean		{			return _allowInteractions;		}				/**		* Allow layer to be set as an NPC [read only]		*/		public function get allowNPC():Boolean		{			return _allowNPC;		}				/**		* Enable layer as an NPC		*/		public function get npc():Boolean		{			return _data.npc;		}				public function set npc(val:Boolean):void		{			_data.npc = val;		}		/**		* Allow editing		*/		public function get editable():Boolean		{			return _editable;		}				public function set editable(enable:Boolean):void		{			_editable = mouseChildren = enable;			if (selected)			{				setSelectedDisplay(enable);			}						if (_hit != null)			{				_hit.visible = enable ? hit : false;			}						var $floorPt:Boolean = enable ? selected : true;			_tar.visible = ($floorPt && bind == "");		}				/**		* Visibility		*/		public function get vis():Boolean		{			return _data.show;		}		public function set vis(val:Boolean):void		{			if (!val)			{				// hide hit and image is disabling				_hit.visible = _img.visible = val;			}			else			{				// olny show hit / image again if they are each enabled				if (hit) _hit.visible = true;				if (image) _img.visible = true;			}			_data.show = val;			_reg.transform.colorTransform = val ? NO_TINT : TINT;		}				/**		* Selected hilite		*/		public function get hilite():Boolean		{			return _data.hilite;		}		public function set hilite(val:Boolean):void		{			_data.hilite = val;		}			// --------------------------------------------------	// PHASE ID	// --------------------------------------------------		/**		* phase id		*/		public function get phase():String		{			return _pdata.id;		}		public function set phase(val:String):void		{			_pdata.id = val;		}				/**		* Lock phase ID name		*/		public function get lockPhaseId():Boolean		{			return _pdata.lockId;		}		public function set lockPhaseId(val:Boolean):void		{			_pdata.lockId = val;		}				/**		* Phase ordering		*/		public function get numPhases():int		{			return phaseData.length;		}				public function get phaseNum():int		{			return _data.editorPhase;		}		public function set phaseNum(val:int):void		{			val = Math.max(0, Math.min(val, numPhases-1));						if (val != phaseNum)			{				var dat:PhaseData = phaseData.splice(phaseNum, 1)[0] as PhaseData;				phaseData.splice(val, 0, dat);				activePhase = val;			}		}			// --------------------------------------------------	// POSITION-plotting properties	// --------------------------------------------------				/**		* Layer x-position		*/		public override function set x(pos:Number):void {			super.x = pos;			_pdata.x = pos;		}		/**		* Layer y-position		*/		public override function set y(pos:Number):void {			super.y = pos;			_pdata.y = pos;		}				/**		* Layer x-position		*/		public function get posX():int {			return _pdata.x;		}		public function set posX(val:int):void {			_pdata.x = val;		}				/**		* Layer y-position		*/		public function get posY():int {			return _pdata.y;		}		public function set posY(val:int):void {			_pdata.y = val;		}				/**		* Floor x-position		*/		public function get floorX():int {			return _pdata.floorX;		}		public function set floorX(val:int):void {			_pdata.floorX = val;		}				/**		* Floor y-position		*/		public function get floorY():int {			return _pdata.floorY;		}		public function set floorY(val:int):void {			_pdata.floorY = val;		}				/**		* Grid binding point		*/		public function get bind():String {			return _pdata.bind;		}		public function set bind(val:String):void {			_pdata.bind = val;			_tar.setTargetStatus(val == "");		}			// --------------------------------------------------	// IMAGE properties	// --------------------------------------------------				/**		* Sets image display with new movieClip		*/		private function setImageDisplay(imgClip:MovieClip):void		{			// clear all existing image media			clearImage();						// if new image is a valid graphic clip			if (imgClip != null)			{				// set as the new layer image				_imgDisplay = imgClip;				_imgDisplay.gotoAndStop(frame);				_imgDisplay.alpha = opacity;				_img.addChild(_imgDisplay);				blend = blend;				opacity = opacity;				applyColorFilter();				applyFocusFilter();			}		}				/**		* Clears the current image display		*/		private function clearImage():void		{			// remove all children of image sprite			while (_img.numChildren > 0)			{				_img.removeChildAt(0);			}						// clear display reference			_imgDisplay = null;		}				/**		* Image asset enabled		*/		public function get image():Boolean		{			return _pdata.image;		}		public function set image(val:Boolean):void		{			_pdata.image = val;			_img.visible = val;		}				/**		* Image's current frame [read-only]		*/		public function get imageFrame():int		{			if (_imgDisplay != null)			{				 return _imgDisplay.currentFrame;			}			return -1;		}				/**		* Image's labeled frames [read-only]		*/		public function get imageFrameLabels():Array		{			if (_imgDisplay != null)			{				 return _imgDisplay.currentLabels;			}			return new Array();		}		/**		* Image frame		*/		public function get frame():int {			return _pdata.frame;		}		public function set frame(num:int):void		{			_pdata.frame = num;						// if layer has an image display			if (_imgDisplay != null)			{				// update display's current frame				_imgDisplay.gotoAndStop(num);			}		}				/**		* Image blend mode		*/		public function get blend():String {			return _pdata.blend;		}		public function set blend(val:String):void		{			_pdata.blend = val;						// if layer has an image display			if (_imgDisplay != null)			{				// update display's current frame				_imgDisplay.blendMode = val;			}		}				/**		* Image x-position		*/		public function get imgX():int {			return _pdata.imgX;		}		public function set imgX(val:int):void {			_pdata.imgX = val;			_img.x = val;		}				/**		* Image y-position		*/		public function get imgY():int {			return _pdata.imgY;		}		public function set imgY(val:int):void {			_pdata.imgY = val;			_img.y = val;		}				/**		* Image scaleX		*/		public function get imgW():Number {			return _pdata.imgW;		}		public function set imgW(val:Number):void {			_pdata.imgW = val;			_img.scaleX = val;		}				/**		* Image scaleY		*/		public function get imgH():Number {			return _pdata.imgH;		}		public function set imgH(val:Number):void {			_pdata.imgH = val;			_img.scaleY = val;		}				/**		* Actual width and height dimentions of the image.		*/		public function get imgWidth():Number {			return _img.width;		}		public function get imgHeight():Number {			return _img.height;		}				/**		* Image scale		*/		protected function setImageScale(w:Number, h:Number):void {			_pdata.imgW = w;			_pdata.imgH = h;		}				protected function setImagePos(x:int, y:int):void {			_pdata.imgX = x;			_pdata.imgY = y;		}				/**		* Alpha property substitute		*/		public function get opacity():Number {			return _pdata.opacity;		}		public function set opacity(val:Number):void {			_pdata.opacity = val;						// if layer has an image display			if (_imgDisplay != null)			{				// update display's opacity				_imgDisplay.alpha = val;			}		}			// --------------------------------------------------	// HIT AREA properties	// --------------------------------------------------				/**		* Hit area enabled		*/		public function get hit():Boolean		{			return _pdata.hit;		}		public function set hit(val:Boolean):void		{			_pdata.hit = val;			_hit.visible = val;		}				/**		* Hit x-position		*/		public function get hitX():int		{			return _pdata.hitX;		}		public function set hitX(val:int):void		{			_pdata.hitX = val;			_hit.x = val;		}				/**		* Hit y-position		*/		public function get hitY():int		{			return _pdata.hitY;		}		public function set hitY(val:int):void		{			_pdata.hitY = val;			_hit.y = val;		}				/**		* Hit width		*/		public function get hitW():int		{			return _pdata.hitW;		}		public function set hitW(val:int):void		{			_pdata.hitW = val;			_hit.redraw(val, hitH);		}				/**		* Hit height		*/		public function get hitH():int		{			return _pdata.hitH;		}		public function set hitH(val:int):void		{			_pdata.hitH = val;			_hit.redraw(hitW, val);		}				/**		* Hit shape		*/		public function get hitShape():String		{			return _pdata.hitShape;		}		public function set hitShape(val:String):void		{			_pdata.hitShape = val;			_hit.round = (val == LayerHitShapes.ROUND);			_hit.redraw(hitW, hitH);		}				/**		* Hit size: set without display update		*/		protected function setHitSize(w:int, h:int):void		{			_pdata.hitW = w;			_pdata.hitH = h;		}				/**		* Hit position: set without display update		*/		protected function setHitPos(xpos:int, ypos:int):void		{			_pdata.hitX = xpos;			_pdata.hitY = ypos;		}			// --------------------------------------------------	// GENERAL properties	// --------------------------------------------------				/**		* Hover title		*/		public function get title():String		{			return _pdata.title;		}		public function set title(val:String):void		{			_pdata.title = val;		}				/**		* Image frame		*/		public function get cursor():String		{			return _pdata.cursor;		}		public function set cursor(val:String):void		{			_pdata.cursor = val;		}				/**		* rate of movement		*/		public function get rate():int		{			return _pdata.rate;		}		public function set rate(val:int):void		{			_pdata.rate = val;		}				/**		* onclick action		*/		public function get onclick():int		{			return _pdata.onclick;		}		public function set onclick(val:int):void		{			_pdata.onclick = val;		}				/**		* view angle		*/		public function get angle():int		{			return _pdata.angle;		}		public function set angle(val:int):void		{			_pdata.angle = val;		}				/**		* layer rotation		*/		public function get rotate():int		{			return _pdata.rotate;		}		public function set rotate(val:int):void		{			_pdata.rotate = val;			rotation = val;		}				/**		* dialogue color		*/		public function get diaColor():uint		{			return _pdata.diaColor;		}		public function set diaColor(val:uint):void		{			_pdata.diaColor = val;		}				/**		* Layer floating enabled		*/		public function get float():Boolean		{			return _pdata.float;		}		public function set float(val:Boolean):void		{			_pdata.float = val;		}				/**		* Mouse enabled		*/		public function get mouse():Boolean		{			return _pdata.mouse;		}		public function set mouse(val:Boolean):void		{			_pdata.mouse = val;		}				/**		* Bitmap caching enabled		*/		public function get cache():Boolean		{			return _pdata.cache;		}		public function set cache(val:Boolean):void		{			_pdata.cache = val;		}			// --------------------------------------------------	// FILTER MATRIX properties	// --------------------------------------------------				/**		* Scale filter		*/		public function get scale():String		{			return _pdata.scale;		}		public function set scale(val:String):void		{			_pdata.scale = val;			previewScale = previewScale;		}				/**		* Color filter		*/		public function get color():String		{			return _pdata.color;		}		public function set color(val:String):void		{			_pdata.color = val;			previewColor = previewColor;		}				/**		* Speed filter		*/		public function get speed():String		{			return _pdata.speed;		}		public function set speed(val:String):void		{			_pdata.speed = val;		}				/**		* Focus filter		*/		public function get focus():String		{			return _pdata.focus;		}		public function set focus(val:String):void		{			_pdata.focus = val;			previewFocus = previewFocus;		}				/**		* Preview scale		*/		public function get previewScale():Boolean		{			return _pdata.previewScale;		}		public function set previewScale(val:Boolean):void		{			var prev:Boolean = previewScale;			_pdata.previewScale = val;			_scaleListener = setFilterListener(_scaleListener, scale, this.applyScaleFilter, this.clearScaleFilter);						if (prev && !val)			{				clearScaleFilter();			}			else if (!prev && val)			{				applyScaleFilter();			}		}				/**		* Preview color		*/		public function get previewColor():Boolean		{			return _pdata.previewColor;		}		public function set previewColor(val:Boolean):void		{			var prev:Boolean = previewColor;			_pdata.previewColor = val;			_colorListener = setFilterListener(_colorListener, color, this.applyColorFilter, this.clearColorFilter);						if (prev && !val)			{				clearColorFilter();			}			else if (!prev && val)			{				applyColorFilter();			}		}				/**		* Preview focus		*/		public function get previewFocus():Boolean		{			return _pdata.previewFocus;		}		public function set previewFocus(val:Boolean):void		{			var prev:Boolean = previewFocus;			_pdata.previewFocus = val;			_focusListener = setFilterListener(_focusListener, focus, this.applyFocusFilter, this.clearFocusFilter);						if (prev && !val)			{				clearFocusFilter();			}			else if (!prev && val)			{				applyFocusFilter();			}		}			// --------------------------------------------------	// BACKGROUND-specific properties	// --------------------------------------------------				/**		* X-scroll rate		*/		public function get scrollMarginL():Number		{			return _pdata.marginL;		}		public function set scrollMarginL(val:Number):void		{			_pdata.marginL = val;		}				/**		* Y-scroll rate		*/		public function get scrollMarginR():Number		{			return _pdata.marginR;		}		public function set scrollMarginR(val:Number):void		{			_pdata.marginR = val;		}				/**		* X-scroll margin		*/		public function get scrollMarginT():int		{			return _pdata.marginT;		}		public function set scrollMarginT(val:int):void		{			_pdata.marginT = val;		}				/**		* Y-scroll margin		*/		public function get scrollMarginB():int		{			return _pdata.marginB;		}		public function set scrollMarginB(val:int):void		{			_pdata.marginB = val;		}			// --------------------------------------------------	// PLANE-specific properties	// --------------------------------------------------				/**		* Parallax		*/		public function get parallax():String		{			return _pdata.parallax;		}		public function set parallax(val:String):void		{			_pdata.parallax = val;		}			// --------------------------------------------------	// Layer Interactions	// --------------------------------------------------				/**		* Interactions list		*/		public function get actions():Array		{			return _pdata.actions;		}		public function set actions(val:Array):void		{			_pdata.actions = val;		}				/**		* Active interaction data		*/		public function get actionsIndex():int		{			_pdata.actionsIndex = Math.max((actions.length < 1 ? -1 : 0), Math.min(_pdata.actionsIndex, actions.length-1));			return _pdata.actionsIndex;		}		public function set actionsIndex(val:int):void		{			_pdata.actionsIndex = Math.max((actions.length < 1 ? -1 : 0), Math.min(val, actions.length-1));		}			// --------------------------------------------------	// Item Interactions	// --------------------------------------------------				/**		* Interactions list		*/		public function get items():Array		{			return _pdata.items;		}		public function set items(val:Array):void		{			_pdata.items = val;		}				/**		* Active item data		*/		public function get itemsIndex():int		{			_pdata.itemsIndex = Math.max((items.length < 1 ? -1 : 0), Math.min(_pdata.itemsIndex, items.length-1));			return _pdata.itemsIndex;		}		public function set itemsIndex(val:int):void		{			_pdata.itemsIndex = Math.max((items.length < 1 ? -1 : 0), Math.min(val, items.length-1));		}			// --------------------------------------------------	// Matrix filters	// --------------------------------------------------			// Scale Filter				protected function applyScaleFilter(evt:Event=null):void		{			if (scale != "" && scale != "_grid")			{				var scaleData:FilterData = RoomController.filterData.getFilterById(scale);								if (scaleData == null)				{					scale = "";					clearScaleFilter();				}				else if (previewScale)				{					scaleX = scaleY = MatrixFilters.getScale(scaleData, x, y);				}			}		}				private function clearScaleFilter():void		{			scaleX = scaleY = 1;		}				// Color Filter				protected function applyColorFilter(evt:Event=null):void		{			if (color != "" && scale != "_grid")			{				var colorData:FilterData = RoomController.filterData.getFilterById(color);								if (colorData == null)				{					color = "";					clearColorFilter();				}				else if (previewColor && _imgDisplay != null)				{					_imgDisplay.transform.colorTransform = MatrixFilters.getColor(colorData, x, y);				}			}		}				private function clearColorFilter():void		{			if (_imgDisplay != null) _imgDisplay.transform.colorTransform = NO_TINT;		}				// Focus Filter				protected function applyFocusFilter(evt:Event=null):void		{			if (focus != "" && scale != "_grid")			{				var focusData:FilterData = RoomController.filterData.getFilterById(focus);								if (focusData == null)				{					focus = "";					clearFocusFilter();				}				else if (previewFocus && _imgDisplay != null)				{					_imgDisplay.filters = new Array(MatrixFilters.getBlur(focusData, x, y));				}			}		}				private function clearFocusFilter():void		{			if (_imgDisplay != null) _imgDisplay.filters = new Array();		}				// Filter listeners				private function setFilterListener(current:String, replace:String, applyMethod:Function, clearMethod:Function):String		{			if (current != "" && current != "_grid" && current != replace)			{				// clear existing event listener				RoomController.filterData.removeEventListener(current, applyMethod);				clearMethod();			}						if (replace != "" && replace != "_grid" && current != replace)			{				// add new event listener				RoomController.filterData.addEventListener(replace, applyMethod, false, 0, true);				applyMethod();			}			return replace;		}	}}