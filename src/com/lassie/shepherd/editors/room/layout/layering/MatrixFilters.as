package com.lassie.shepherd.editors.room.layout.layering{	import fl.motion.Color;	import flash.geom.Point;	import flash.geom.ColorTransform;	import flash.filters.BlurFilter;	import com.lassie.shepherd.data.room.*;		internal final class MatrixFilters	{		public static function getScale(filter:FilterData, x:Number, y:Number):Number		{			return getRange(filter, filter.scale0, filter.scale1, new Point(x, y));		}				public static function getColor(filter:FilterData, x:Number, y:Number):ColorTransform		{			//trace("\n***");						var c0:Number = filter.color0;			var v0:Number = filter.tint0;			var m0:Number = 1 - v0;			var r0:Number = (c0 >> 16 & 0xFF) * v0;			var g0:Number = (c0 >> 8 & 0xFF) * v0;			var b0:Number = (c0 >> 0 & 0xFF) * v0;						//trace(r0 +", "+ g0 +", "+ b0 +" x "+ m0);						var c1:Number = filter.color1;			var v1:Number = filter.tint1;			var m1:Number = 1 - v1;			var r1:Number = (c1 >> 16 & 0xFF) * v1;			var g1:Number = (c1 >> 8 & 0xFF) * v1;			var b1:Number = (c1 >> 0 & 0xFF) * v1;						//trace(r1 +", "+ g1 +", "+ b1 +" x "+ m1);						var p:Number = getRatio(filter, new Point(x, y));			var m:Number = m0 + ((m1 - m0) * p);			var r:Number = r0 + ((r1 - r0) * p);			var g:Number = g0 + ((g1 - g0) * p);			var b:Number = b0 + ((b1 - b0) * p);						//trace(r +", "+ g +", "+ b +" x "+ m);						return new ColorTransform(m, m, m, 1, r, g, b, 0);		}				public static function getBlur(filter:FilterData, x:Number, y:Number):BlurFilter		{			var blur:Number = getRange(filter, filter.blur0, filter.blur1, new Point(x, y));			return new BlurFilter(blur, blur, 2);		}				public static function getRange($f:FilterData, $a:Number, $b:Number, $c:Point):Number		{			return $a + (($b - $a) * getRatio($f, $c));		}				public static function getRatio(f:FilterData, c:Point):Number		{			var p0:Point = new Point(f.x0, f.y0);			var p1:Point = new Point(f.x1, f.y1);			var whole:Number, part:Number;						switch(f.axis)			{				case FilterAxis.X:					whole = p1.x - p0.x;					part = c.x -  p0.x;					break;									case FilterAxis.Y:					whole = p1.y - p0.y;					part = c.y -  p0.y;					break;				case FilterAxis.R:					whole = Point.distance(p0, p1);					part = Point.distance(p0, c);					break;			}						return Math.max(0, Math.min(part / whole, 1));		}	}}