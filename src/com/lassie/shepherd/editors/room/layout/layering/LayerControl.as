package com.lassie.shepherd.editors.room.layout.layering{	import com.lassie.shepherd.core.LSSprite;	import com.lassie.shepherd.editors.room.interfaces.ILayerControl;	import com.lassie.shepherd.editors.room.RoomController;	import com.lassie.shepherd.data.room.LayerData;	import com.lassie.shepherd.data.room.LayerTypes;	import com.lassie.shepherd.data.room.RoomDataParser;	import com.lassie.shepherd.editors.room.interfaces.ILayer;	import com.lassie.shepherd.editors.room.layout.layering.LayerFactory;	import com.lassie.shepherd.editors.room.layout.layering.LayerObject;	import com.lassie.shepherd.editors.room.display.AlertMessages;	import com.lassie.utils.ObjectUtil;		public final class LayerControl extends LSSprite implements ILayerControl	{		private var _active:Boolean = false;			// --------------------------------------------------	//  Constructor	// --------------------------------------------------			public function LayerControl():void		{			super();						// disable mouse on main container			mouseEnabled = false;		}	// --------------------------------------------------	//  Initialization	// --------------------------------------------------			protected override function init():void		{			// if room has layout data			if (RoomController.layerData.length > 0)			{				// load room layout				loadLayout(RoomController.layerData);			}			else			{				// create default layout with background layer only				addLayer(LayerTypes.BACKGROUND);			}		}				protected override function uninit():void		{			clearLayout();		}			// --------------------------------------------------	//  IControlSystem methods	// --------------------------------------------------			public function get active():Boolean		{			return _active;		}				public function activate():void		{			enableLayout(true);		}				public function deactivate():void		{			enableLayout(false);		}				public function updateDisplay():void		{			// nothing		}				private function enableLayout(enable:Boolean):void		{			_active = enable;						for (var j:int = 0; j < numChildren; j++)			{				LayerObject(getChildAt(j)).editable = enable;			}		}			// --------------------------------------------------	//  Interface Methods	// --------------------------------------------------				public function addLayer(type:String):void		{			// prevent operation if requested layer is a character			// and if layout already has a character layer			if (type == LayerTypes.CHARACTER && hasCharacterLayer())			{				lsServices.alert(AlertMessages.CANNOT_ADD_MULTIPLE_CHARACTERS);			}			else			{				// create new layer				var layer:LayerObject = LayerFactory.create(type);					// add layer to display				addChild(layer);								// update layers list				listLayers();								// select newly created layer				layer.select();			}		}				public function cloneLayer():void		{			var sel:LayerObject = RoomController.selectedLayer as LayerObject;			var dat:LayerData = RoomDataParser.toLayerData(ObjectUtil.clone(sel.data));			dat.id += "Copy";						var layer:LayerObject = LayerFactory.create(dat.type, dat);			addChild(layer);			listLayers();			layer.select();		}				public function removeLayer():void		{			var sel:LayerObject = RoomController.selectedLayer as LayerObject;			if (allowLayerRemoval(sel.type))			{				// remove child object				removeChild(sel);				RoomController.selectedLayer = null;								// update layers list				listLayers();								// select new layer at zero-index				LayerObject(getChildAt(0)).select();			}		}				public function selectLayerAt(index:int):void		{			try			{				LayerObject(getChildAt(index)).select();			}			catch(e)			{				// could not select specified layer			}		}				public function shiftLayerTo(index:int):void		{			try			{				// set selected layer's index				RoomController.selectedLayer.depth = index;			}			catch(e)			{				// could not set layer's depth			}						// update layers list			listLayers();		}				public function listLayers():void		{			// create array to collect child references			var layers:Array = new Array();						// loop through child objects			for (var j:int = 0; j < numChildren; j++)			{				// add each child object				layers.push(getChildAt(j));			}						// publish display list as a room setting			RoomController.layersList = layers;		}			// --------------------------------------------------	//  Private methods	// --------------------------------------------------				private function loadLayout(dat:Array):void		{			// loop through provided layers			for (var j:int = 0; j < dat.length; j++)			{				// create new layer using layout data				var layer:LayerObject = LayerFactory.create(dat[j].type, dat[j]);					// add layer to display				addChild(layer);			}						// update layers list			listLayers();						// select newly created layer			LayerObject(getChildAt(0)).select();		}				private function clearLayout():void		{			while (numChildren > 0)			{				removeChildAt(0);			}						RoomController.selectedLayer = null;			RoomController.layersList = new Array();		}				private function allowLayerRemoval(type:String):Boolean		{			// check a layer's type before allowing removal						if (type == LayerTypes.BACKGROUND)			{				lsServices.alert(AlertMessages.CANNOT_DELETE_BACKGROUND);				return false;			}			/*else if (type == LayerTypes.CHARACTER)			{				trace("Cannot delete character layer");				return false;			}*/			return true;		}				private function hasCharacterLayer():Boolean		{			// loop through child layers to check for a character layer			for (var j:int = 0; j < numChildren; j++)			{				if (LayerObject(getChildAt(j)).type == LayerTypes.CHARACTER)				{					return true;				}			}			return false;		}	}}