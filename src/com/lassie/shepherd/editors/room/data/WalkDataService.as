package com.lassie.shepherd.editors.room.data{	import flash.events.EventDispatcher;	import com.lassie.shepherd.editors.room.events.RoomEditorEvent;	import com.lassie.shepherd.data.room.*;	import com.lassie.utils.ObjectUtil;		public final class WalkDataService extends EventDispatcher	{		private var _spawn:int=0;		private var _data:Array;		private var _currentDataSet:int=0;			// --------------------------------------------------	//  Constructor	// --------------------------------------------------				public function WalkDataService(dat:Array):void		{			super();			// set source data			_data = dat;						// if no load data was provided			if (_data.length < 1)			{				// create base walkarea				addWalkarea("base");			}			else			{				// otherwise, load saved layout				updateLayout();			}		}			// --------------------------------------------------	//  Get source data	// --------------------------------------------------					public function get data():Array {			return _data;		}				public function clear():void {			_data = new Array();		}			// --------------------------------------------------	//  Control methods	// --------------------------------------------------				public function addWalkarea(id:String=""):void		{			// add new walkarea			_data.push(new WalkareaData(id));						// set current data to newest addition			_currentDataSet = _data.length-1;						// notify layout of update			updateLayout();		}				public function cloneWalkarea():void		{			var rec:WalkareaData = RoomDataParser.toWalkareaData(ObjectUtil.clone(getCurrentData()));			rec.id += "Copy";						_data.push(rec);			_currentDataSet = _data.length-1;						// notify layout of update			updateLayout();		}				public function removeWalkarea(id:String=null):Boolean		{			// if there is only a single walkarea			if (_data.length <= 1)			{				// fail removal				return false;			}			else			{				// remove currently selected dataset				_data.splice(_currentDataSet, 1);								// reset selection to first dataset				_currentDataSet = 0;								// notify layout of update				updateLayout();			}						// notife that oferation was successful			return true;		}				private function updateLayout():void		{			// notify layout of update			dispatchEvent(new RoomEditorEvent(RoomEditorEvent.UPDATE_WALKAREA_LAYOUT));		}			// --------------------------------------------------	//  Active walkarea	// --------------------------------------------------				public function get activeWalkarea():int		{			return _currentDataSet;		}				public function set activeWalkarea(index:int):void		{			// if index is within data range and is not alread active			if (index < _data.length && index != _currentDataSet)			{				// set new selected index				_currentDataSet = index;								// notify layout of update				updateLayout();			}		}				private function getCurrentData():WalkareaData		{			return WalkareaData(_data[_currentDataSet]);		}			// --------------------------------------------------	//  Active walkarea properties	// --------------------------------------------------			/**		* Read-write :		* Walkarea ID		*/		public function get walkareaId():String		{			return getCurrentData().id;		}				public function set walkareaId(id:String):void		{			getCurrentData().id = id;		}				/**		* Read-write :		* Lock walkarea ID		*/		public function get lockWalkareaId():Boolean		{			return getCurrentData().lockId;		}				public function set lockWalkareaId(val:Boolean):void		{			getCurrentData().lockId = val;		}				/**		* Read-write :		* Lock walkarea nodes		*/		public function get lockNodes():Boolean		{			return getCurrentData().lockNodes;		}				public function set lockNodes(val:Boolean):void		{			getCurrentData().lockNodes = val;		}				/**		* Read-write :		* Show walkarea nodes		*/		public function get showNodes():Boolean		{			return getCurrentData().showNodes;		}				public function set showNodes(val:Boolean):void		{			getCurrentData().showNodes = val;		}				/**		* Read-write :		* Lock walkarea boxes		*/		public function get lockBoxes():Boolean		{			return getCurrentData().lockBoxes;		}				public function set lockBoxes(val:Boolean):void		{			getCurrentData().lockBoxes = val;		}				/**		* Read-write :		* Show walkarea boxes		*/		public function get showBoxes():Boolean		{			return getCurrentData().showBoxes;		}				public function set showBoxes(val:Boolean):void		{			getCurrentData().showBoxes = val;		}				/**		* Read-write :		* Walk area active		*/		public function get active():Boolean		{			return getCurrentData().active;		}				public function set active(val:Boolean):void		{			getCurrentData().active = val;		}				/**		* Read-only :		* List of all walkareas		*/		public function get walkareaList():Array		{			// create new list			var list:Array = new Array();						// collect all data ID's within list			for (var j:int = 0; j < _data.length; j++)			{				list.push(_data[j].id);			}						// return list of walkarea IDs			return list;		}			// --------------------------------------------------	//  Nodes	// --------------------------------------------------				public function get newNodeIndex():int		{			return getCurrentData().spawnNode++;		}				public function get nodes():Array		{			return getCurrentData().nodes;		}				public function getNodeById(id:String):NodeData		{			// create local reference to current node data			var nodesList:Array = nodes;						for (var j:int = 0; j < nodesList.length-1; j++)			{				if (NodeData(nodesList[j]).id == id)				{					return NodeData(nodesList[j]);				}			}			return null;		}			// --------------------------------------------------	//  Boxes	// --------------------------------------------------				public function get newBoxIndex():int		{			return getCurrentData().spawnBox++;		}				public function get boxes():Array		{			return getCurrentData().boxes;		}	}}