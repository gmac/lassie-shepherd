/*** SoundObject: sound control framework for ActionScript3.* @author Greg MacWilliam* @version 1.0*//*** Licensed under the MIT License* * Copyright (c) 2009 Greg MacWilliam* * Permission is hereby granted, free of charge, to any person obtaining a copy of* this software and associated documentation files (the "Software"), to deal in* the Software without restriction, including without limitation the rights to* use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of* the Software, and to permit persons to whom the Software is furnished to do so,* subject to the following conditions:* * The above copyright notice and this permission notice shall be included in all* copies or substantial portions of the Software.* * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR* COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.* * http://code.google.com/p/sound-skin/* http://www.opensource.org/licenses/mit-license.php */package com.gmac.sound{	import flash.media.Sound;	import flash.events.EventDispatcher;	import flash.events.Event;		/**	* SoundGroupControl is a container used to manage multiple sounds with a single set of controls.	*/	public class SoundGroupControl extends SoundObjectContainer	{		// private		private var _groupVolume:Boolean = true;		private var _groupMute:Boolean = true;		private var _groupPlayback:Boolean = true;				/**		* Creates a new SoundGroupControl class instance.		*/		public function SoundGroupControl():void		{			super();		}			//-------------------------------------------------	// Child permissions	//-------------------------------------------------			/**		* Specifies if the <code>volume</code> property of this container's children should be managed as a group.		* While <code>groupVolume</code> is enabled (<code>true</code>),		* any new children added to the container will automatically have their volume adjusted to match the container's volume,		* and any adjustments to the container's volume will be applied to all of its children.		* The volume of each child sound may still be adjusted independently while <code>groupVolume</code> is enabled.		* You can call <code>applyVolume()</code> at any time to reset all child sounds to match the container's volume.		* @see #applyVolume()		*/		public function get groupVolume():Boolean {			return _groupVolume;		}		public function set groupVolume($enable:Boolean):void {			_groupVolume = $enable;			if ($enable) applyVolume();		}				/**		* Specifies if the <code>mute</code> property of this container's children should be managed as a group.		* While <code>groupMute</code> is enabled (<code>true</code>),		* any new children added to the container will automatically have their mute status adjusted to match the container's mute status,		* and any adjustments to the container's mute status will be applied to all of its children.		* The mute status of each child sound may still be set independently while <code>groupMute</code> is enabled.		* You can call <code>applyMute()</code> at any time to reset all child sounds to match the container's mute status.		* @see #applyMute()		*/		public function get groupMute():Boolean {			return _groupMute;		}		public function set groupMute($enable:Boolean):void {			_groupMute = $enable;			if ($enable) applyMute();		}				/**		* Specifies if playback of the container's children should be managed as a group.		* While <code>groupPlayback</code> is enabled (<code>true</code>),		* any new children added to the container will automatically be played or stopped based on the container's current <code>playing</code> status.		* Also while <code>groupPlayback</code> is enabled (<code>true</code>), children will be played when <code>play()</code> is called on the container,		* and children will be stopped when <code>stop()</code> is called on the container.		* @see #play()		* @see #stop()		*/		public function get groupPlayback():Boolean {			return _groupPlayback;		}		public function set groupPlayback($enable:Boolean):void {			_groupPlayback = $enable;			if ($enable) {				playing ? play() : stop();			}		}			//-------------------------------------------------	// Volume controls	//-------------------------------------------------			/**		* @private		*/		override public function set volume($percent:Number):void		{			if (groupVolume) super.volume = $percent;			else _volume = $percent;		}				/**		* Applys the container's volume setting to all children of the container, regardless of <code>groupVolume</code> status.		* @see #groupVolume		*/		public function applyVolume():void {			super.volume = _volume;		}				/**		* @private		*/		override public function set mute($mute:Boolean):void		{			if (groupMute) super.mute = $mute;			else _mute = $mute;		}				/**		* Applys the container's mute setting to all children of the container, regardless of <code>groupMute</code> status.		* @see #groupMute		*/		public function applyMute():void {			super.mute = _mute;		}			//-------------------------------------------------	// Playback controls	//-------------------------------------------------		/**		* Specifies if playback is currently enabled on the SoundGroupControl.		* This status is determined by the last call made to either the <code>play()</code> or <code>stop()</code> commands.		* When <code>groupPlayback</code> is enabled, new sounds added to the group will automatically be played or stopped		* based on the container's current <code>playing</code> value. 		* Note that individual child sounds will stop themselves upon completing playback,		* at which time an individual sound's playback status may no longer match the group's playback status.		* To test if there are child sounds currently playing within the group, use <code>hasPlayingSound()</code>.		* @see #groupPlayback		* @see #hasPlayingSound()		* @see #play()		* @see #stop()		*/		override public function get playing():Boolean {			return _playing;		}				/**		* Enables the container's playback status. If <code>groupPlayback</code> is enabled, all child sounds are played.		* @see #groupPlayback		* @see #playAllSounds()		* @see #applyPlayback()		*/		override public function play():void		{			_playing = true;			if (groupPlayback) super.play();		}				/**		* Plays all child sounds, regardless of <code>groupPlayback</code> status.		* @see #groupPlayback		* @see #play()		*/		public function playAllSounds():void {			super.play();		}				/**		* Disables the container's playback status. If <code>groupPlayback</code> is enabled, all child sounds are stopped.		* @see #groupPlayback		* @see #stopAllSounds()		* @see #applyPlayback()		*/		override public function stop():void		{			_playing = false;			if (groupPlayback) super.stop();		}				/**		* Stops all child sounds, regardless of <code>groupPlayback</code> status.		* @see #groupPlayback		* @see #stop()		*/		public function stopAllSounds():void {			super.stop();		}				/**		* Applys the container's current <code>playing<code> status to all child sounds, regardless of <code>groupPlayback</code> status.		* @see #groupPlayback		*/		public function applyPlayback():void {			playing ? super.play() : super.stop();		}			//-------------------------------------------------	// Container methods	//-------------------------------------------------				/**		* @private		*/		override public function addChild($child:SoundChild):SoundChild		{			$child = super.addChild($child);						if ($child != null) {				// adjust child to match container settings				if (groupVolume) $child.volume = _volume;				if (groupMute) $child.mute = _mute;				if (groupPlayback) {					playing ? $child.play() : $child.stop();				}			}			return $child;		}	}}